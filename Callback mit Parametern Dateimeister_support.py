#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    Oct 14, 2023 03:20:47 PM CEST  platform: Windows NT

import sys
import os
import configparser 
import re
import locale
import ctypes
import time


import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
from tkinter import filedialog as fd
from tkinter import messagebox
from tkinter import Scrollbar
from tkinter import ttk
from tkinter import Frame
from tkinter import Label
from tkinter import Canvas
    
from PIL import Image, ImageTk

import Dateimeister
#from Dateimeister import ToolTip

_debug = True # False to eliminate debug printing from callback functions.
_index_of_leftmost = -1
_canvas_gallery_width_visible = 0
_canvas_gallery_width_images = 0
_canvas_gallery_width_all = 0
_screen_width = 0
_screen_height = 0
_image = 0
_dict_process_image = {}
_dict_firstname_fullname = {}
_imagetype = ""
_list_processids = []
_processid_akt = 0
_processid_high = 0
_processid_low = 999999
_tooltiptext = ""
_use_camera_prefix = True
_dict_thumbnails = {}
_dict_duplicates = {}
_duplicates = False
_dict_file_image = {} # key: Imagefilename, value MyFSImage-Objekt, mit fullscale Image, canvas id, window...


from enum import Enum
class state(Enum):
    INCLUDE = 1
    EXCLUDE = 2

class MyThumbnail:
    #image = "" # hier stehen Klassenvariablen, im Gegensatz zu den Instanzvariablen

    # The class "constructor" - It's actually an initializer 
    def __init__(self, image, start, end, file, showfile, id, text_id, rect_id, lineno):
        self.image = image
        self.start = start
        self.end   = end
        self.file = file
        self.showfile = showfile
        self.image_id = id
        self.state_id_text = text_id
        self.state_id_rect = rect_id
        self.lineno = lineno        
        self.state = state.INCLUDE
        self.setState(self.state)
        
    def getImage(self):
        #print("*** retrieve Image ")
        return self.image    

    def getStart(self):
        return self.start    

    def getEnd(self):
        return self.end    

    def getFile(self):
        return self.file    
    def getShowfile(self):
        return self.showfile    

    def setId(self, id):
        self.image_id = id    
    def getId(self):
        return self.image_id    

    def setState(self, state):
        if state != self.state:
            state_changed = True
        else:
            state_changed = False
        self.state = state # neuer Status
        # change line in text
        # die Textzeile beschaffen
        lstart = "%d.0" % (self.lineno)
        lend   = "%d.0 lineend" % (self.lineno)
        # tindex = "%d.0, %d.0 lineend" % (lineno, lineno + 1)
        line    = t_text1.get(lstart, lend)
        #print ("Retrieved Textline: " + line)
        if self.state == state.INCLUDE:
            canvas_gallery.itemconfigure(self.state_id_text, state='hidden')
            canvas_gallery.itemconfigure(self.state_id_rect, state='hidden')
            linenew = line
            linenew = re.sub(rf"{_uncomment}", '', linenew)
            t_text1.delete(lstart, lend)
            t_text1.insert(lstart, linenew)
        if self.state == state.EXCLUDE and state_changed:
            canvas_gallery.itemconfigure(self.state_id_text, state='normal')
            canvas_gallery.itemconfigure(self.state_id_rect, state='normal')
            linenew = line
            linenew = re.sub(r"^", f"{_uncomment}", linenew)
            t_text1.delete(lstart, lend)
            t_text1.insert(lstart, linenew)
    def getState(self):
        return self.state   

    def getLineno(self):
        return self.lineno    

    def setLineno(self, lineno):
        self.lineno = lineno    

    def __del__(self):
        width = self.end -self.start 
        print("*** Deleting MyThumbnail-Objekt. " + self.file + " lineno in cmdfile " + str(self.lineno))

# hier speichern wir die full-size-Bilder
class MyFSImage:

    # The class "constructor" - It's actually an initializer 
    def __init__(self, image, file, id, toplevel, window, thumbnail):
        self.image = image
        self.file = file
        self.image_id = id
        self.window = window
        self.toplevel = toplevel
        self.thumbnail = thumbnail
    def setImage(self, pimg):
        self.pimg = pimg    
    def getImage(self):
        #print("*** retrieve Image ")
        return self.image    

    def getFile(self):
        return self.file    

    def setId(self, id):
        self.image_id = id    
    def getId(self):
        return self.image_id    

    def getWindow(self):
        return self.window    
    def getToplevel(self):
        return self.toplevel 
    
    def setPhotoimage(self, pimg):
        self.pimg = pimg
        
    def getThumbnail(self):
        return self.thumbnail
        
    def setScrollbar_x(self, scrollbar):
        self.scrollbar_x = scrollbar
    def getScrollbar_x(self):
        return self.scrollbar_x
    def setScrollbar_y(self, scrollbar):
        self.scrollbar_y = scrollbar
    def getScrollbar_y(self):
        return self.scrollbar_y

    def setZoomfaktor(self, zoomfaktor):
        self.zoomfaktor = zoomfaktor    
    def getZoomfaktor(self):
        return self.zoomfaktor    

    def __del__(self):
        print("*** Deleting FSImage-Objekt. File is " + str(self.file))


def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = Dateimeister.Toplevel1(_top1)
    init(root, _w1)
    root.mainloop()

def init(tk_root,gui):
    global w, root, _screen_width, _screen_height, _imagetype, _dict_process_image, _codepage, _language, \
       _button_undo, _button_redo, _uncomment, _tooltiptext, _tt, _dict_cameras, _dict_subdirs, \
        colors, color_noreport, color_lookahead, levels, o_e, o_s, o_indir, o_outdir, o_camera,\
        lb_camera, b_button1, b_button2, b_button_outdir, t_text1, l_label1, dateimeister_root, dict_gen_files, lb_gen, imagefiles, \
        canvas_gallery, cb_recursive, cb_recursive_var, cb_prefix, cb_prefix_var, cb_addrelpath, cb_addrelpath_var, \
        thumbnails, images, scroll_canvas_x, gap, context_menu, \
        _dict_image_lineno, _button_exclude, _button_include, _use_camera_prefix, _button_duplicates
#    print("Init called\n")
    windll = ctypes.windll.kernel32
    _codepage = windll.GetUserDefaultUILanguage()
    _language = locale.windows_locale[ windll.GetUserDefaultUILanguage() ]
    os.environ["LANGUAGE"]    = _language
    
    print("Codepage is: " + str(_codepage) + " language is: " + _language)
    w = gui
    root = tk_root

    inifile = "Dateimeister.ini" 
    config = configparser.ConfigParser() 
    config.read(inifile)
    default_indir  = config["dirs"]["indir"]
    default_outdir = config["dirs"]["outdir"]
    dateimeister_root = config["dirs"]["dateimeister_root"]
    print ("Dateimeister_root is " + dateimeister_root)
    
    _dict_cameras = {}
    _dict_subdirs = {}
    sectionname = "Subdirs"
    if sectionname not in config:
        messagebox.showerror("INIT", "Section " + sectionname + " not found in " + inifile)
        exit()
    else:
        for imagetype in config[sectionname]:
            _dict_subdirs[imagetype.upper()] = config[sectionname][imagetype]
            print("  {:s}, {:s}".format(imagetype.upper(), config[sectionname][imagetype]).upper())

    sectionname = "Cameras"
    regpattern = r'^\s*(\S+)\s*\(([^\)]+)\s*\)\s*$' # Imagetyp, Datentypen
    if sectionname not in config:
        messagebox.showerror("INIT", "Section " + sectionname + " not found in " + inifile)
    else:
        for camera in config[sectionname]:
            camera = camera.upper()
            imagetypes = config[sectionname][camera].upper()
            _dict_cameras[camera] = {}
            print("Kamera: " + camera + " Imagetypes: " + imagetypes)
            list_imagetypes = imagetypes.split('+')
            for imagetype in list_imagetypes:
                imagetype = imagetype.strip()
                match = re.search(regpattern, imagetype)
                if match:
                    thistype     = match.group(1).upper() # Keys immer upper
                    if thistype not in _dict_subdirs:
                        messagebox.showerror("INIT", "Imagetype " + thistype + " not found in section Subdirs in " + inifile)
                        exit()
                    _dict_cameras[camera.upper()][thistype] = []
                    endungen = match.group(2)
                    print("   Typ: " + thistype + " Endungen: " + endungen)
                    _dict_cameras[camera.upper()][thistype.upper()] = endungen
                else:
                    print("   Imagetype " + imagetype + " kein Match fuer " + regpattern)

    sectionname = "process_image"
    if sectionname not in config:
        messagebox.showerror("INIT", "Section " + sectionname + " not found in " + inifile)
        exit()
    else:
        for type in config[sectionname]:
            print("  {:s}, {:s}".format(type.upper(), config[sectionname][type]).upper())
            _dict_process_image[type.upper()] = config[sectionname][type].upper()
    _uncomment = config["misc"]["uncomment"] + " "        
    
    o_indir   = w.Entry_indir
    o_outdir  = w.Entry_outdir
    o_camera  = w.Entry_camera
    lb_camera = w.Listbox1
    b_button1 = w.Button1
    b_button2 = w.Button2
    b_button_outdir = w.Button_outdir
    t_text1 = w.Text1
    l_label1 = w.Label1
    lb_gen   = w.Listbox_gen
    _button_include = w.Button_include
    _button_exclude = w.Button_exclude
    _button_include.config(state = DISABLED)
    _button_exclude.config(state = DISABLED)
    _button_undo = w.Button_undo
    _button_redo = w.Button_redo
    _button_undo.config(state = DISABLED)
    _button_redo.config(state = DISABLED)
    _button_duplicates = w.Button_duplicates
    _button_duplicates.config(state = DISABLED)
    
    # Scrollbars
    V = Scrollbar(t_text1)
    V.pack(side=RIGHT, fill=Y)
    V.config(command=t_text1.yview)
    t_text1.config(yscrollcommand=V.set)  
    H = Scrollbar(t_text1, orient = HORIZONTAL)
    H.pack(side=BOTTOM, fill=BOTH)
    H.config(command=t_text1.xview)
    t_text1.config(xscrollcommand=H.set)  
    t_text1.configure(wrap="none")

    cb_recursive = w.Checkbutton1
    cb_recursive_var = w.cb1_val
    cb_recursive_var.set(1)
    
    cb_prefix = w.Checkbutton_use_camera_name
    cb_prefix_var = w.cb_prefix_var
    cb_prefix_var.set(1)

    cb_addrelpath = w.Checkbutton_addrelpath
    cb_addrelpath_var = w.cb_addrelpath_var
    cb_addrelpath_var.set(0)

    
    canvas_gallery = w.Canvas1
    # Scrollbars
    scroll_canvas_x = tk.Scrollbar(canvas_gallery, orient="horizontal", command=xview)
    scroll_canvas_x.place(relx=0.0, rely=0.95, relheight=0.05, relwidth=0.999)
    #scroll_canvas_x.grid(row=1, column=0, sticky="WE")
    #scroll_canvas_x.pack(side=BOTTOM, fill=X)
    canvas_gallery.config(xscrollcommand = scroll_canvas_x.set, scrollregion=canvas_gallery.bbox("all"))

    # Create the context menu
    context_menu = tk.Menu(canvas_gallery, tearoff=0)
    context_menu.add_command(label="Exclude", command=canvas_image_exclude)    
    context_menu.add_command(label="Show"   , command=canvas_image_show)    
   
    # Events
    # Button 1 single haben wir deaktiviert, weil double immer auch zuerst single auslöst
    # deshalb exlude und show über Kontext-Menü (rechte Maustaste), Show zusätzlich auch mit Doppelclick
    #canvas_gallery.bind("<Button-1>", canvas_gallery_exclude)
    canvas_gallery.bind("<Double-Button-1>", canvas_gallery_show)
    # Pfeitasten fürs scrollen
    canvas_gallery.bind("<Left>",  lambda event: xview("scroll", -1, "units"))
    canvas_gallery.bind("<Right>", lambda event: xview("scroll",  1, "units"))
    # Bind the context menu to the canvas widget
    canvas_gallery.bind("<Button-3>", show_context_menu)    
    canvas_gallery.bind('<Motion>', tooltip_imagefile)    
    #canvas_gallery.bind('<Button-1>', tooltip_imagefile)    
    root.bind("<Configure>", on_window_resize)
    root.bind("<Destroy>",   on_window_destroy)
    # strg-z, y
    canvas_gallery.bind('<Control-z>', lambda event: process_undo(event))
    canvas_gallery.bind('<Control-y>', lambda event: process_redo(event))
    
    for key in _dict_cameras:
        lb_camera.insert(END, key)
    lb_camera.selection_set(END)
    insert_text(o_indir, default_indir);
    insert_text(o_outdir, default_outdir);
    l_label1.config(text = "Messages")
    dict_gen_files = {}
    imagefiles = {}
    thumbnails = {}
    images = []
    _dict_image_lineno = {}
    gap = 10
    
    # Fenstergröße
    _screen_width  = int(root.winfo_screenwidth() * 0.9)
    _screen_height = int(root.winfo_screenheight() * 0.8)
    print("Bildschirm ist " + str(_screen_width) + " x " + str(_screen_height))
    width,height=_screen_width,_screen_height
    v_dim=str(width)+'x'+str(height)
    root.geometry(v_dim)
    #my_w.maxsize(300,220)  # (maximum ) width , ( maximum) height
    #my_w.minsize(250,220)  # (minimum ) width , ( minimum) height
    root.resizable(False, False)
    _tt = Dateimeister.ToolTip(canvas_gallery, "no images available", delay=0, follow = True)

def tooltip_imagefile(event):
    global _tt, _tooltiptext
    # Tooltip
    #x, y = canvas_gallery.winfo_pointerxy()
    text = "no image available"
    if len(thumbnails) > 0:
        canvas_x = canvas_gallery.canvasx(event.x)
        canvas_y = canvas_gallery.canvasy(event.y)
        thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            text = thumbnail.getFile()
        #print("Image clicked: " + text)
        if text != _tooltiptext:
            _tt.update(text)
            _tooltiptext = text
 

def on_window_resize(event): # das funktioniert nicht rihtig. Die übergebenen Zahlen sind falsch und der Handler wird unglaublich oft aufgerufen
    width = event.width
    height = event.height
    #print("Window resized to width: " + str(width) + " height: " + str(height))

def Press_indir(*args):
    if _debug:
        print('Dateimeister_support.Press_indir')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    indir = fd.askdirectory() 
    print ("indir %s" % indir)
    clear_textbox(o_indir)
    insert_text(o_indir, indir)

def Press_outdir(*args):
    if _debug:
        print('Dateimeister_support.Press_outdir')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    #outdir = fd.askopenindir() 
    outdir = fd.askdirectory() 
    print ("outdir %s" % outdir)
    clear_textbox(o_outdir)
    insert_text(o_outdir, outdir)

def B_camera_press(*args):
    if _debug:
        print('Dateimeister_support.B_camera_press')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    # get selected indices
    selected_indices = lb_camera.curselection()
    thiscamera = ",".join([lb_camera.get(i) for i in selected_indices]) # weil wir single für die Listbox gewählt haben
    print ("Kamera ist " + thiscamera)
    clear_textbox(o_camera)
    insert_text(o_camera, thiscamera)
    
def Press_generate(*args):
    global _dict_firstname_fullname, _dict_duplicates
    if _debug:
        print('Dateimeister_support.B_camera_press')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    # get indir, outdir, camera
    indir  = o_indir.get()
    outdir = o_outdir.get()
    thiscamera = o_camera.get();
    if not indir:
        messagebox.showerror("showerror", "kein Indir ausgewählt")
        b_button1.focus_set()
        return None
    if not outdir:
        messagebox.showerror("showerror", "kein outdir ausgewählt")
        b_button_outdir.focus_set()
        return None
    if not thiscamera:
        messagebox.showerror("showerror", "keine Kamera ausgewählt")
        b_button2.focus_set()
        return None
    #dateimeister_root      = "C:/Arbeit/Dateimeister"
    dateimeister_conf      = dateimeister_root + "/programm/conf"
    dateimeister_programme = dateimeister_root + "/programm/programme"
    dateimeister_daten     = dateimeister_root + "/daten"
    if cb_recursive_var.get():
        os.environ["REKURSIV"]      = "J"
    else:
        os.environ["REKURSIV"]      = "N"
    if cb_prefix_var.get():
        _use_camera_prefix = True
    else:
        _use_camera_prefix = False
    if cb_addrelpath_var.get():
        os.environ["ADDRELPATH"]      = "j"
    else:
        os.environ["ADDRELPATH"]      = "n"
    os.environ["TEMPLATEDATEI"] = dateimeister_conf + "/dateimeister-templates.txt"
    os.environ["TEMPLATENAME"]  = "mcopy_gt"
    os.environ["REGELDATEI"]    = dateimeister_conf + "/dateimeister-regeln.pl"
    os.environ["INDIR"]         = indir
    print ("INDIR is  " + indir)
    my_cmd = "perl dateimeister.pl " + dateimeister_conf + "/dateimeister.properties " + dateimeister_daten + "/log"
    os.chdir(dateimeister_root + "/Programm/programme")
    clear_text(t_text1)
    clear_textbox(lb_gen)

    _dict_duplicates = {}
    for dateityp in _dict_cameras[thiscamera]:
        subdir = _dict_subdirs[dateityp]
        thisoutdir = outdir + "/" + subdir
        os.environ["ZIEL"] = thisoutdir
        endung= _dict_cameras[thiscamera][dateityp]
        _dict_duplicates[dateityp]= {}
        print ("OUTDIR is " + thisoutdir + " ENDUNG is " + endung)
        os.environ["ZIEL"]    = thisoutdir
        os.environ["OUTFILE"] = dateimeister_daten + "/gen/_kopiere-" + dateityp + ".cmd"
        os.environ["MUSTER"]  = "." + endung
        #print ("OUTFILE is " + os.environ["OUTFILE"])
        # wenn die Endung wegen mehrerer Möglichkeiten (jpeg, jpg) mehr al 1 Eintrag hat, nehmen wir den letzten
        #print("'(.*?)\.({:s})' 'PIC_{:s}_$1.$2'".format(dateityp, thiscamera))
        if _use_camera_prefix:
            zieldateiname = "\"'^(.*?)$\' 'PIC_{:s}_$1'\"".format(thiscamera)
        else:
            zieldateiname = "\"'^(.*?)$\' '$1'\"".format(thiscamera)
        print("Zieldateiname " + zieldateiname)
        os.environ["ZIELDATEINAME"] = zieldateiname
        my_cmd_output = os.popen(my_cmd)
        for line in my_cmd_output:
            insert_text(t_text1, line)

        # generierte Dateien in dict festhalten
        dict_gen_files[dateityp] = os.environ["OUTFILE"]
        
        # alle Dateien aus der gerade verarbeiteten cmd-Datei tragen wir in _dict_jpeg ein, wenn ihre Endung in der INI-Datei den Typ JPEG hat
        # und wir tragen die Dubletten ein       
        regpattern = r'[\/\\]([^\/\\."]+)\.([^\/\\."]+)"\s*"([^"]+)"' # zwischen dem letzten / bzw. \ und dem letzten Punkt steht der Vorname, Nachname danach, gefolgt von Zieldatei
        regpattern_source = r'"([^"]+)"' # Sourcefile
        target_file = ""
        source_file = ""
        with open(dict_gen_files[dateityp]) as f:
            lines = f.readlines()
            lineno = 0
            for line in lines:
                lineno += 1
                b_match = False
                match = re.search(regpattern, line)
                if match:
                    firstname = match.group(1)
                    lastname  = match.group(2).upper()
                    target_file = match.group(3)
                    #print("GENERATE: firstname / lastname = " + firstname + " / " + lastname + " target: " + target_file)
                    b_match = True
                else: 
                    #print("GENERATE unable to find firstname, lastname in: " + line)
                    a = 1
                if (b_match == True):
                    process_type = _dict_process_image[lastname].upper()
                    if (process_type == "JPEG"):
                        # den vollen Dateinmen bestimmen
                        regpattern_file = r'^[^"]+"([^"]+)"' # zwischen den ersten hochkommas steht der Dateiname
                        match = re.search(regpattern_file, line)
                        if match:
                            imagefile = match.group(1)
                            if firstname.upper() not in _dict_firstname_fullname:
                                _dict_firstname_fullname[firstname.upper()] = []
                            _dict_firstname_fullname[firstname.upper()].append(imagefile) # es kann ja in den ganzen Verzeichnissen mehrere jpegs mit demselben Vornamen geben  
                # jetzt noch mögliche Duplikate festhalten 
                #print(line)
                match = re.search(regpattern_source, line)
                if match:
                    source_file = match.group(1)
                    #print("Source file is: " + source_file + " target: " + target_file)
                    if target_file not in _dict_duplicates[dateityp]:
                        _dict_duplicates[dateityp][target_file] = []
                    _dict_duplicates[dateityp][target_file].append(source_file) # Duplicates  
                

    l_label1.config(text = "Output from Dateimeister.pl")
            
    # die generierten Dateien in die Listbox eintragen
    for key in dict_gen_files:
        lb_gen.insert(END, key)
    lb_gen.select_set(0)
    imagefiles = {}
        
def Button_be_pressed(*args):
    global _canvas_gallery_width_visible
    global _canvas_gallery_width_images
    global _canvas_gallery_width_all
    global _lastposition
    global _imagetype, _list_processids, _processid_high, _processid_akt, _processid_low, _dict_duplicates, _duplicates
    
    # reset all process-states
    _list_processids = []
    _processid_akt  = 0
    _processid_high = 0
    _processid_low  = 999999
    _button_undo.config(state = DISABLED)    
    _button_redo.config(state = DISABLED)    
    #print(_dict_firstname_fullname)
    if _debug:
        print('Dateimeister_support.Press_be_out')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    clear_text(t_text1)
    canvas_gallery.delete("all")

    regpattern = r'^[^"]+"([^"]+)"' # zwischen den ersten hochkommas steht der Dateiname
    selected_indices = lb_gen.curselection()
    thistype = ",".join([lb_gen.get(i) for i in selected_indices]) # weil wir single für die Listbox gewählt haben
    filename =dict_gen_files[thistype]
    imagetype = thistype
    _imagetype = imagetype # auch in globaler Variable festhalten, da wir das an vielen Stellen brauchen
    # in Python kann man offenbar nicht automatisch einen Eintrag anlegen, indem man ein Element an die Liste hängt
    imagefiles[imagetype] = []
    if imagetype in thumbnails:
        thumbnails[imagetype].clear() # damit werden implizit jetzt alle Bilder gelöscht
    else:
        thumbnails[imagetype] = []
    l_label1.config(text = "Output from Dateimeister.pl : " + filename)
    _dict_image_lineno[imagetype] = {} # in Python muss das sein, sonst gehts in der nächsten Ebene nicht
    with open(dict_gen_files[thistype]) as f:
        lines = f.readlines()
        lineno = 0
        for line in lines:
            lineno += 1
            insert_text(t_text1, line)
            # match = re.search(r'"([^"]+)"', str)
            match = re.search(regpattern, line)
            if match:
                imagefile = match.group(1)
                imagefiles[imagetype].append(imagefile)
                _dict_image_lineno[imagetype][imagefile] = lineno
                #print("Match G1 is:    " + imagefile + " Typ is: " + imagetype + " Lineno is: " + str(lineno))
            #else:
                #print ("no match in " + line + " for " + regpattern)
    for thistype in imagefiles:
        files = imagefiles[thistype]
        #print(thistype + " files:")
        for file in files:
            a = 1 # damit der Block nicht leer ist
            #print("  " + file)
    
    # wir suchen in der cmd-Datei die Endung für jedes Imagefile. Damit suchen wir in _dict_process_image nach einem Eintrag
    # wenn JPEG, dann verarbeiten wir die Zeile und verwenden das mutmaßliche JPEG_Bild in der Gallerie. Wenn use_jpeg gefunden wird
    # suchen wir nach einem passenden JPEG. Falls die Endung im dict nicht gefunden wird, verwenden wir ebenfalls use_jpeg. Später
    # können hier passende RAW-DLLs aufgerufen werden, z.b. mit Name der DLL in der Ini-Datei
    canvas_height = canvas_gallery.winfo_height() - scroll_canvas_x.winfo_height()
    _canvas_gallery_width_visible = canvas_gallery.winfo_width() # Fensterbreite
    _lastposition = 0
    _dict_thumbnails[imagetype] = {}
    for file in imagefiles[imagetype]:
        # wir brauchen die Endung der Datei und den Vornamen
        regpattern = r'[\/\\]([^\/\\."]+)\.([^\/\\."]+)' # zwischen dem letzten / bzw. \ und dem letzten Punkt steht der Vorname, Nachname danach
        match = re.search(regpattern, file)
        if match:
            firstname = match.group(1)
            lastname  = match.group(2).upper()
            #print("firstname / lastname = " + firstname + " / " + lastname)
        else: 
            print("unable to find firstname, lastname for: " + file)
        # wir brauchen die Methode aus der ini-Datei, mit der wir das Bild verarbeiten sollen
        process_type = _dict_process_image[lastname].upper()
        if (process_type == "JPEG"):
            showfile = file # Image-file to show in Canvas
        elif process_type == "USE_JPEG":
            if firstname.upper() in _dict_firstname_fullname:
                showfile = _dict_firstname_fullname[firstname.upper()][-1]
                #print ("*** JPEG found for " + file + " using " + showfile)
            else:
                showfile = "none"
                print ("*** No JPEG found for " + file + " using " + showfile)
        else: # hier später mal ein Aufruf, um RAW oder was auch immer nach JPEG zu konvrtieren, aber jetzt erstmal Default nciht gefunden anzeigen
            showfile = "none"
        if  showfile != "none":
            img  = Image.open(showfile)
            image_width_orig, image_height_orig = img.size
            faktor = canvas_height / image_height_orig
            newsize = (int(image_width_orig * faktor), int(image_height_orig * faktor))
            r_img = img.resize(newsize, Image.Resampling.NEAREST)
            image_width, image_height = r_img.size
            #print("try to print " + file + " width is " + str(image_width) + "(" + str(image_width_orig) + ")" + " height is " + str(image_height) + "(" + str(image_height_orig) + ")" \
            #   + " factor is " + str(faktor))
            pimg = ImageTk.PhotoImage(r_img)
            # an den Thumbnails führen wir einige Attribute, außerdem sorgt die Liste dafür, dass der Garbage-Kollektor das Bild nicht löscht.
            # indem wir es in eine Liste einfügen, bleibt der Referenz-Count > 0
            id = canvas_gallery.create_image(_lastposition, 0, anchor='nw',image = pimg, tags = 'images')
            text_id = canvas_gallery.create_text(_lastposition, 0, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
            rect_id = canvas_gallery.create_rectangle(canvas_gallery.bbox(text_id), outline="blue", fill = "white")
            canvas_gallery.tag_raise("text")
            myimage = MyThumbnail(pimg, _lastposition, _lastposition + image_width, file, showfile, id, text_id, rect_id, _dict_image_lineno[imagetype][file])
            thumbnails[imagetype].append(myimage)
            _dict_thumbnails[imagetype][file] = myimage # damit können wir auf thumbnails mit den Sourcefilenamen zugreifen, z.B. für Duplicates
            _lastposition += image_width + gap 
            # print ("*** File " + file + " Type " + imagetype + " Lineno: " + str(_dict_image_lineno[imagetype][file]))
            img.close()
        else: # wir haben kein Bild, ein Rechteck einfügen
            image_height = canvas_height
            image_width  = int(canvas_height * 4 / 3)
            id = canvas_gallery.create_rectangle(_lastposition, 0, _lastposition + image_width, canvas_height, fill="blue", tags = 'images')
            text_id = canvas_gallery.create_text(_lastposition, 0, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
            rect_id = canvas_gallery.create_rectangle(canvas_gallery.bbox(text_id), outline="blue", fill = "white")
            canvas_gallery.tag_raise("text")
            myimage = MyThumbnail(0, _lastposition, _lastposition + image_width, file, showfile, id, text_id, rect_id, _dict_image_lineno[imagetype][file])
            thumbnails[imagetype].append(myimage)
            _dict_thumbnails[imagetype][file] = myimage
            _lastposition += image_width + gap 
    # gap haben wir einmal zuviel (fürs letzte) gezählt
    _lastposition -= gap
    #print ("Canvas_gallery sichtbare Breite : " + str(_canvas_gallery_width_visible))
    # damit wir am Ende auch bis zum letzten einzelnen Bild scrollen können, fügen wir ein Rechteck ein
    if len(thumbnails[imagetype]) > 0: 
        thumbnail = thumbnails[imagetype][-1]
        rect_len = _canvas_gallery_width_visible - (thumbnail.getEnd() - thumbnail.getStart() + gap)
        canvas_gallery.create_rectangle(_lastposition, 0, _lastposition + rect_len, canvas_height, fill="yellow")
        canvas_gallery.config(scrollregion = canvas_gallery.bbox('all')) 
        _canvas_gallery_width_images = canvas_gallery.bbox('images')[2]
        _canvas_gallery_width_all    = canvas_gallery.bbox('all')[2]
        #print ("Canvas_gallery totale Breite(Images): " + str(_canvas_gallery_width_images) + " totale Breite(All): " + str(_canvas_gallery_width_all) \
        #    + " visible: " + str(_canvas_gallery_width_visible) + " lastposition: " + str(_lastposition))
    
    # Pfeiltasten für Scrollen einrichten
    canvas_gallery.focus_set()
    _button_include.config(state = NORMAL)
    _button_exclude.config(state = NORMAL)
    #print(_dict_duplicates)
    historize_process()
    
    _duplicates = False
    for mytarget in _dict_duplicates[imagetype]:
        #print("Duplcate Key: " + mytarget) 
        mylist = _dict_duplicates[imagetype][mytarget]
        if len(mylist) > 1: # es gibt 1...n Duplicates
            _duplicates = True
            break
    if _duplicates:
        _button_duplicates.config(state = NORMAL)
    else:
        _button_duplicates.config(state = DISABLED)

def get_thumbnail_by_position(canvas_x, canvas_y):
    index = -1
    found = False
    for thumbnail in thumbnails[_imagetype]:
        start = thumbnail.getStart()
        end   = thumbnail.getEnd()
        if (canvas_x >= start and canvas_x <= end):
            index = thumbnails[_imagetype].index(thumbnail)
            #print("retrieved " + thumbnail.getFile() + " Index: " + str(index))
            found = True
            break
    if not found:
        thumbnail = None
        index = None
    return (thumbnail, index)

def canvas_gallery_show(event):
    #print('bbox', canvas_gallery.bbox('images'))
    canvas_gallery.focus_set()

    canvas_x = canvas_gallery.canvasx(event.x)
    canvas_y = canvas_gallery.canvasy(event.y)
    thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
    if thumbnail is not None:
        item_id = thumbnail.getId()
    display_image(thumbnail)

def xview(*args):
    #print (*args)
    global _canvas_gallery_width_visible
    global _canvas_gallery_width_images
    global _canvas_gallery_width_all
    s1 = 0.0
    s2 = 1.0
    scrolldelta = 0
    width_scrollbar = scroll_canvas_x.winfo_width()
    #print ("Scroll Canvas_gallery totale Breite(Images): " + str(_canvas_gallery_width_images) + " totale Breite(All): " + str(_canvas_gallery_width_all) \
    #    + " visible: " + str(_canvas_gallery_width_visible) + " Scrollbarwidth: " + str(width_scrollbar) + " BBOX: " + str(canvas_gallery.bbox('all')))
    slider_width = int((_canvas_gallery_width_visible / _canvas_gallery_width_all) * width_scrollbar)
    # aktuelle Scroll-Position des Canvas
    canvas_x = canvas_gallery.canvasx(0)
    canvas_y = canvas_gallery.canvasy(0)
    # aktuelle position der Scrollbar
    scrollposition = scroll_canvas_x.get()[0]
    
    #print("scroll_position_canvas_x: " + str(canvas_x) + " scroll_position Scrollbar: " + str(scrollposition))
    # wenn wir die Pfeiltasten betätigen, wollen wir auf den Anfang des nächsten (vorherigen) Bildes scrollen.
    # wenn das aktuelle Bild nur teilweise zusehen ist, scrollen wir bei Linkstaste auf den Bildbeginn
    if len(args) == 3 and args[2] == "units":
        # den scrollbetrag auf die Größe des Bildes am linken Rand setzen
        thumbnail, index = get_thumbnail_by_position(canvas_x + 11, canvas_y)
        if thumbnail is not None:
            if int(args[1]) > 0:
                scrolldelta = (thumbnail.getEnd() - canvas_x + gap)
            else:
                if canvas_x - thumbnail.getStart() > 10: # Bild links abgeschnitten, an den Anfang scrollen
                    scrolldelta = (thumbnail.getStart() - canvas_x) # ist dann negativ, was wir ja wollen
                    #print("Bild links abgeschnitten, weil canvas_x = " + str(canvas_x) + " und Bildstart = " + str(thumbnail.getStart()))
                else: #Bild ist vollständig zu sehen, also zurück zum nächsten
                    if index > 0: # es gibt einen Vorgänger
                        scrolldelta = (thumbnails[_imagetype][index - 1].getStart()) - canvas_x
                        #print("Vorgänger ist: " + thumbnails[_imagetype][index - 1].getFile() + " Start: " + str(thumbnails[_imagetype][index - 1].getStart())\
                        #    + " canvas_x is: " + str(canvas_x) + " scrolldelta is: " + str(scrolldelta))
            
            new_canvas_x = canvas_x + scrolldelta
            # nach links scrollen machr keinen Sinn, wenn wir schon ganz links stehen, analog rechts
            if (int(args[1]) < 0 and canvas_x <= 0) or (int(args[1]) > 0 and new_canvas_x >= _canvas_gallery_width_images):
               return
            s2 = new_canvas_x / _canvas_gallery_width_all
            s1 = (new_canvas_x - slider_width) / _canvas_gallery_width_all
            #print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
        scroll_canvas_x.set(s1, s2)
        canvas_gallery.xview('moveto', s2)
    else:
        #if (1 == 0):
            #return
        canvas_gallery.xview(*args)

def display_image(thumbnail):
    file = thumbnail.getShowfile()
    # wenn das Bild schon in einem Fenster angezeigt wird, dann verwenden wir dieses
    if file in _dict_file_image:
        print ("FSImage exists for file: " + file)
        fs_image = _dict_file_image[file]
        window = fs_image.getToplevel()
        img = fs_image.getImage()
        w2    = fs_image.getToplevel()
        root2 = fs_image.getWindow()
        f = w2.Canvas_image
        # Scrollbars
        V_I = fs_image.getScrollbar_y()
        H_I = fs_image.getScrollbar_x()
        faktor = fs_image.getZoomfaktor()
        f.delete('images')
        #return
    else: # ein neues Objekt anlegen und in _dict_file_image eintragen
        print ("FSImage does not exist for file: " + file)
        # Create secondary (or popup) window.
        root2 = tk.Toplevel()
        w2 = Dateimeister.Toplevel2(root2)
        img  = Image.open(file)
        fs_image = MyFSImage(img, file, 0, w2, root2, thumbnail)
        _dict_file_image[file] = fs_image
        f = w2.Canvas_image
        # zur Behandlung von Events brauchen wir den Imagefile-Namen. Darüber kommen wir an das Window und
        # das Image selbst. Das ist erforderlich, weil wir ja mehrere Fenster haben können
        # kurz gesagt: mit dieser Methode kann man Parameter an den Handler übergeben
        def zoom_handler():
            return __zoom_handler(filename = file)
        w2.Button_zoom.config(command = zoom_handler)
        def mousewheel_handler(event):
            return __mousewheel_handler(event, filename = file)
        f.bind("<MouseWheel>", mousewheel_handler)
        #f.config(command = mousewheel_handler)
        def close_handler():
            return __close_handler(filename = file)
        root2.protocol("WM_DELETE_WINDOW", close_handler)

        root2.title(file)
        width,height=_screen_width,_screen_height
        v_dim=str(width)+'x'+str(height)
        root2.geometry(v_dim)
        root2.resizable(False, False)

        # Scrollbars
        V_I = Scrollbar(f)
        V_I.config(command=f.yview)
        f.config(yscrollcommand=V_I.set)  
        H_I = Scrollbar(f, orient = HORIZONTAL)
        H_I.config(command=f.xview)
        f.config(xscrollcommand=H_I.set)
        fs_image.setScrollbar_x(H_I)
        fs_image.setScrollbar_y(V_I)
        img.close
        faktor = 1.0

    V_I.pack(side=RIGHT, fill=Y)
    H_I.pack(side=BOTTOM, fill=BOTH)

    image_width_orig, image_height_orig = img.size
    canvas_width  = f.winfo_width()  - V_I.winfo_reqwidth()
    canvas_height = f.winfo_height() - V_I.winfo_reqheight()
    #faktor = min(canvas_height / image_height_orig, canvas_width / image_width_orig)
    newsize = (int(image_width_orig * faktor), int(image_height_orig * faktor))
    r_img = img.resize(newsize, Image.Resampling.NEAREST)
    pimg = ImageTk.PhotoImage(r_img)
    fs_image.setPhotoimage(pimg) # brauchen wir eigentlich, hindert aber den Garbage Kolletor am Zuschlageb
    id = f.create_image(0, 0, anchor='nw',image = pimg, tags = 'images')
    print("*** faktor is: " + str(faktor) + " canvas_height: " + str(canvas_height) + " origsize: " + str(img.size) + " newsize: " +str(newsize) + " ID is: " +str(id))
    f.config(scrollregion = f.bbox("all")) 
    # id festhalten
    fs_image.setId(id)
    fs_image.setZoomfaktor(faktor)
    root2.mainloop()

def __zoom_handler(filename):
    print("Zoom-Händler imagefile is = " + filename)
    button_zoom(filename)

def __close_handler(filename):
    print("close-Händler imagefile is = " + filename)
    t = _dict_file_image[filename]
    obj =  t.getWindow()
    obj.destroy()
    _dict_file_image.pop(filename)
    del t
    
def __mousewheel_handler(event, filename):
    t = _dict_file_image[filename]
    zoomfaktor    = t.getZoomfaktor()
    zoomincrement = (event.delta / 120) / 100 # Windows-spezifisch, macOS: keine Division durch 120
    if (zoomincrement > 0):
        if zoomfaktor + zoomincrement <= 1:
            newzoomfaktor = zoomfaktor + zoomincrement
            t.setZoomfaktor(newzoomfaktor)
        else:
            newzoomfaktor = 1.0
            t.setZoomfaktor(newzoomfaktor)
    else: # lt 0
        if zoomfaktor + zoomincrement >= .1:
            newzoomfaktor = zoomfaktor + zoomincrement
            t.setZoomfaktor(newzoomfaktor)
        else:
            newzoomfaktor = 0.1
            t.setZoomfaktor(newzoomfaktor)
    print ("Mousewheel Delta is " + str(event.delta) + " Zoomfaktor old / new is: " + str(zoomfaktor) + ' / ' + str(newzoomfaktor))
    image_zoom(filename, zoomfaktor)

def button_zoom(filename):
    print("*** Zoom..." + filename)
    fs_image   = _dict_file_image[filename] # retrieve object containing the Image

    zoomincrement = 0.1
    zoomfaktor    = fs_image.getZoomfaktor()
    newzoomfaktor = zoomfaktor + min(zoomincrement, 1.0 - zoomfaktor)
    fs_image.setZoomfaktor(newzoomfaktor)
    print ("Zoomfaktor old / new is: " + str(zoomfaktor) + ' / ' + str(newzoomfaktor))
    image_zoom(filename, zoomfaktor)

def image_zoom(filename, zoomfaktor):
    print("*** Zoom..." + filename)
    fs_image   = _dict_file_image[filename] # retrieve object containing the Image
    toplevel   = fs_image.getToplevel()
    root       = fs_image.getWindow()
    img        = fs_image.getImage()
    canvas_id  = fs_image.getId()
    
    # alles noch nicht so schön. in dieser Funktion zeigen wir das Bild formatfüllend an, der Faktor ist i.d.R. < 1, damit es in den Rahmen passt
    # wenn wir den Button noch einmal drücken, wird der Zoomfaktor immer um 0.1 erhöht, bis 1 erreicht ist. Das ist dann das Bild in voller Auflösung
    # wenn der Zoomfaktor < 1 ist, rufen wir einfach display_image auf
    zoomincrement = 0.1
    zoomfaktor    = fs_image.getZoomfaktor()
    if zoomfaktor < 1.0: # wir brauchen die Scrollbars
        display_image(fs_image.getThumbnail())
        return
    else:
        print("max Zoom  1.0 reached")
    f = toplevel.Canvas_image
    f.update()
    image_width_orig, image_height_orig = img.size
    canvas_width  = f.winfo_width()
    canvas_height = f.winfo_height()
    faktor = min(canvas_height / image_height_orig, canvas_width / image_width_orig)
    newsize = (int(image_width_orig * faktor), int(image_height_orig * faktor))
    print("*** faktor is: " + str(faktor) + " canvas_height: " + str(canvas_height) + " origsize: " + str(img.size) + " newsize: " +str(newsize) + " ID is: " +str(canvas_id))
    r_img = img.resize(newsize, Image.Resampling.NEAREST)
    pimg = ImageTk.PhotoImage(r_img)
    fs_image.setPhotoimage(pimg) # brauchen wir eigentlich, hindert aber den Garbage Kolletor am Zuschlagen
    f.delete('images')
    #f.itemconfig(canvas_id, image = pimg)
    id = f.create_image(0, 0, anchor='nw',image = pimg, tags = 'images')
    f.update()
    f.config(scrollregion = f.bbox("all")) 
    fs_image.getScrollbar_x().pack_forget()
    fs_image.getScrollbar_y().pack_forget()
    fs_image.setZoomfaktor(faktor)
    fs_image.setId(id)
   
def show_context_menu(event):
    global context_men, _event
    # das Event müssen wir speichern, da die eigenlichen Funktionen die x und y benötigen
    _event = event
    # falls wir keine anzeigbare Datei haben, müssen wir show-Item disablen
    canvas_x = canvas_gallery.canvasx(event.x)
    canvas_y = canvas_gallery.canvasy(event.y)
    thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
    if thumbnail is not None:
        if thumbnail.getImage() == 0:
            print(" No Image availabl for " + thumbnail.getFile())
            context_menu.entryconfig(1, state="disabled")
        else:
            context_menu.entryconfig(1, state="normal")
        if thumbnail.getState() == state.INCLUDE:
            context_menu.entryconfig(0, label = "Exclude " + thumbnail.getFile())
        else:
            context_menu.entryconfig(0, label = "Include " + thumbnail.getFile())
    context_menu.entryconfig(1, label = "Show " + thumbnail.getFile())
    context_menu.post(event.x_root, event.y_root)
    
def canvas_gallery_exclude(event):
    #print('bbox', canvas_gallery.bbox('images'))
    canvas_gallery.focus_set()

    canvas_x = canvas_gallery.canvasx(event.x)
    canvas_y = canvas_gallery.canvasy(event.y)
    thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
    if thumbnail is not None:
        linenew = ""
        #print("State is: " + str(thumbnail.getState()))
        if thumbnail.getState() == state.INCLUDE:
            thumbnail.setState(state.EXCLUDE)
        else: # toggle to not exclude, delete Item
            thumbnail.setState(state.INCLUDE)
    historize_process()
    
def Button_exclude_all(*args):
    for thumbnail in thumbnails[_imagetype]:
        if thumbnail.getState() == state.INCLUDE:
            thumbnail.setState(state.EXCLUDE)
    historize_process()
            
def Button_include_all(*args):
    for thumbnail in thumbnails[_imagetype]:
        if thumbnail.getState() == state.EXCLUDE:
            thumbnail.setState(state.INCLUDE)
    historize_process()

def historize_process():
    global _processid_akt, _processid_high, _processid_low, _list_processids, _dict_process_image
    _processid_high += 10
    _processid_akt = _processid_high
    if _processid_akt < _processid_low: # das ist nur einmal erfüllt, da auf high value initialisiert
        _processid_low  = _processid_akt
    _list_processids.append(_processid_akt)
    print ("Processid_high is now: " + str(_processid_high) + " Processid_akt is now: " + str(_processid_akt) + " List is: " + str(_list_processids))
    # wir bilden jetzt zu der aktuellen processid eine Liste der states der thumbnails
    _dict_process_image[_processid_akt] = []
    for thumbnail in thumbnails[_imagetype]:
        _dict_process_image[_processid_akt].append(thumbnail.getState())
    update_button_state() # refer to function comment
    
    # UNDO / REDO disabeln, wenn Aktion nicht möglich, weil es keine frühere / spätere Bearbeitung gibt
    if _processid_akt > _processid_low:
        _button_undo.config(state = NORMAL)
    else:
        _button_undo.config(state = DISABLED)
    if _processid_akt < _processid_high:
        _button_redo.config(state = NORMAL)
    else:
        _button_redo.config(state = DISABLED)

def canvas_image_exclude():
    print("Context menu exlude")
    canvas_gallery_exclude(_event)

def canvas_image_show():
    print("Context menu show")
    canvas_gallery_show(_event)
    
# Undo /Redo Funktionen
def process_undo(event):
    global _processid_akt, _processid_high, __processid_low, list_processids
    print("ctrl_z pressed.")
    if _button_undo["state"] == DISABLED:
        messagebox.showinfo("UNDO", "no further processes which can be undone")
        return
    i = len(_list_processids) - 1
    while i >= 0:
        print (" UNDO I: " + str(i) + " processid von i: " + str(_list_processids[i]) + " processid_akt: " + str(_processid_akt))
        if _list_processids[i] < _processid_akt:
            print ("  UNDO Bedingung erfuellt. I: " + str(i) + " Wert Liste: " + str(_list_processids[i]) + " processid_akt: " + str(_processid_akt))
            _list_processids.append(_list_processids.pop(i))
            break
        i -= 1
    _processid_akt = _list_processids[-1] # das oberste Element
    print (" UNDO Processid_high is now: " + str(_processid_high) + " Processid_akt is now: " + str(_processid_akt) + " List is: " + str(_list_processids))
    apply_process_id(_processid_akt)
    if _processid_akt == _processid_low:
        _button_undo.config(state = DISABLED)
    _button_redo.config(state = NORMAL)

def process_redo(event):
    global _processid_akt, _processid_high, _processid_low, _list_processids
    print("ctrl_y pressed.")
    if _button_redo["state"] == DISABLED:
        messagebox.showinfo("REDO", "no further processes which can be redone")
        return
    i = len(_list_processids) - 1
    while i >= 0:
        print (" REDO I: " + str(i) + " processid von i: " + str(_list_processids[i]) + " processid_akt: " + str(_processid_akt))
        if _list_processids[i] > _processid_akt:
            print ("  REDO Bedingung erfuellt. I: " + str(i) + " Wert Liste: " + str(_list_processids[i]) + " processid_akt: " + str(_processid_akt))
            _list_processids.append(_list_processids.pop(i))
            break
        i -= 1
    _processid_akt = _list_processids[-1] # das oberste Element
    print (" REDO Processid_high is now: " + str(_processid_high) + " Processid_akt is now: " + str(_processid_akt) + " List is: " + str(_list_processids))
    apply_process_id(_processid_akt)
    if _processid_akt == _processid_high:
        _button_redo.config(state = DISABLED)
    _button_undo.config(state = NORMAL)

def apply_process_id(process_id):
    # set thumbnail-states according actual processid
    global _processid_akt, _processid_high, _processid_low, _list_processids
    i = 0
    for thumbnail in thumbnails[_imagetype]:
        #_dict_process_image[_processid_akt].append(thumbnail.setState(_dict_process_image[process_id][i]))
        thumbnail.setState(_dict_process_image[process_id][i])
        i += 1
    update_button_state()
    
def update_button_state(): # enabled / disabled include / Exclude buttons

    #wir ermitteln, ob alle include oder exlude haben. In diesem Falls
    # disabeln wir exclude / Include All, was ja keinen Sinn hat und ggf.
    # die Historie unötig aufbläht
    count_states = 0
    count_exclude = 0
    count_include = 0
    for thumbnail in thumbnails[_imagetype]:
        if thumbnail.getState() == state.EXCLUDE:
            count_exclude += 1
        if thumbnail.getState() == state.INCLUDE:
            count_include += 1
        count_states += 1
    if count_exclude == count_states:
        _button_exclude.config(state = DISABLED)
    else:
        _button_exclude.config(state = NORMAL)
    if count_include == count_states:
        _button_include.config(state = DISABLED)
    else:
        _button_include.config(state = NORMAL)

def button_undo():
    process_undo((0, 0))
    
def button_redo():
    process_redo((0, 0))
# Ende undo / redo-Funktionen

def button_duplicates():
    #global _dict_duplicates, _imagetype
    for mytarget in _dict_duplicates[_imagetype]:
        #print("Duplcate Key: " + mytarget) 
        mylist = _dict_duplicates[_imagetype][mytarget]
        if len(mylist) > 1: # es gibt 1...n Duplicates
            print("Duplcate Key: " + mytarget)
            for mysource in mylist:
                print("   " + mysource)
                #display_image(_dict_thumbnails[_imagetype][mysource])
                #time.sleep(.5)
    
   
def on_window_destroy(self):
    a = 1
    #print ("Destroy called.")
    #root.instance.destroy()

def clear_textbox(o):
    o.delete(0, 'end')
    
def clear_text(o):
    o.delete(1.0, 'end')

def insert_text(o, str):
    o.insert('end', str)

if __name__ == '__main__':
    Dateimeister.start_up()





