#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    Oct 14, 2023 03:20:47 PM CEST  platform: Windows NT

import sys
import os
import configparser 
import re
import locale
import ctypes
import time
import operator
import threading
import copy
import subprocess
import shutil

import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
from tkinter import filedialog as fd
from tkinter import messagebox
from tkinter import Scrollbar
from tkinter import ttk
from tkinter import Frame
from tkinter import Label
from tkinter import Canvas
from tkinter import Menu
from time import gmtime, strftime

import xml.etree.ElementTree as ET
    
from PIL import Image, ImageTk
from datetime import datetime, timezone

import Dateimeister
import dateimeister_config_xml as DX
import dateimeister_video as DV
import Diatisch as DIAT
import dateimeister_generator as DG
#from Dateimeister import ToolTip

_debug = True # False to eliminate debug printing from callback functions.
_index_of_leftmost = -1
_canvas_gallery_width_visible = 0
_canvas_gallery_width_images = 0
_canvas_gallery_width_all = 0
_image = 0
_dict_firstname_fullname = {}
_processid_akt = 0
_processid_high = 0
_processid_incr = 10
_list_processids = []
_stack_processids = [] # list
_dict_thumbnails = {}
_dict_thumbnails_lineno = {}
_dict_duplicates = {}
_dict_duplicates_sourcefiles = {}
_duplicates = False
_dict_file_image = {} # key: Imagefilename, value MyFSImage-Objekt, mit fullscale Image, canvas id, window...
_win_messages = None


from enum import Enum
class state(Enum):
    INCLUDE = 1
    EXCLUDE = 2
    
# variables used by more than 1 class
class Globals:
    imagetype = ""
    screen_width = 0
    screen_height = 0
    uncomment = ""
    gap = 10
    button_duplicates   = None
    config_files_xml    = None
    config_files_subdir = None
    cmd_files_subdir    = None
    delay_default = 20 #ToDo: Ini

class MyThumbnail:
    #image = "" # hier stehen Klassenvariablen, im Gegensatz zu den Instanzvariablen

    # The class "constructor" - It's actually an initializer 
    def __init__(self, image, pmain, start, end, file, showfile, id, text_id, rect_id, frameids, lineno, player, duplicate, canvas, targetfile, \
      text = None, parent = None, tooold = False):
        self.main = pmain
        self.image = image
        self.start = start
        self.end   = end
        self.file = file
        self.showfile = showfile
        self.image_id = id
        self.state_id_text = text_id
        self.state_id_rect = rect_id
        self.frameids = frameids
        self.lineno = lineno
        self.player = player 
        self.targetfile = targetfile
        self.fsimage = None
        self.dupl = None
        self.state = state.INCLUDE
        self.canvas = canvas
        self.text = text
        self.parent = parent
        self.duplicate = duplicate
        self.tooold = tooold
        self.setState(self.state)
        
    def getImage(self):
        #print("*** retrieve Image ")
        return self.image    

    def getStart(self):
        return self.start    

    def getEnd(self):
        return self.end    

    def getFile(self):
        return self.file    
    def getShowfile(self):
        return self.showfile    

    def setId(self, id):
        self.image_id = id    
    def getId(self):
        return self.image_id    

    def set_tooold(self, tooold):
        self.tooold = tooold    
    def get_tooold(self):
        return self.tooold    

    def getDuplicate(self):
        return self.duplicate    

    def setState(self, state, caller = None, do_save = True):
        if state != self.state:
            state_changed = True
        else:
            state_changed = False
        self.state = state # neuer Status
        if self.text is not None:
            # change line in text
            # die Textzeile beschaffen
            lstart = "%d.0" % (self.lineno)
            lend   = "%d.0 lineend" % (self.lineno)
            # tindex = "%d.0, %d.0 lineend" % (lineno, lineno + 1)
            line    = self.text.get(lstart, lend)
            #print ("Retrieved Textline: " + line)
        if self.state == state.INCLUDE:
            self.canvas.itemconfigure(self.state_id_text, state='hidden')
            self.canvas.itemconfigure(self.state_id_rect, state='hidden')
            if self.text is not None:
                linenew = line
                linenew = re.sub(rf"{Globals.uncomment}", '', linenew)
                self.text.delete(lstart, lend) # without delete / insert highlighttag does not work. Bug in Python?
                self.text.insert(lstart, line)
                self.text.tag_add("include", lstart, lend) # normal foreground
                self.scrollTextToLineno()
        if self.state == state.EXCLUDE and state_changed:
            self.canvas.itemconfigure(self.state_id_text, state='normal')
            self.canvas.itemconfigure(self.state_id_rect, state='normal')
            if self.text is not None:
                linenew = line
                linenew = re.sub(r"^", f"{Globals.uncomment}", linenew)
                self.text.delete(lstart, lend) # without delete / insert highlighttag does not work. Bug in Python?
                self.text.insert(lstart, line)
                self.text.tag_add("exclude", lstart, lend) # exclude foreground(grey)
                self.scrollTextToLineno()
        if self.parent is not None:
            self.parent.setState(state, caller)
        if self.fsimage is not None:
            self.fsimage.exclude_call(state) # synchronisiert das FSImge, falls vorhanden
            print("FSImage Exclude-Call")
        if self.dupl is not None:
            #print("dupl is: " + str(self.dupl) + "caller is: " + str(caller))
            if caller != self.dupl: # to avoid loop
                self.dupl.exclude_call(self, state) # synchronisiert das Duplicate, falls vorhanden
                #print("Duplicate Exclude-Call")
        if state_changed and do_save:
            self.main.write_cmdfile(Globals.imagetype)
            print ("setState: SAVE requested")
    def getState(self):
        return self.state   

    def getLineno(self):
        return self.lineno    

    def setLineno(self, lineno):
        self.lineno = lineno 
        
    def scrollTextToLineno(self): # reset all lines to "unselect", keep exclude / include Info, hide frame
        for t in Globals.thumbnails[Globals.imagetype]:
            lineno = t.getLineno()
            lstart = "%d.0" % (lineno)
            lend   = "%d.0 lineend" % (lineno)
            line    = self.text.get(lstart, lend) # text widget is the same for all thumbnails
            # without delete / insert tag_add will not work. Bug in tkinter?
            self.text.delete(lstart, lend) # without delete / insert highlighttag does not work. Bug in Python?
            self.text.insert(lstart, line)
            #print("try to select line " + line)
            if t.getState() == state.INCLUDE:
                self.text.tag_add("normal_include", lstart, lend)
            else:
                self.text.tag_add("normal_exclude", lstart, lend)
            self.canvas.itemconfigure("imageframe", state = 'hidden')
        # now set tag for this thumbnail
        lstart = "%d.0" % (self.lineno)
        lend   = "%d.0 lineend" % (self.lineno)
        line    = self.text.get(lstart, lend)
        # without delete / insert tag_add will not work. Bug in tkinter?
        self.text.delete(lstart, lend) # without delete / insert highlighttag does not work. Bug in Python?
        self.text.insert(lstart, line)
        #self.text.mark_set(tk.INSERT, "%d.%d" % (self.lineno, 0))
        #print("try to select line " + line)
        if self.getState() == state.INCLUDE:
            self.text.tag_add("select_include", lstart, lend)
        else:
            self.text.tag_add("select_exclude", lstart, lend)
        self.text.see(lstart)
        lineinfo = self.text.dlineinfo(lstart)
        self.text.yview_scroll(lineinfo[1], 'pixels' )
        #self.canvas.itemconfigure("imageframe", state = 'normal')
        #print("Frameids: " + str(self.frameids))
        for frameid in self.frameids:
            self.canvas.itemconfigure(frameid, state = 'normal')

    def register_FSimage(self, fsimage):
        self.fsimage = fsimage

    def register_Dupl(self, dupl):
        self.dupl = dupl

    def getPlayer(self):
        return self.player   

    def getTargetfile(self):
        return self.targetfile   

    def __del__(self):
        if self.player is not None:
            self.player.pstop()
            del self.player
        width = self.end -self.start 
        #print("*** Deleting MyThumbnail-Objekt. " + self.file + " lineno in cmdfile " + str(self.lineno))

# hier speichern wir die full-size-Bilder
class MyFSImage:

    # The class "constructor" - It's actually an initializer 
    def __init__(self, file, thumbnail, dict_caller, pmain): # close_handler has to delete self from the dict main or duplicate
        self.main = pmain
        self.thumbnail = thumbnail
        self.player = None
        if thumbnail.getPlayer() is None: # still image
            self.image  = Image.open(file)
        self.file = file
        self.dict_caller = dict_caller
        # register at thumbnail, so it can call us for reacting to state
        self.thumbnail.register_FSimage(self)
        # Create secondary (or popup) window.
        self.root2 = tk.Toplevel()
        self.w2 = Dateimeister.Toplevel2(self.root2)
        self.f = self.w2.Canvas_image
        if self.thumbnail.getState() == state.INCLUDE:
            self.w2.Button_exclude.config(text = "Exclude")
            self.w2.Label_status.config(text = "Included")
        else: # toggle to not exclude
            self.w2.Button_exclude.config(text = "Include")
            self.w2.Label_status.config(text = "Excluded")
        # zur Behandlung von Events brauchen wir den Imagefile-Namen. Darüber kommen wir an das Window und
        # das Image selbst. Das ist erforderlich, weil wir ja mehrere Fenster haben können
        # kurz gesagt: mit dieser Methode kann man Parameter an den Handler übergeben
        self.w2.Button_fit.config(command = self.fit_handler)
        self.w2.Button_fscale.config(command = self.fscale_handler)
        self.w2.Button_exclude.config(command = self.exclude_handler)
        self.w2.Button_pp.config(command = self.pp_handler)
        self.w2.Button_restart.config(command = self.restart_handler)
        self.w2.Scale_fps.config(command = self.setFps)
        self.f.bind("<MouseWheel>", self.mousewheel_handler)
        self.root2.protocol("WM_DELETE_WINDOW", self.close_handler)

        self.root2.title(file)
        width,height=Globals.screen_width,Globals.screen_height
        v_dim=str(width)+'x'+str(height)
        self.root2.geometry(v_dim)
        self.root2.resizable(False, False)

        # Scrollbars
        self.V_I = Scrollbar(self.f)
        self.V_I.config(command=self.f.yview)
        self.f.config(yscrollcommand=self.V_I.set)  
        self.H_I = Scrollbar(self.f, orient = HORIZONTAL)
        self.H_I.config(command=self.f.xview)
        self.f.config(xscrollcommand=self.H_I.set)
        if thumbnail.getPlayer() is None:
            self.image.close
        self.zoomfaktor = 1.0
        self.V_I.pack(side=RIGHT, fill=Y)
        self.H_I.pack(side=BOTTOM, fill=BOTH)
        # Bind keys to canvas for scrolling
        self.f.bind("<Left>",  lambda event: self.scrollx(-1, "unit"))
        self.f.bind("<Right>", lambda event: self.scrollx( 1, "unit"))
        self.f.bind("<Up>",    lambda event: self.scrolly(-1, "unit"))
        self.f.bind("<Down>",  lambda event: self.scrolly( 1, "unit"))

        self.zoomfaktor = 1.0 # wir fangen immer mit dem Bild in voller Auflösung an.
        self.f.focus_set()
        if thumbnail.getPlayer() is None: # still image
            self.image_zoom(self.zoomfaktor)
            self.player = None
            self.w2.Button_pp.place_forget()
            self.w2.Button_restart.place_forget()
            self.w2.Scale_fps.place_forget()
            self.w2.Label_fps.place_forget()
        else: #video, we need a new one the existing is for playing in thumbnal
            self.w2.Button_fit.place_forget()
            self.w2.Button_fscale.place_forget()
            self.H_I.pack_forget()
            self.V_I.pack_forget()
            self.f.update()
            self.player   = DV.VideoPlayer(self.root2, self.file, self.f, self.f.winfo_width(), self.f.winfo_height(), 0)
            self.image_width, self.image_height, self.pimg = self.player.get_pimg()  
            print(file, " height / width: ",  self.image_width, self.image_height)
            self.id = self.f.create_image(0, 0, anchor='nw',image = self.pimg, tags = 'images')
            self.f.tag_raise("text")
            self.f.tag_raise("line")
            self.player.setId(self.id)
            self.player.pstart()
            self.player.setDelay(Globals.delay_default)
            self.w2.Scale_fps.set(1000 / Globals.delay_default)
            self.playerstatus = 'play'
            self.w2.Button_pp.config(text = 'pause')
    def getPlayer(self):
        return self.player
    
    def scrollx(self, amount, unit):
        #print("scroll command: " + str(amount) + ' ' + unit)
        self.f.xview_scroll(amount, unit)
        return "break"
    def scrolly(self, amount, unit):
        #print("scroll command: " + str(amount) + ' ' + unit)
        self.f.yview_scroll(amount, unit)
        return "break"
     
    def fit_handler(self):
        self.button_fit()

    def pp_handler(self):
        if self.playerstatus == 'play': 
            self.player.pstop()
            self.playerstatus = 'pause'
            self.w2.Button_pp.config(text = 'play')
        else:
            self.player.pstart()
            self.playerstatus = 'play'
            self.w2.Button_pp.config(text = 'pause')

    def setPlaystatus(self, newstatus):
        if newstatus == 'play': 
            self.playerstatus = 'play'
            self.w2.Button_pp.config(text = 'pause')
        else:
            self.playerstatus = 'pause'
            self.w2.Button_pp.config(text = 'play')

    def restart_handler(self):
        self.player.restart()
        self.setPlaystatus('play')

    def fscale_handler(self):
        self.image_zoom(1) # damit bringt image_zoom das Foto in höchster Auflösung zur Anzeige
        
    def setFps(self, value):
        self.player.setDelay(int(1000 / int(value)))

    def exclude_handler(self): # react to own Button, thumbnail can be from main or duplicates
        if self.thumbnail.getState() == state.INCLUDE:
            self.thumbnail.setState(state.EXCLUDE)
            self.w2.Button_exclude.config(text = "Include")
            self.w2.Label_status.config(text = "Excluded")
        else: # toggle to not exclude, delete Item
            self.thumbnail.setState(state.INCLUDE)
            self.w2.Button_exclude.config(text = "Exclude")
            self.w2.Label_status.config(text = "Included")
        self.main.historize_process()

    def exclude_call(self, state): # react to request from outside
        print("MyFSImage.Exclude called, State = " + str(state))
        if state == state.INCLUDE:
            self.w2.Button_exclude.config(text = "Exclude")
            self.w2.Label_status.config(text = "Included")
        else: # toggle to not exclude, delete Item
            self.w2.Button_exclude.config(text = "Include")
            self.w2.Label_status.config(text = "Excluded")
    
    def close_handler(self): #calles when window is closing: delete player and fsimage, remove from _dict_file_image
        t = self.dict_caller[self.file]
        self.thumbnail.register_FSimage(None)
        self.dict_caller.pop(self.file)
        if self.player is not None:
            self.player.pstop()
            del self.player
        self.root2.destroy()
        del t
        
    def close_handler_external(self): # called from external. Do the same things as close_handler, except remove from _dict_file_image
        # can be called from main window or Duplicates-Window which use different dicts
        t = self.dict_caller[self.file]
        self.thumbnail.register_FSimage(None)
        #_dict_file_image.pop(self.file) # the dict is dont do this when calles from external, because probably dict is in use
        if self.player is not None:
            self.player.pstop()
            del self.player
        self.root2.destroy()
        del t
        
    def mousewheel_handler(self, event):
        if self.player is None: # exception when used for video
            zoomincrement = (event.delta / 120) / 100 # Windows-spezifisch, macOS: keine Division durch 120
            if (zoomincrement > 0):
                if self.zoomfaktor + zoomincrement <= 1:
                    newzoomfaktor = self.zoomfaktor + zoomincrement
                else:
                    newzoomfaktor = 1.0
            else: # lt 0
                if self.zoomfaktor + zoomincrement >= .1:
                    newzoomfaktor = self.zoomfaktor + zoomincrement
                else:
                    newzoomfaktor = 0.1
            #print ("Mousewheel Delta is " + str(event.delta) + " Zoomfaktor old / new is: " + str(self.zoomfaktor) + ' / ' + str(newzoomfaktor))
            self.zoomfaktor = newzoomfaktor
            self.image_zoom(self.zoomfaktor)

    def button_fit(self):
        self.image_zoom(0) # damit bringt image_zoom das Foto vollständig und canvas-füllend zur Anzeige

    def image_zoom(self, zoomfaktor):
        # zoomfaktor 0 heißt: selbst errechnen, so dass Bild formatfüllend ist.
        image_width_orig, image_height_orig = self.image.size
        self.f.update()
        canvas_width  = self.f.winfo_width()
        canvas_height = self.f.winfo_height()
        if  zoomfaktor == 0: # wir brauchen die Scrollbars nicht und errechnen den formatfüllenden Zoomfaktor
            #self.V_I.pack_forget()
            #self.H_I.pack_forget()
            faktor = min(canvas_height / image_height_orig, canvas_width / image_width_orig)
            self.zoomfaktor = faktor
            print("... calculate faktor for Image to fit in Canvas")
        else:
            #self.V_I.pack(side=RIGHT, fill=Y)
            #self.H_I.pack(side=BOTTOM, fill=BOTH)
            faktor = zoomfaktor
            self.zoomfaktor = faktor
            
        newsize = (int(image_width_orig * faktor), int(image_height_orig * faktor))
        #print("*** faktor is: " + str(faktor) + " canvas_height: " + str(canvas_height) + " origsize: " + str(self.image.size) + " newsize: " +str(newsize))
        r_img = self.image.resize(newsize, Image.Resampling.NEAREST)
        self.pimg = ImageTk.PhotoImage(r_img)
        self.f.delete('images')
        #f.itemconfig(canvas_id, image = pimg)
        self.id = self.f.create_image(0, 0, anchor='nw',image = self.pimg, tags = 'images')
        self.f.tag_raise("rect")
        self.f.tag_raise("text")
        self.f.update()
        
        if newsize[0] <= canvas_width:
            self.H_I.pack_forget()
        else:
            self.H_I.pack(side=BOTTOM, fill=BOTH)
        if newsize[1] <= canvas_height:
            self.V_I.pack_forget()
        else:
            self.V_I.pack(side=RIGHT, fill=Y)
            
        self.f.config(scrollregion = self.f.bbox("all")) 

    def __del__(self):
        self.a = 1
        #print("*** Deleting FSImage-Objekt. File is " + str(self.file))

# display and process duplicates
class MyDuplicates:

    # The class "constructor" - It's actually an initializer 
    def __init__(self, pmain):
        self.player = None
        self.main = pmain
        self.thumbnails_duplicates = {}
        self.dict_thumbnails_duplicates = {}
        # register at thumbnail, so it can call us for reacting to state
        # Create secondary (or popup) window.
        self.root3 = tk.Toplevel()
        self.w3 = Dateimeister.Toplevel_dupl(self.root3)
        self.f = self.w3.Canvas_dupl
        self.f.delete('all')
        self.w3.Button_dupl.config(command = self.dupl_handler)
        self.root3.protocol("WM_DELETE_WINDOW", self.close_handler)

        width,height=Globals.screen_width,Globals.screen_height
        v_dim=str(width)+'x'+str(height)
        self.root3.geometry(v_dim)
        self.root3.resizable(False, False)
        title = self.root3.title()
        self.root3.title(title + " for " + _outdir)

        # horizontal scrollbar for cancas
        self.H_I = Scrollbar(self.f, orient = HORIZONTAL, command = self.xview)
        #self.H_I.config(command=self.f.xview)
        self.f.config(xscrollcommand=self.H_I.set)
        self.H_I.pack(side=BOTTOM, fill=BOTH)
        # Bind keys to canvas for scrolling
        self.f.bind("<Left>",  lambda event: self.xview("scroll", -1, "units"))
        self.f.bind("<Right>", lambda event: self.xview("scroll",  1, "units"))
        self.f.bind("<Double-Button-1>", self.canvas_show)
        self.f.focus_set()
        
        # Listbox
        # vertical scrollbar for lisrbox
        self.V_L = Scrollbar(self.w3.Listbox_dupl, orient = VERTICAL)
        self.V_L.config(command = self.w3.Listbox_dupl.yview)                    
        self.V_L.pack(side=RIGHT, fill=BOTH)
        self.w3.Listbox_dupl.config(yscrollcommand = self.V_L.set) 
        self.w3.Listbox_dupl.bind('<Double-1>', self.lb_double)
        for key in _dict_duplicates[Globals.imagetype]:
            self.w3.Listbox_dupl.insert(END, key)
        self.w3.Listbox_dupl.select_set(0)

        # Create the context menu
        self.context_menu = tk.Menu(self.f, tearoff=0)
        self.context_menu.add_command(label="Exclude", command=self.canvas_image_exclude)    
        self.context_menu.add_command(label="Show"   , command=self.canvas_image_show)    
        self.context_menu.add_command(label="Restart", command=self.canvas_video_restart)    

        self.f.bind("<Button-3>", self.show_context_menu)    
        self.f.bind('<Motion>', self.tooltip_imagefile)    
        self.f.bind('+', lambda event: self.delay_decr(event))
        self.f.bind('-', lambda event: self.delay_incr(event))
        self.f.bind('0', lambda event: self.delay_deflt(event))
        
        self.dict_child_parent = {}
        self.timestamp = datetime.now()
        self.tooltiptext = ""
        self.tt = Dateimeister.ToolTip(self.f, "no images available", delay=0, follow = True)
        
        self.dict_file_image = {}
        Globals.button_duplicates.config(state = DISABLED) # Duplicates Window must not exist more than once

    def exclude_call(self, parent, state): # react to request from outside, outside is root - thumbnail
        print("MyDuplicate.Exclude called, State = " + str(state))
        # we have to find child for parent ( this is the thumbnail in main window)
        for child in self.dict_child_parent:
            myparent = self.dict_child_parent[child]
            if myparent == parent:
                break
        child.setState(state, self)
    
    def canvas_image_exclude(self): # calls canvas_exclude with self.event
        print("Context menu exlude")
        self.canvas_exclude(self.event)

    def canvas_exclude(self, event):
        self.f.focus_set()

        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            if thumbnail.getState() == state.INCLUDE:
                thumbnail.setState(state.EXCLUDE, self)
            else: # toggle to not exclude, delete Item
                thumbnail.setState(state.INCLUDE, self)
            self.main.historize_process()

    def canvas_image_show(self):
        print("Context menu show")
        self.canvas_show(self.event)

    def canvas_show(self, event):
        self.f.focus_set()

        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            item_id = thumbnail.getId()
            self.display_image(thumbnail)

    def display_image(self, thumbnail):
        file = thumbnail.getShowfile()
        # wenn das Bild schon in einem Fenster angezeigt wird, dann verwenden wir dieses
        if file in self.dict_file_image:
            print ("FSImage exists for file: " + file)
            fs_image = self.dict_file_image[file]
            player = fs_image.getPlayer()
            if player is not None: # this is a video
                print ("FSImage restart file: " + file)
                player.restart()
                fs_image.setPlaystatus('play') # Status, Buttontext
        else: # ein neues Objekt anlegen und in _dict_file_image eintragen
            print ("FSImage does not exist for file: " + file)
            fs_image = MyFSImage(file, thumbnail, self.dict_file_image, self.main)
            self.dict_file_image[file] = fs_image

    def canvas_video_restart(self):
        print("Context menu restart")
        self.f.focus_set()

        canvas_x = self.f.canvasx(self.event.x)
        canvas_y = self.f.canvasy(self.event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # this is a video
                player.restart()

    def show_context_menu(self, event):
        # das Event müssen wir speichern, da die eigenlichen Funktionen die x und y benötigen
        self.event = event
        # falls wir keine anzeigbare Datei haben, müssen wir show-Item disablen
        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            if thumbnail.getImage() == 0:
                print(" No Image availabl for " + thumbnail.getFile())
                self.context_menu.entryconfig(1, state="disabled")
            else:
                self.context_menu.entryconfig(1, state="normal")
            if thumbnail.getState() == state.INCLUDE:
                self.context_menu.entryconfig(0, label = "Exclude " + thumbnail.getFile())
            else:
                self.context_menu.entryconfig(0, label = "Include " + thumbnail.getFile())
            self.context_menu.entryconfig(1, label = "Show " + thumbnail.getFile())
            self.context_menu.post(event.x_root, event.y_root)
    
    def tooltip_imagefile(self, event):
        tsnow = datetime.now()
        tdiff = abs(tsnow - self.timestamp)
        if  tdiff.microseconds > 100000:
            #print("Timer has finished, microsecons is: ", tdiff.microseconds)
            self.timestamp = tsnow
        else:
            return
        # Tooltip
        #x, y = canvas.winfo_pointerxy()
        text = "no image available"
        # canvas is drawn before the thumbnails are created, so check existence and length
        if Globals.imagetype in self.thumbnails_duplicates and len(self.thumbnails_duplicates[Globals.imagetype]) > 0:
            canvas_x = self.f.canvasx(event.x)
            canvas_y = self.f.canvasy(event.y)
            thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
            if thumbnail is not None:
                text = thumbnail.getFile()
                #print("Image clicked: " + text)
            if text != self.tooltiptext:
                self.tt.update(text)
                self.tooltiptext = text
                self.stop_all_players()
                # if file is video, play video
                if thumbnail is not None:
                    player = thumbnail.getPlayer()
                    if player is not None: # this is a video
                        player.pstart()
                        player.setDelay(Globals.delay_default)
                        fps   = player.getFPS()
                        fc    = player.getFrameCount()
                        delay = player.getDelay()
                        frames_per_second = 1000 / delay
                        duration_in_seconds = fc / frames_per_second
                        #print ("FPS is: ", fps, " Total Num of Frames is: ", fc, " Delay is: ", delay, " calc duration is: " + str(duration_in_seconds))
                        self.context_menu.entryconfig(2, state="normal")
                    else:
                        self.context_menu.entryconfig(2, state="disabled")
                        
    def delay_decr(self, event): # speed +
        self.f.focus_set()
        delta = -5
        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                if delay + delta > 5:
                    player.setDelay(delay + delta)

    def delay_incr(self, event): # speed -
        self.f.focus_set()
        delta = 5
        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                if delay + delta < 200:
                    player.setDelay(delay + delta)

    def delay_deflt(self, event): # speed normal
        self.f.focus_set()
        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                player.setDelay(Globals.delay_default)
                
    def lb_double(self, event):
        cs = self.w3.Listbox_dupl.curselection()
        self.thisduplicate = self.w3.Listbox_dupl.get(cs)
        #print("Duplicate selected: " + self.thisduplicate)
        self.display_duplicate(self.thisduplicate)
    
    def scrollx(self, amount, unit):
        #print("scroll command: " + str(amount) + ' ' + unit)
        self.f.xview_scroll(amount, unit)
        return "break"
     
    def dupl_handler(self):
        cs = self.w3.Listbox_dupl.curselection()
        self.thisduplicate = self.w3.Listbox_dupl.get(cs)
        #print("Duplicate selected: " + self.thisduplicate)
        self.display_duplicate(self.thisduplicate)

    def close_handler(self): #calles when window is closing
        print("ToDo, cleanup when window is closed")
        self.stop_all_players() # unregister to avoid calls after duplicate has been destroyed
        for child in self.dict_child_parent:
            parent = self.dict_child_parent[child]
            parent.register_Dupl(None)
        self.root3.destroy()
        for t in self.dict_file_image: # destroy all FSImages
            u = self.dict_file_image[t]
            u.close_handler_external()
        Globals.button_duplicates.config(state = NORMAL)
        self.main.win_duplicates = None
        
    def stop_all_players(self):
        # stop all video players
        Globals.button_duplicates.config(state = DISABLED)
        if Globals.imagetype in self.thumbnails_duplicates:
            for t in self.thumbnails_duplicates[Globals.imagetype]: # stop all running players
                thisplayer = t.getPlayer()
                if thisplayer is not None:
                    if thisplayer.getRun(): # running
                        thisplayer.pstop()
                        #print ("Stop player for: " + t.getFile())
    
    def display_duplicate(self, target_file):
        self.main.stop_all_players() # should not continue running 
        self.f.delete('all')
        self.thumbnails_duplicates[Globals.imagetype] = []
        self.dict_thumbnails_duplicates[Globals.imagetype] = {}
        list_duplicate_sourcefiles = _dict_duplicates[Globals.imagetype][target_file]
        self.lastposition = 0
        self.num_images = 0
        # distance from border for text-boxes
        dist_text  = 10
        # distance from border for image-frame
        dist_frame = 20
        height_scrollbar = self.H_I.winfo_height()

        for source_file in list_duplicate_sourcefiles:
            thumbnail = _dict_thumbnails[Globals.imagetype][source_file]
            showfile = thumbnail.getShowfile()
            state = thumbnail.getState() # we want to use the current state and copy it to the duplicate-thumbnail
            if showfile != 'none':
                canvas_height = self.f.winfo_height() - self.H_I.winfo_height()
                canvas_width  = self.f.winfo_width()
                self.canvas_width_visible = self.f.winfo_width() # Fensterbreite
                player = None
                if thumbnail.getPlayer() is not None: # Video
                    print("try to create new videoplayer...")
                    # create new videoplayer
                    player   = DV.VideoPlayer(self.root3, showfile, self.f, canvas_width, canvas_height, self.lastposition)
                    image_width, image_height, pimg = player.get_pimg()
                else: # still image
                    img  = Image.open(showfile)
                    image_width_orig, image_height_orig = img.size
                    faktor = canvas_height / image_height_orig
                    newsize = (int(image_width_orig * faktor), int(image_height_orig * faktor))
                    r_img = img.resize(newsize, Image.Resampling.NEAREST)
                    image_width, image_height = r_img.size
                    print("try to print " + showfile + " width is " + str(image_width) + "(" + str(image_width_orig) + ")" + " height is " + str(image_height) + "(" + str(image_height_orig) + ")" \
                       + " factor is " + str(faktor))
                    pimg = ImageTk.PhotoImage(r_img)
                id = self.f.create_image(self.lastposition, 0, anchor='nw',image = pimg, tags = 'images')
                text_id = self.f.create_text(self.lastposition + dist_text, dist_text, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
                rect_id = self.f.create_rectangle(self.f.bbox(text_id), outline="blue", fill = "white", tag = 'rect')
                # the frame for selected image, consisting of 4 lines because there is no opaque rectangle in tkinter
                north_west = (self.lastposition + dist_frame, dist_frame)
                north_east = (self.lastposition + image_width - dist_frame, dist_frame)
                south_west = (self.lastposition + dist_frame, image_height - dist_frame)
                south_east = (self.lastposition + image_width - dist_frame, image_height - dist_frame)
                line_north = self.f.create_line(north_west, north_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_east  = self.f.create_line(north_east, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_south = self.f.create_line(south_west, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_west  = self.f.create_line(north_west, south_west, dash=(1, 1), fill = "red", tags="imageframe")
                frameids = (line_north, line_east, line_south, line_west)

                self.f.tag_raise("rect")
                self.f.tag_raise("text")
                self.f.tag_raise("line")
                #self.f.tag_raise("imageframe")
                if player is not None:
                    player.setId(id)
                # we must also create a thumbnail_list for duplicate images, or the garbage collector will delete images
                myimage = MyThumbnail(pimg, self.main, self.lastposition, self.lastposition + image_width, showfile, showfile, id, \
                    text_id, rect_id, frameids, 0, player, 'j', self.f, None, None, thumbnail)
                self.thumbnails_duplicates[Globals.imagetype].append(myimage)
                myimage.setState(state)
                self.dict_thumbnails_duplicates[Globals.imagetype][showfile] = myimage # damit können wir auf thumbnails mit den Sourcefilenamen zugreifen, z.B. für Duplicates
                self.lastposition += image_width + Globals.gap 
            else: # wir haben kein Bild, ein Rechteck einfügen
                image_height = canvas_height
                image_width  = int(canvas_height * 4 / 3)
                id = self.f.create_rectangle(self.lastposition, 0, self.lastposition + image_width, canvas_height, fill="blue", tags = 'images')
                text_id = self.f.create_text(self.lastposition, 0, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
                rect_id = self.f.create_rectangle(self.f.bbox(text_id), outline="blue", fill = "white")
                # the frame for selected image, consisting of 4 lines because there is no opaque rectangle in tkinter
                north_west = (self.lastposition + dist_frame, dist_frame)
                north_east = (self.lastposition + image_width - dist_frame, dist_frame)
                south_west = (self.lastposition + dist_frame, image_height - dist_frame)
                south_east = (self.lastposition + image_width - dist_frame, image_height - dist_frame)
                line_north = self.f.create_line(north_west, north_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_east  = self.f.create_line(north_east, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_south = self.f.create_line(south_west, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_west  = self.f.create_line(north_west, south_west, dash=(1, 1), fill = "red", tags="imageframe")
                frameids = (line_north, line_east, line_south, line_west)
                self.f.tag_raise("text")
                #self.f.tag_raise("imageframe")
                myimage = MyThumbnail(0, self.main, self.lastposition, self.lastposition + image_width, showfile, showfile, id, \
                    text_id, rect_id, frameids, 0, player, 'j', self.f, None, None, thumbnail)
                self.thumbnails_duplicates[Globals.imagetype].append(myimage)
                self.dict_thumbnails_duplicates[Globals.imagetype][showfile] = myimage
                self.lastposition += image_width + Globals.gap 
            self.num_images += 1
            # register at parent-thumbnail, so it can call us for reacting to state
            # we need a dict with child-parent-thumbnails in order to unregister on close
            self.dict_child_parent[myimage] = thumbnail # child -> parent
            thumbnail.register_Dupl(self)
        # Globals.gap haben wir einmal zuviel (fürs letzte) gezählt
        self.lastposition -= Globals.gap
        # damit wir am Ende auch bis zum letzten einzelnen Bild scrollen können, fügen wir ein Rechteck ein
        if len(self.thumbnails_duplicates[Globals.imagetype]) > 0: 
            thumbnail = self.thumbnails_duplicates[Globals.imagetype][-1]
            rect_len = self.canvas_width_visible - (thumbnail.getEnd() - thumbnail.getStart() + Globals.gap)
            self.f.create_rectangle(self.lastposition, 0, self.lastposition + rect_len, canvas_height, fill="yellow")
            self.f.config(scrollregion = self.f.bbox('all')) 
            self.canvas_width_images = self.f.bbox('images')[2]
            self.canvas_width_all    = self.f.bbox('all')[2]
            #print ("Canvas totale Breite(Images): " + str(self.canvas_width_images) + " totale Breite(All): " + str(self.canvas_width_all) \
            #    + " visible: " + str(self.canvas_width_visible) + " lastposition: " + str(self.lastposition))
        
        for child in self.dict_child_parent:
            parent = self.dict_child_parent[child]
            print("Child file / parent file is: " + child.getFile() + ' / ' + parent.getFile())
        #print("self.thumbnails_duplicates is: " + str(self.thumbnails_duplicates))
        self.f.focus_set()

    def xview(self, *args):
        print (*args)
        s1 = 0.0
        s2 = 1.0
        scrolldelta = 0
        width_scrollbar = self.H_I.winfo_width()
        #print ("Scroll Canvas totale Breite(Images): " + str(self.canvas_width_images) + " totale Breite(All): " + str(self.canvas_width_all) \
        #    + " visible: " + str(self.canvas_width_visible) + " Scrollbarwidth: " + str(width_scrollbar) + " BBOX: " + str(self.f.bbox('all')))
        slider_width = int((self.canvas_width_visible / self.canvas_width_all) * width_scrollbar)
        # aktuelle Scroll-Position des Canvas
        canvas_x = self.f.canvasx(0)
        canvas_y = self.f.canvasy(0)
        # aktuelle position der Scrollbar
        scrollposition = self.H_I.get()[0]
        
        #print("scroll_position_H_I: " + str(canvas_x) + " scroll_position Scrollbar: " + str(scrollposition))
        # wenn wir die Pfeiltasten betätigen, wollen wir auf den Anfang des nächsten (vorherigen) Bildes scrollen.
        # wenn das aktuelle Bild nur teilweise zusehen ist, scrollen wir bei Linkstaste auf den Bildbeginn
        if len(args) == 3 and args[2] == "units":
            # den scrollbetrag auf die Größe des Bildes am linken Rand setzen
            thumbnail, index = self.get_thumbnail_by_position(canvas_x + 11, canvas_y)
            if thumbnail is not None:
                if int(args[1]) > 0:
                    scrolldelta = (thumbnail.getEnd() - canvas_x + Globals.gap)
                else:
                    if canvas_x - thumbnail.getStart() > 10: # Bild links abgeschnitten, an den Anfang scrollen
                        scrolldelta = (thumbnail.getStart() - canvas_x) # ist dann negativ, was wir ja wollen
                        #print("Bild links abgeschnitten, weil canvas_x = " + str(canvas_x) + " und Bildstart = " + str(thumbnail.getStart()))
                    else: #Bild ist vollständig zu sehen, also zurück zum nächsten
                        if index > 0: # es gibt einen Vorgänger
                            scrolldelta = (self.thumbnails_duplicates[Globals.imagetype][index - 1].getStart()) - canvas_x
                            #print("Vorgänger ist: " + Globals.thumbnails[Globals.imagetype][index - 1].getFile() + " Start: " + str(Globals.thumbnails[Globals.imagetype][index - 1].getStart())\
                            #    + " canvas_x is: " + str(canvas_x) + " scrolldelta is: " + str(scrolldelta))
                
                new_canvas_x = canvas_x + scrolldelta
                # nach links scrollen machr keinen Sinn, wenn wir schon ganz links stehen, analog rechts
                if (int(args[1]) < 0 and canvas_x <= 0) or (int(args[1]) > 0 and new_canvas_x >= self.canvas_width_images):
                   return
                s2 = new_canvas_x / self.canvas_width_all
                s1 = (new_canvas_x - slider_width) / self.canvas_width_all
                print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
            self.H_I.set(s1, s2)
            self.f.xview('moveto', s2)
        else:
            #if (1 == 0):
                #return
            self.f.xview(*args)

    def get_thumbnail_by_position(self, canvas_x, canvas_y):
        index = -1
        found = False
        for thumbnail in self.thumbnails_duplicates[Globals.imagetype]:
            start = thumbnail.getStart()
            end   = thumbnail.getEnd()
            if (canvas_x >= start and canvas_x <= end):
                index = self.thumbnails_duplicates[Globals.imagetype].index(thumbnail)
                #print("retrieved " + thumbnail.getFile() + " Index: " + str(index))
                found = True
                break
        if not found:
            thumbnail = None
            index = None
        return (thumbnail, index)

    def __del__(self):
        self.a = 1
        print("*** Deleting MyDuplicates-Objekt. Outdir is " + str(_outdir))

# Message Output from generated scripts
class MyMessagesWindow:

    # The class "constructor" - It's actually an initializer 
    def __init__(self, pmain, imagetype, copyscript = None, deletescript = None, delrelpathscript = None):
        self.root = tk.Toplevel()
        self.main = pmain
        self.w = Dateimeister.Toplevel_messages(self.root)
        self.root.protocol("WM_DELETE_WINDOW", self.close_handler)

        self.copyscript = copyscript
        self.deletescript = deletescript
        self.delrelpathscript = delrelpathscript
        self.root.title(imagetype)
        width,height=Globals.screen_width,Globals.screen_height
        v_dim=str(width)+'x'+str(height)
        self.root.geometry(v_dim)
        self.root.resizable(True, True)

        self.w.cb_delrelpath = self.w.Checkbutton_delrelpath
        self.w.cb_delrelpath_var.set(0)

        self.w.Button_execute.config(command = self.exec_handler)
        # Scrollbars
        # Script
        parent_width  = self.w.Frame_script.winfo_width()
        parent_height = self.w.Frame_script.winfo_height()
        self.VS = Scrollbar(self.w.Frame_script)
        self.VS.config(command=self.w.Text_script.yview)
        self.w.Text_script.config(yscrollcommand=self.VS.set) 
        self.HS = Scrollbar(self.w.Frame_script, orient = HORIZONTAL)
        self.HS.config(command=self.w.Text_script.xview)
        self.w.Text_script.config(xscrollcommand=self.HS.set)
        self.VS.place(relx = 1, rely = 0,     relheight = 0.98, relwidth = 0.04, anchor = tk.NE)
        self.HS.place(relx = 0, rely = 1, relheight = 0.02, relwidth = 0.96, anchor = tk.SW)

        #Messages
        parent_width  = self.w.Frame_messages.winfo_width()
        parent_height = self.w.Frame_messages.winfo_height()
        self.VM = Scrollbar(self.w.Frame_messages)
        self.VM.config(command=self.w.Text_messages.yview)
        self.w.Text_messages.config(yscrollcommand=self.VM.set)  
        self.HM = Scrollbar(self.w.Frame_messages, orient = HORIZONTAL)
        self.HM.config(command=self.w.Text_messages.xview)
        self.w.Text_messages.config(xscrollcommand=self.HM.set)
        self.VM.place(relx = 1, rely = 0,     relheight = 0.98, relwidth = 0.02, anchor = tk.NE)
        self.HM.place(relx = 0, rely = 1, relheight = 0.02, relwidth = 0.98, anchor = tk.SW)
        
        # Errors
        parent_width  = self.w.Frame_errors.winfo_width()
        parent_height = self.w.Frame_errors.winfo_height()
        self.VE = Scrollbar(self.w.Frame_errors)
        self.VE.config(command=self.w.Text_errors.yview)
        self.w.Text_errors.config(yscrollcommand=self.VE.set) 
        self.HE = Scrollbar(self.w.Frame_errors, orient = HORIZONTAL)
        self.HE.config(command=self.w.Text_errors.xview)
        self.w.Text_errors.config(xscrollcommand=self.HE.set)
        self.VE.place(relx = 1, rely = 0,     relheight = 0.98, relwidth = 0.04, anchor = tk.NE)
        self.HE.place(relx = 0, rely = 1, relheight = 0.02, relwidth = 0.96, anchor = tk.SW)
        
        # Radio Buttons for selection of script
        # control variable
        self.rb_value = tk.StringVar()
        # Radiobutton
        self.w.Radiobutton_copyscript.config(value = "copy", variable = self.rb_value, command = self.script_select)
        self.w.Radiobutton_deletescript.config(value = "delete", variable = self.rb_value, command = self.script_select)
        self.w.Radiobutton_delrelpathscript.config(value = "delrelpath", variable = self.rb_value, command = self.script_select)
        self.w.Radiobutton_copyscript.select()    
        self.show_script(copyscript)        
        self.action = "copy"
        self.w.Label_script.config(text = copyscript)
        self.w.Checkbutton_delrelpath.config(state = DISABLED)
        self.w.Label_scripttype.config(text = "Copyscript")
    def script_select(self):
        print("Script selected is: " + self.rb_value.get())
        if self.rb_value.get() == "copy":
            self.show_script(self.copyscript)
            self.action = "copy"
            self.w.Button_execute.config(state = NORMAL)
            self.w.Label_script.config(text = self.copyscript)
            self.w.Checkbutton_delrelpath.config(state = DISABLED)
            self.w.Label_scripttype.config(text = "Copyscript")
        elif self.rb_value.get() == "delete":
            self.show_script(self.deletescript)
            self.action = "delete"
            self.w.Button_execute.config(state = NORMAL)
            self.w.Label_script.config(text = self.deletescript)
            self.w.Checkbutton_delrelpath.config(state = NORMAL)
            self.w.Label_scripttype.config(text = "Deletescript")
        elif self.rb_value.get() == "delrelpath":
            self.show_script(self.delrelpathscript)
            self.action = "delrelpath"
            self.w.Button_execute.config(state = DISABLED)
            self.w.Label_script.config(text = self.delrelpathscript)
            self.w.Checkbutton_delrelpath.config(state = DISABLED)
            self.w.Label_scripttype.config(text = "Delrelpathscript")
        self.w.Button_execute.config(text = self.action)

    def show_script(self, script):        
        try:
            file = open(script)
        except FileNotFoundError:
            print("File does not exist: " + script)
        text = file.read()
        self.w.Text_script.delete(1.0, 'end')
        self.w.Text_script.insert('end', text)
        self.w.Text_script.insert('end', "\r\n")

    def show_messages(self, text, b_clear):
        if b_clear:
            self.w.Text_messages.delete(1.0, 'end')
        self.w.Text_messages.insert('end', text)
        self.w.Text_messages.insert('end', "\r\n")

    def show_errors(self, text, b_clear):
        if b_clear:
            self.w.Text_errors.delete(1.0, 'end')
        self.w.Text_errors.insert('end', text)
        self.w.Text_errors.insert('end', "\r\n")
        
    def exec_handler(self):
        if self.action == "copy":
            cmdfile = self.copyscript
        elif self.action == "delete" or self.action == "delrelpath":
            cmdfile = self.deletescript
        self.w.Label_script.config(text = cmdfile)
        my_cmd = "call " + cmdfile 
        owndir = os.getcwd()
        os.chdir(os.path.join(datadir, Globals.cmd_files_subdir))    
        my_cmd_output = subprocess.Popen(my_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (output, error) = my_cmd_output.communicate()
        self.show_messages(output, True)
        self.show_errors(error, True)
        if self.action == "delete" and self.delrelpathscript is not None and self.w.cb_delrelpath_var.get():
            cmdfile_delrelpath = self.delrelpathscript
            my_cmd = "call " + cmdfile_delrelpath 
            my_cmd_output = subprocess.Popen(my_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
            (output, error) = my_cmd_output.communicate()
            self.show_messages(output, False)
            self.show_errors(error, False)
            self.w.Label_script.config(text = cmdfile + ' + ' + cmdfile_delrelpath)
        os.chdir(owndir)

    def close_handler(self): #calles when window is closing:
        self.root.destroy()

    def __del__(self):
        self.a = 1
        #print("*** Deleting Camera-Objekt.")


# Camera Treeview
class MyCameraTreeview:

    # The class "constructor" - It's actually an initializer 
    def __init__(self, pmain, cameraname = None):
        self.main = pmain
        self.cameraname = cameraname
        self.root = tk.Toplevel()
        self.w = Dateimeister.Toplevel_treeview_camera(self.root)
        self.root.protocol("WM_DELETE_WINDOW", self.close_handler)

        if cameraname is not None:
            self.root.title(cameraname)
        else:
            self.root.title("Cameras")
        width,height=Globals.screen_width,Globals.screen_height
        v_dim=str(width)+'x'+str(height)
        self.root.geometry(v_dim)
        self.root.resizable(True, True)
        self.tv = self.w.Scrolledtreeview_camera
        self.tv.heading("#0", text="Camera")
        self.tv.heading("#1", text="Last modification")
        self.tv.heading("#2", text="Type Subdir")
        self.tv.heading("#3", text="Suffix Process")
        self.tv.config(selectmode = tk.BROWSE)
        # bind select events
        self.tv.tag_bind("camera", "<<TreeviewSelect>>", self.item_selected_camera)
        self.tv.tag_bind("type",   "<<TreeviewSelect>>", self.item_selected_type)
        self.tv.tag_bind("suffix", "<<TreeviewSelect>>", self.item_selected_suffix)
        
        self.entry_camera = self.w.Entry_camera
        self.label_camera = self.w.Label_camera
        self.entry_type = self.w.Entry_type
        self.label_type = self.w.Label_type
        self.entry_suffix = self.w.Entry_suffix
        self.label_suffix = self.w.Label_suffix
        self.entry_subdir = self.w.Entry_subdir
        self.label_subdir = self.w.Label_subdir
        self.button_apply = self.w.Button_apply
        self.button_apply.config(command = self.apply_new)
        self.button_cancel = self.w.Button_cancel
        self.button_cancel.config(command = self.cancel_new)
        self.button_camera_new = self.w.Button_camera_new
        self.button_camera_new.config(command = self.camera_new)
        self.root.bind('<Return>', self.apply_new)

        self.label_camera.config(text = "new item")

        # Undo /Redo Funktionen
        self.button_undo = self.w.Button_undo
        self.button_redo = self.w.Button_redo
        self.button_undo.config(command = self.button_undo_h)
        self.button_redo.config(command = self.button_redo_h)
        self.button_undo.config(state = DISABLED)
        self.button_redo.config(state = DISABLED)
        self.root.bind('<Control-z>', lambda event: self.process_undo(event))
        self.root.bind('<Control-y>', lambda event: self.process_redo(event))

        # Create the context menus
        self.context_menu = tk.Menu(self.tv, tearoff=0)
        #self.context_menu.add_command(label="new suffix", command=self.type_new_suffix)    
        self.context_menu.add_command(label="change"    , command=self.type_change)    
        self.context_menu.add_command(label="delete"    , command=self.type_delete)    
        self.tv.bind("<Button-3>", self.set_selection_by_button3) # selects item at mouse position just like left-click   
        self.proctype_menu = Menu(self.context_menu, tearoff=0)

        # some instance variables 
        # select item, tag, text
        self.item = ""
        self.tag  = ""
        self.text = ""
        self.event = []
        self.context_menu_required = False
        self.newitem = "" 
        self.camera = ""
        self.ctype  = ""
        self.suffix = ""
        self.proctype = ""
        self.subdir = ""
        self.dict_camera_iid = {}  # initial, refresh after applying changed xml       
        self.dict_subdirs = {}
        self.dict_process_image = {}
        self.locked = False
        self.entry_camera.config(state = DISABLED)                  
        self.entry_type.config(state = DISABLED)                  
        self.entry_suffix.config(state = DISABLED)                  
        self.entry_subdir.config(state = DISABLED)                  

        # Undo /Redo Funktionen
        self.processid_akt = 0
        self.processid_high = 0
        self.processid_incr = 10
        self.dict_processid_xmlfile = {}
        self.list_processids = []
        self.stack_processids = [] # list
        # historize initial state
        self.historize_process()

        self.lock_treeview(False)
        # populate proctype submenue with proctypes from ini
        self.update_proctype_menu()
            
        # fille treeview from xml
        self.treeview_from_xml(Globals.config_files_xml)
    
    def new_text(self, o, text):
        o.delete(0, 'end')
        o.insert('end', text)

    def treeview_clear(self):    
        for i in self.tv.get_children():
           self.tv.delete(i)
        self.root.update()    

    def lock_treeview(self, block):
        if block == False: #set to not lockes
            self.locked = False # remove lock from treeview
            ttk.Style().configure("Treeview", background="white", foreground="black", fieldbackground="white")
            # also enable camera_new Button
            self.button_camera_new.config(state = NORMAL)
        else: #
            self.locked = True # remove lock from treeview
            ttk.Style().configure("Treeview", background="lightgrey", foreground="black", fieldbackground="lightgrey")
            # also disable camera_new Button
            self.button_camera_new.config(state = DISABLED)
    
    
    def treeview_from_xml(self, xml):
        #retrieve cameras from xml-file
        #get usedates
        # get dict Type -> Subdir
        self.dict_subdirs = {}
        self.dict_subdirs = DX.get_subdirs(xml)
        self.dict_process_image = {}
        self.dict_process_image = DX.get_process_image(xml)
        self.treeview_clear()
        self.dict_camera_iid = {}
        dict_cameras_usedate = DX.get_cameras_usedate(xml)
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
        dict_cameras = DX.get_cameras_types_suffixes(xml)
        dict_type_without_suffix = {}
        for camera in dict_cameras:
            ctype_num = 0
            usedate = dict_cameras_usedate[camera]
            cid = self.tv.insert("", tk.END, text = camera, values = (usedate, "", ""), tag = ("camera"))
            self.dict_camera_iid[camera] = cid
            dict_type_without_suffix[camera] = {}
            for ctype in dict_cameras[camera]:
                ctype_num += 1
                if ctype in self.dict_subdirs:
                    subdir = self.dict_subdirs[ctype]
                else: # error: each type needs a subdir
                    subdir = "!"
                tid = self.tv.insert(cid, tk.END, text = ctype, values = ("", subdir, ""), tag = ("type"))
                csuffix_num = 0
                for csuffix in dict_cameras[camera][ctype]:
                    csuffix_num += 1
                    if csuffix in self.dict_process_image:
                        process_image = self.dict_process_image[csuffix]
                    else: # error: each type needs a subdir
                        process_image = "!"
                    sid = self.tv.insert(tid, tk.END, text = csuffix, values = ("", "", process_image), tag = ("suffix"))
                    #print("Camera: " + camera + " Type: " + ctype + " Suffix: " + csuffix + " camera_usedate: " + usedate)
                if csuffix_num == 0:
                    dict_type_without_suffix[camera][ctype] = tid
        if ctype_num == 0:
            messagebox.showinfo("INIT", "Camera " + camera + " no type defined. At least 1 is needed", parent = self.root)
        for camera in dict_type_without_suffix: # ask for missing suffix
            dict_types = dict_type_without_suffix[camera]
            for ctype in dict_types:
                tid = dict_type_without_suffix[camera][ctype]
                self.open_camera(camera) # expand camera node
                messagebox.showinfo("MyCameraTreeview", "Camera " + camera + " type " + ctype + " no suffix defined. At least 1 is needed", parent = self.root)
                self.tv.focus(tid)
                self.tv.selection_set(tid)
                self.context_menu_required = True
                self.retrieve_item(self.event)
                self.type_new_suffix()

    # called when selected depending on bindings defined for tags
    def item_selected_camera(self, event):
        self.retrieve_item(event)
    def item_selected_type(self, event):
        self.retrieve_item(event)
    def item_selected_suffix(self, event):
        self.retrieve_item(event)
    
    
    # retrieves item tag and text for the selected item and show context menu if button-3 pressed or from program
    def retrieve_item(self, event):
        if self.locked == False: # there is no incomplete work (e.g. new type without suffix)
            try:
                # Get the Id of the first selected item.
                self.item = self.tv.selection()[0]
                print("Item selected: " , str(self.tv.selection()))
            except IndexError:
                # If the tuple is empty, there is no selected item.
                messagebox.showwarning(message="Nothin selected", title="Treeview Selection", parent = self.root)
            else:
                # Get and display the text of the selected item.
                self.text = self.tv.item(self.item, option="text")
                self.tag  = self.tv.item(self.item,  option="tag")[0]
                #messagebox.showinfo(message = self.tag, title="Treeview Selection", parent = self.root) 
                if self.context_menu_required:
                    if self.tag.upper() == "CAMERA":
                        self.context_menu.delete(0, 10)
                        self.context_menu.insert_command(0, label = self.text + " new type...", command=self.camera_new_type)
                        self.context_menu.insert_command(1, label = self.text + " change...", command=self.camera_change)
                        self.context_menu.insert_command(2, label = self.text + " delete", command=self.camera_delete)
                    elif self.tag.upper() == "TYPE":
                        self.context_menu.delete(0, 10)
                        self.context_menu.insert_command(0, label = self.text + " new suffix...", command=self.type_new_suffix)
                        self.context_menu.insert_command(1, label = self.text + " change...", command=self.type_change)
                        self.context_menu.insert_command(2, label = self.text + " delete", command=self.type_delete)
                        self.context_menu.insert_command(3, label = self.text + " subdir...", command=self.type_subdir)
                    elif self.tag.upper() == "SUFFIX": # suffix nothing new possible
                        self.context_menu.delete(0, 10)
                        self.context_menu.insert_command(0, label = self.text + " change...", command=self.suffix_change)
                        self.context_menu.insert_command(1, label = self.text + " delete", command=self.suffix_delete)
                        self.context_menu.add_cascade(label="Select processing type", menu = self.proctype_menu) # add submenu of processing types
                    self.context_menu.post(self.event.x_root, self.event.y_root)
                self.context_menu_required = False
        else: # locked
            print("retrieve_item is locked")

            
    def update_proctype_menu(self):
        # descending by usedate
        self.proctype_menu.delete(0, "end")
        # populate proctype_menu
        for item in self.main.dict_proctypes: # from main, filled in dateimeister_support.init from inifile
            print("Process Image  {:s}, {:s}".format(item, self.main.dict_proctypes[item]))
            labeltext = self.main.dict_proctypes[item]
            self.proctype_menu.add_command(label=labeltext, command = lambda item=item: self.proctype_apply(item))
        
    def proctype_apply(self, i): # react to proctype_menu, i is proctype-key from submenu 
        proctype = self.main.dict_proctypes[i].upper()
        camera, ctype, suffix, iid = self.get_camera_type_suffix(self.item)
        self.camera = camera
        self.ctype  = ctype
        self.suffix = suffix
        self.proctype = proctype
        self.newitem = "PROCTYPE_NEW"
        print("** Menuitem selected: " + i + " proctype is: " + proctype + " for suffix: " + suffix)
        self.enable_processing(False, False, False, False, False, "", "", "", "") # enable/ disable entries, buttons, return key
        self.apply_new()

    # handler for mouse right click in treeview
    def set_selection_by_button3(self, event):
        iid = self.tv.identify('item', event.x, event.y)
        self.event = event
        print("button 3 clicked, iid is: " + str(iid)) 
        if iid:
            # mouse pointer over item
            self.tv.focus(iid)
            self.tv.selection_set(iid)
            self.context_menu_required = True
            print(" iid is: " + str(iid)) 
        else:
            # mouse pointer not over item
            # occurs when items do not fill frame
            # no action required
            pass        
        
    # command handler for camera new button
    def camera_new(self):
        print(self.text + " camera new selected by button")
        self.newitem = "CAMERA_NEW" 
        self.enable_processing(True, True, True, False, True, "", "", "", "") # enable/ disable entries, buttons, return key

    # the command handlers for treeview context menu
    def camera_change(self):
        print(self.text + " camera change selected from context menu")
        camera, iid = self.get_camera(self.item)
        self.newitem = "CAMERA_RENAME" 
        self.camera = camera
        self.enable_processing(True, False, False, False, True, self.camera, "", "", "") # enable/ disable entries, buttons, return key

    def camera_delete(self):
        print(self.text + " camera delete selected from context menu")
        camera, iid = self.get_camera(self.item)
        self.newitem = "CAMERA_DELETE" 
        self.camera = camera
        self.enable_processing(False, False, False, False, False, "", "", "", "") # enable/ disable entries, buttons, return key
        self.apply_new() # needed because we now ally-button / return key for which ally_new is the command handler. so we have to call it explicitly
    
    def camera_new_type(self):
        print(self.text + " camera new type selected from context menu")
        # ask for suffix name
        camera, iid = self.get_camera(self.item)
        self.newitem = "TYPE_NEW" 
        self.camera = camera
        self.enable_processing(False, True, True, False, True, self.camera, "", "", "") # enable/ disable entries, buttons, return key
    
    def type_change(self):
        print(self.text + " type change selected from context menu")
        # ask for type name
        camera, ctype, iid = self.get_camera_type(self.item)
        self.entry_camera.delete(0, 'end')
        self.entry_camera.focus_set()
        self.newitem = "TYPE_RENAME" 
        self.camera = camera
        self.ctype  = ctype
        self.enable_processing(False, True, False, False, True, self.camera, self.ctype, "", "") # enable/ disable entries, buttons, return key

    def type_delete(self):
        print(self.text + " type delete selected from context menu")
        camera, ctype, iid = self.get_camera_type(self.item)
        self.newitem = "TYPE_DELETE" 
        self.camera = camera
        self.ctype  = ctype
        self.enable_processing(False, False, False, False, False, "", "", "", "") # enable/ disable entries, buttons, return key
        self.apply_new()

    def type_new_suffix(self):
        print(self.text + " type new suffix selected from context menu or from treeview_from_xml because new type has no suffix")
        # ask for suffix name
        camera, ctype, iid = self.get_camera_type(self.item)
        self.entry_camera.delete(0, 'end')
        self.entry_camera.focus_set()
        self.newitem = "SUFFIX_NEW" 
        self.camera = camera
        self.ctype  = ctype
        self.suffix = self.text
        self.enable_processing(False, False, True, False, True, self.camera, self.ctype, "", "") # enable/ disable entries, buttons, return key
 
    def type_subdir(self):
        print(self.text + " type subdir selected from context menu")
        # ask for type name
        camera, ctype, iid = self.get_camera_type(self.item)
        self.entry_camera.delete(0, 'end')
        self.entry_camera.focus_set()
        self.newitem = "TYPE_SUBDIR" 
        self.camera = camera
        self.ctype  = ctype
        self.enable_processing(False, False, False, True, True, self.camera, self.ctype, "", "") # enable/ disable entries, buttons, return key

    def suffix_change(self):
        print(self.text + " suffix change selected from context menu")
        # ask for suffix name
        camera, ctype, suffix, iid = self.get_camera_type_suffix(self.item)
        self.entry_camera.delete(0, 'end')
        self.entry_camera.focus_set()
        self.newitem = "SUFFIX_RENAME" 
        self.camera = camera
        self.ctype  = ctype
        self.suffix = self.text
        self.enable_processing(False, False, True, False, True, self.camera, self.ctype, "", "") # enable/ disable entries, buttons, return key

    def suffix_delete(self):
        print(self.text + " suffix delete selected from context menu")
        camera, ctype, suffix, iid = self.get_camera_type_suffix(self.item)
        self.newitem = "SUFFIX_DELETE" 
        self.camera = camera
        self.ctype  = ctype
        self.suffix = self.text
        self.enable_processing(False, False, False, False, False, "", "", "", "") # enable/ disable entries, buttons, return key
        self.apply_new()

    def enable_processing(self, b_camera, b_type, b_suffix, b_subdir, b_buttons, text_camera, text_ctype, text_suffix, text_subdir):
        # enable all entries, just for setting text
        self.entry_camera.config(state = NORMAL)                  
        self.entry_type.config(state = NORMAL)                  
        self.entry_suffix.config(state = NORMAL)                  
        self.entry_subdir.config(state = NORMAL)                  
        # fill entries with selection from treeview
        self.new_text(self.entry_camera, text_camera)
        self.new_text(self.entry_type, text_ctype)
        self.new_text(self.entry_suffix, text_suffix)
        self.dict_subdirs = DX.get_subdirs(Globals.config_files_xml)
        if text_ctype in self.dict_subdirs:
            suffix = self.dict_subdirs[self.ctype]
            print("Suffix for ctype " + text_ctype + " is " + suffix)
            self.new_text(self.entry_subdir, suffix)
        else:
            self.new_text(self.entry_subdir, "")

        # initially disable all entries, buttons and return key, can be overridden
        self.root.unbind('<Return>')
        self.button_apply.config(state = DISABLED)
        self.button_cancel.config(state = DISABLED)
        self.entry_camera.config(state = DISABLED)                  
        self.entry_type.config(state = DISABLED)                  
        self.entry_suffix.config(state = DISABLED)                  
        self.entry_subdir.config(state = DISABLED)                  
        focus = False
        if b_camera == True:
            self.entry_camera.config(state = NORMAL, background = 'yellow')
            self.entry_camera.focus_set()
            focus = True

        if b_type == True:
            self.entry_type.config(state = NORMAL, background = 'yellow')
            if not focus: # dont override focus from higher level object
                self.entry_type.focus_set()
                focus = True

        if b_suffix == True:
            self.entry_suffix.config(state = NORMAL, background = 'yellow')
            if not focus: # dont override focus from higher level object
                self.entry_suffix.focus_set()
                focus = True

        if b_subdir == True:
            self.entry_subdir.config(state = NORMAL, background = 'yellow')
            if not focus: # dont override focus from higher level object
                self.entry_subdir.focus_set()
                focus = True

        # finally enable button if something has to be done
        if b_buttons:
            self.button_apply.config(state = NORMAL)
            self.button_cancel.config(state = NORMAL)
            self.root.bind('<Return>', self.apply_new)
        self.lock_treeview(True) # suppress further commands from context-menu until this transaction has finished


    def get_camera_type_suffix(self, iid): # find parent of parent of suffix
        iid = self.item 
        suffix = self.text
        iid = self.tv.parent(iid)
        ctype = self.tv.item(iid, option="text")
        iid = self.tv.parent(iid)
        camera = self.tv.item(iid, option="text")
        return camera, ctype, suffix, iid # iid of camra
        
    def get_camera_type(self, iid): # find parent of type
        iid = self.item 
        ctype = self.text
        iid = self.tv.parent(iid)
        camera = self.tv.item(iid, option="text")
        return camera, ctype, iid # iid of camera
        
    def get_camera(self, iid): # find parent of type
        iid = self.item 
        camera = self.tv.item(iid, option="text")
        return camera, iid # iid of camera

    def apply_new(self, event = None):
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
        if self.newitem == "SUFFIX_NEW":
            suffix = self.entry_suffix.get().upper()
            if suffix is not None and suffix != "":
                rc = DX.new_camera_type_suffix(Globals.config_files_xml, self.camera, self.ctype, suffix, ts) 
            else: # entry_suffix is empty
                messagebox.showinfo("MyCameraTreeview", "Camera " + self.camera + " type " + ctype + \
                 " no suffix defined. At least 1 is needed  or press cancel", parent = self.root)
                self.entry_suffix.focus_set()
                return
        elif self.newitem == "SUFFIX_RENAME":
            suffix_new = self.entry_suffix.get().upper()
            rc = DX.update_camera_type_suffix(Globals.config_files_xml, self.camera, self.ctype, self.suffix, suffix_new, ts)
            self.suffix = suffix_new
        elif self.newitem == "SUFFIX_DELETE":
            suffix = self.suffix
            rc = DX.update_camera_type_suffix(Globals.config_files_xml, self.camera, self.ctype, suffix, "", ts)  # empty newname will delete suffix
            print("delete suffix rc: " + str(rc))
        elif self.newitem == "TYPE_NEW":
            ctype  = self.entry_type.get().upper()
            if ctype is not None and ctype != "":
                suffix = self.entry_suffix.get().upper()
                if suffix is None or suffix == "":
                    messagebox.showinfo("MyCameraTreeview", "Camera " + self.camera + " type " + ctype + \
                     " no suffix defined. At least 1 is needed  or press cancel", parent = self.root)
                    self.entry_suffix.focus_set()
                    return
                else:
                    rc = DX.new_camera_type_suffix(Globals.config_files_xml, self.camera, ctype, suffix, ts)
            else: # entry_type is empty
                messagebox.showinfo("MyCameraTreeview", "Camera " + self.camera + " no type defined. Please enter type or press cancel", parent = self.root)
                self.entry_type.focus_set()
                return
        elif self.newitem == "TYPE_RENAME":
            type_new = self.entry_type.get().upper()
            rc = DX.update_camera_type(Globals.config_files_xml, self.camera, self.ctype, type_new, ts) 
            self.ctype = type_new
        elif self.newitem == "TYPE_DELETE":
            #print(" delete requested for: " + self.camera + '.' + self.ctype)
            rc = DX.update_camera_type(Globals.config_files_xml, self.camera, self.ctype, "", ts)  # empty newname will delete suffix
        elif self.newitem == "TYPE_SUBDIR":
            # create new subdir in xml or update if type-subdir already exists
            subdir = self.entry_subdir.get()
            rc = DX.new_subdir(Globals.config_files_xml, self.ctype, subdir)
            if rc == 0:
                print("subdir node does not exist, make new for type: " + self.ctype + " subdir: " + subdir)
            elif rc == 1:
                print("subdir already exists, update subdir for type: " + self.ctype + " subdir: " + subdir)
        elif self.newitem == "PROCTYPE_NEW":
            # create new process_image in xml or update if suffix already exists
            rc = DX.new_process_image(Globals.config_files_xml, self.suffix, self.proctype)
            if rc == 0:
                print("process_image node does not exist, make new for suffix: " + self.suffix + " process: " + self.proctype)
            elif rc == 1:
                print("process_image already exists, update proctype for suffix: " + self.suffix + " process: " + self.proctype)
        elif self.newitem == "CAMERA_NEW":
            camera  = self.entry_camera.get().upper()
            if camera is not None and camera != "":
                ctype = self.entry_type.get().upper()
                if ctype is None or ctype == "":
                    messagebox.showinfo("MyCameraTreeview", "Camera " + self.camera + \
                     " no type defined. At least 1 is needed  or press cancel", parent = self.root)
                    self.entry_type.focus_set()
                    return
                else: # check if suffix is given
                    self.camera = camera
                    suffix = self.entry_suffix.get().upper()
                    if suffix is None or suffix == "":
                        messagebox.showinfo("MyCameraTreeview", "Camera " + self.camera + " type " + ctype + \
                         " no suffix defined. At least 1 is needed  or press cancel", parent = self.root)
                        self.entry_suffix.focus_set()
                        return
                    else: # create new camera / type /suffix
                        rc = DX.new_camera_type_suffix(Globals.config_files_xml, camera, ctype, suffix, ts)
            else: # entry_type is empty
                messagebox.showinfo("MyCameraTreeview", "Camera " + self.camera + " no camera defined. Please enter camera or press cancel", parent = self.root)
                self.entry_camera.focus_set()
                return
        elif self.newitem == "CAMERA_RENAME":
            print(" rename requested for: " + self.camera)
            camera_new = self.entry_camera.get().upper()
            rc = DX.update_camera(Globals.config_files_xml, self.camera, camera_new)
            self.camera = camera_new
        elif self.newitem == "CAMERA_DELETE":
            print(" delete requested for: " + self.camera)
            rc = DX.update_camera(Globals.config_files_xml, self.camera, "") # empty newname will delete camera

        self.treeview_from_xml(Globals.config_files_xml) # refresh treeview from changed xml
        if self.camera is not None and self.camera != "":
            self.open_camera(self.camera) # expand camera node
        self.enable_processing(False, False, False, False, False, "", "", "", "") # enable/ disable entries, buttons, return key
        self.lock_treeview(False)
        # main window needs new camera data
        self.update_main_window()
        self.historize_process()

    def cancel_new(self, event = None):
        if self.camera is not None and self.camera != "":
            self.open_camera(self.camera) # expand camera node
        self.enable_processing(False, False, False, False, False, "", "", "", "") # enable/ disable entries, buttons, return key
        self.lock_treeview(False)

    def open_camera(self, camera):
        if camera in self.dict_camera_iid:
            iid = self.dict_camera_iid[camera]
            #print ("try to open iid " + iid)
            self.tv.item(iid, open=True)
            item_children = self.tv.get_children(iid)
            print(item_children)
            for iid_child in item_children:
                self.tv.item(iid_child, open=True)

    def update_main_window(self):
        # cleanup: close all child windows of main except this one because nothing can be changed which affects camera window
        #self.state_gen_required()
        self.main.dict_cameras, self.main.dict_subdirs, self.main.dict_process_image = self.main.get_camera_xml()
        #print("update_main_window dict_camera: " + str(self.main.dict_cameras))



    # Undo /Redo Funktionen
    def process_undo(self, event):
        print("ctrl_z pressed.")
        # if there is a predecessor in list_processids (len > 1):
        #   move processid_akt from list_processids to undo-stack, then apply new act (predecessor) giving the processids from act and undone
        num_elements = len(self.list_processids)
        if num_elements <= 1:
            messagebox.showinfo("UNDO", "no further processes which can be undone", parent = self.root)
        else:
            processid_undone = self.list_processids[-1] # last element
            self.stack_processids.append(processid_undone)
            self.list_processids.pop() # removes last element
            self.processid_akt = self.list_processids[-1] # "new" last element
            print (" UNDO List Processids: " + str(self.list_processids) + " REDO Stack Processids: " + str(self.stack_processids))
            self.apply_process_id(self.processid_akt)
            self.endis_buttons()

    def process_redo(self, event):
        print("ctrl_y pressed.")
        # if there is an element in stack processids (len > 1):
        #   move last processid from stack processids to list_processids, then apply new act (moved from stack) giving the processids from act and predecessor of list_processids
        num_elements = len(self.stack_processids)
        if num_elements < 1:
            messagebox.showinfo("REDO", "no further processes which can be redone", parent = self.root)
        else:
            processid_predecessor = self.list_processids[-1] # last element
            processid_redone = self.stack_processids[-1] # last element
            self.list_processids.append(processid_redone)
            self.stack_processids.pop() # removes last element
            self.processid_akt = self.list_processids[-1] # "new" last element
            print (" REDO List Processids: " + str(self.list_processids) + " REDO Stack Processids: " + str(self.stack_processids))
            self.apply_process_id(self.processid_akt)
            self.endis_buttons()

    def endis_buttons(self): # disable / enable buttons depending on processids
        if len(self.list_processids) > 1:
            self.button_undo.config(state = NORMAL)
        else:
            self.button_undo.config(state = DISABLED)
        if len(self.stack_processids) > 0:
            self.button_redo.config(state = NORMAL)
        else:
            self.button_redo.config(state = DISABLED)


    def apply_process_id(self, process_id):
        # apply xml for actual processid
        # copy xml for processid_akt to "normal" xml and apply it
        xml_filename = self.dict_processid_xmlfile[process_id]
        print("apply_process_id, xml to apply is: ", xml_filename)
        # copy historized xml to "normal" xml
        sourcefile = xml_filename
        targetfile = Globals.config_files_xml
        try:
            shutil.copy(sourcefile, targetfile)
            #print("Source file copied to destination successfully.")
         
        # If source and destination are same
        except shutil.FileNotFoundError:
            print("Source file " + sourcefile + " not found.")
         
        # If source not exists
        except shutil.SameFileError:
            print("Source and destination represents the same file.")
         
        # If there is any permission issue
        except PermissionError:
            print("Permission denied.")
         
        # For other errors
        except:
            print("Error occurred while copying file.")
        # now apply xml
        self.treeview_from_xml(Globals.config_files_xml) # refresh treeview from changed xml
        if self.camera is not None and self.camera != "":
            self.open_camera(self.camera) # expand camera node
        
    def historize_process(self):
        self.processid_high += self.processid_incr
        self.processid_akt = self.processid_high
        print ("Processid_high is now: " + str(self.processid_high) + " Processid_akt is now: " + str(self.processid_akt))
        # wir we save the current xml-file to firstname-<processid>.xml
        # E:/Arbeit/python/Dateimeister_vor_git/daten/config/dateimeister_configfiles.xml
        config_dir = os.path.join(datadir, Globals.config_files_subdir)
        xml_filename = Globals.config_files_xml
        # replace last . by <processid>.
        xml_filename = re.sub(r'\.([^\.]+)$', rf"_{self.processid_akt}.\1", xml_filename) # reconstruct newline in template
        self.dict_processid_xmlfile[self.processid_akt] = xml_filename
        print("historize_process, new xml is: ", xml_filename)
        # save actual xml (changed by the action which called historize_processorize) to a config file with xml_filename containing the actual processid
        sourcefile = Globals.config_files_xml
        targetfile = xml_filename
        try:
            shutil.copy(sourcefile, targetfile)
            #print("Source file copied to destination successfully.")
         
        # If source and destination are same
        except shutil.FileNotFoundError:
            print("Source file " + sourcefile + " not found.")
         
        # If source not exists
        except shutil.SameFileError:
            print("Source and destination represents the same file.")
         
        # If there is any permission issue
        except PermissionError:
            print("Permission denied.")
         
        # For other errors
        except:
            print("Error occurred while copying file.")

        self.list_processids.append(self.processid_akt)
        self.endis_buttons()

    def button_undo_h(self, event = None):
        print("UUNdo pressed")
        self.process_undo((0, 0))
        
    def button_redo_h(self, event = None):
        self.process_redo((0, 0))
    # Ende undo /redo-Funktionen


    def close_handler(self): #calles when window is closing:
        self.root.destroy()

    def __del__(self):
        self.a = 1
        #print("*** Deleting Camera-Treeview-Objekt.")



class Dateimeister_support:
    def __init__(self, root):
        self.root = root
        self.root.protocol( 'WM_DELETE_WINDOW' , self.root.destroy)
        # Creates a toplevel widget.
        self.w = Dateimeister.Toplevel1(self.root)
        self.dict_process_image = {}
        self.win_duplicates = None
        self.dict_status_image = {}
        self.codepage = ""
        self.config_file = ""
        self.tooltiptext = ""
        self.context_menu = None
        self.timestamp = datetime.now()
        self.use_camera_prefix = True

        self.init()
        self.root.mainloop()

    def init(self):
        global cb_num, cb_num_var, dict_templates, templatefile, \
            combobox_indir, combobox_indir_var, combobox_outdir, combobox_outdir_var, max_configfiles, max_indirs, max_outdirs, \
            button_indir_from_list, button_outdir_from_list, platform, datadir, oldcamera, dict_proctypes, _dict_file_image
        windll = ctypes.windll.kernel32
        self.codepage = windll.GetUserDefaultUILanguage()
        self.language = locale.windows_locale[ windll.GetUserDefaultUILanguage() ]
        os.environ["LANGUAGE"]    = self.language
        
        print("Codepage is: " + str(self.codepage) + " language is: " + self.language)
        
        inifile = "Dateimeister.ini" 
        config = configparser.ConfigParser() 
        config.read(inifile)
        default_indir  = config["dirs"]["indir"]
        default_outdir = config["dirs"]["outdir"]
        datadir = config["dirs"]["datadir"]
        Globals.config_files_subdir = config["dirs"]["config_files_subdir"]
        Globals.cmd_files_subdir    = config["dirs"]["cmd_files_subdir"]
        Globals.config_files_xml = config["misc"]["config_files_xml"]
        
        # read process_types from ini because depemdent on dateimeister implementation
        self.dict_proctypes = config["proc_types"]
        for t in self.dict_proctypes:
            print("Proctype: " + self.dict_proctypes[t]) 
        
        Globals.uncomment = config["misc"]["uncomment"] + " "        
        templatefile = config["misc"]["templatefile"]
        #max number of config_file-, indir-, outdir-entries in xml
        max_configfiles = config["misc"]["max_configfiles"]
        max_indirs      = config["misc"]["max_indirs"]
        max_outdirs     = config["misc"]["max_outdirs"]
        platform = config["misc"]["platform"].upper()
        if platform != "UNIX" and platform != "WINDOWS":
            messagebox.showerror("INIT", "Platform must be Windows or Unix, not " + platform)
            exit()
        
        dict_templates = {}
        _dict_file_image = {}


        # configure some controls
        self.o_camera  = self.w.Entry_camera
        self.lb_camera = self.w.Listbox_camera
        self.lb_camera.configure(exportselection=False)
        self.b_button1 = self.w.Button1
        self.b_button2 = self.w.Button2
        self.b_button2.config(command=self.B_camera_press)
        self.b_button_indir = self.w.Button1
        self.b_button_indir.config(command=self.Press_indir)
        self.b_button_outdir = self.w.Button_outdir
        self.b_button_outdir.config(command=self.Press_outdir)
        self.button_call = self.w.Button_call
        self.button_call.config(command = self.Press_generate)
        self.button_exec = self.w.Button_exec
        self.button_exec.config(command = self.button_exec_pressed)
        self.Button_exclude = self.w.Button_exclude
        self.Button_exclude.config(command=self.Button_exclude_all)
        self.Button_include = self.w.Button_include
        self.Button_include.config(command=self.Button_include_all)

        # get all camera information and fill camera-listbox
        self.dict_cameras, self.dict_subdirs, self.dict_process_image = self.get_camera_xml()
        #print("self.dict_process_image is: " + str(self.dict_process_image))

        self.t_text1 = self.w.Text1
        # set font
        font_tuple = ("Lucida Console", 10, "normal")
        self.t_text1.config(font = font_tuple)
        self.t_text1.tag_configure("normal_include", foreground="black", background = "white")
        self.t_text1.tag_configure("select_include", foreground="red", background = "white")
        self.t_text1.tag_configure("normal_exclude", foreground="lightgrey", background = "darkgrey")
        self.t_text1.tag_configure("select_exclude", foreground="red", background = "darkgrey")
        
        self.l_label1 = self.w.Label1
        self.label_num = self.w.Label_num
        self.lb_gen   = self.w.Listbox_gen
        self.button_include = self.w.Button_include
        self.button_exclude = self.w.Button_exclude
        self.button_include.config(state = DISABLED)
        self.button_exclude.config(state = DISABLED)
        self.button_undo = self.w.Button_undo
        self.button_redo = self.w.Button_redo
        self.button_undo.config(state = DISABLED)
        self.button_redo.config(state = DISABLED)
        self.button_undo.configure(command=self.button_undo_pressed)
        self.button_redo.configure(command=self.button_redo_pressed)
        Globals.button_duplicates = self.w.Button_duplicates
        Globals.button_duplicates.config(state = DISABLED)
        self.button_be = self.w.Button_be
        self.button_be.config(state = DISABLED)
        self.button_be.config(command = self.Button_be_pressed)
        self.button_exec.config(state = DISABLED)
        self.button_call.config(state = DISABLED) # generate-Button
        Globals.button_duplicates.configure(command=self.button_duplicates)
        
        self.label_indir  = self.w.Label_indir
        self.label_outdir = self.w.Label_outdir
        button_indir_from_list = self.w.Button_indir_from_list
        button_outdir_from_list = self.w.Button_outdir_from_list
        
        # Scrollbars
        V = Scrollbar(self.w.Frame1)
        V.place(relx = 1, rely = 0, relheight = .976, relwidth = .01, anchor = tk.NE)
        V.config(command=self.t_text1.yview)
        self.t_text1.config(yscrollcommand=V.set)  
        H = Scrollbar(self.w.Frame1, orient = HORIZONTAL)
        H.place(relx = 0, rely = 1, relheight = 0.024, relwidth = .99, anchor = tk.SW)
        H.config(command=self.t_text1.xview)
        self.t_text1.config(xscrollcommand=H.set)  
        self.t_text1.configure(wrap="none")
        
        self.cb_recursive = self.w.Checkbutton1
        self.cb_recursive.config(command = self.state_gen_required)
        self.cb_recursive_var = self.w.cb1_val
        self.cb_recursive_var.set(1)
        
        self.cb_prefix = self.w.Checkbutton_use_camera_name
        self.cb_prefix.config(command = self.state_gen_required)
        self.cb_prefix_var = self.w.cb_prefix_var
        self.cb_prefix_var.set(1)

        self.cb_addrelpath = self.w.Checkbutton_addrelpath
        self.cb_addrelpath.config(command = self.state_gen_required)
        self.cb_addrelpath_var = self.w.cb_addrelpath_var
        self.cb_addrelpath_var.set(0)

        self.cb_newer = self.w.Checkbutton_newer
        self.cb_newer.config(command = self.state_gen_required)
        self.cb_newer_var = self.w.cb_newer_var
        self.cb_newer_var.set(0)

        cb_num = self.w.Checkbutton_num
        cb_num_var = self.w.cbnum_var
        cb_num_var.set(1)

        combobox_indir = self.w.TCombobox_indir
        combobox_indir_var = self.w.combobox_indir
        combobox_indir.configure(exportselection=False)
        combobox_outdir = self.w.TCombobox_outdir
        combobox_outdir_var = self.w.combobox_outdir
        combobox_outdir.configure(exportselection=False)
        
        # Scrollbars
        VI = Scrollbar(combobox_indir, orient= VERTICAL)
        VI.place(relx = 1, rely = 0, relheight = 1, relwidth = .015, anchor = tk.NE)
        VI.config(command = combobox_indir.yview)
        combobox_indir.config(yscrollcommand = VI.set)
        VO = Scrollbar(combobox_outdir, orient= VERTICAL)
        VO.place(relx = 1, rely = 0, relheight = 1, relwidth = .015, anchor = tk.NE)
        VO.config(command = combobox_outdir.yview)
        combobox_outdir.config(yscrollcommand = VO.set)
        #listbox camera
        VC = Scrollbar(self.w.Frame_camera, orient= VERTICAL)
        VC.place(relx = 1, rely = 0.01, relheight = .96, relwidth = .03, anchor = tk.NE)
        VC.config(command = self.lb_camera.yview)
        self.lb_camera.config(yscrollcommand = VC.set)
        
        self.canvas_gallery = self.w.Canvas1
        # Scrollbars
        self.scroll_canvas_x = tk.Scrollbar(self.root, orient="horizontal", command=self.xview)
        #self.scroll_canvas_x.pack(side=BOTTOM, fill=BOTH)
        self.scroll_canvas_x.place(relx = .015, rely = .96, relheight = 0.015, relwidth = .97, anchor = tk.NW)
        self.canvas_gallery.config(xscrollcommand = self.scroll_canvas_x.set, scrollregion=self.canvas_gallery.bbox("all"))

        # Create the context menu
        self.context_menu = tk.Menu(self.canvas_gallery, tearoff=0)
        self.context_menu.add_command(label="Exclude", command=self.canvas_image_exclude)    
        self.context_menu.add_command(label="Show"   , command=self.canvas_image_show)    
        self.context_menu.add_command(label="Restart", command=self.canvas_video_restart)    
      
        # Events
        # Button 1 single haben wir deaktiviert, weil double immer auch zuerst single auslöst
        # deshalb exlude und show über Kontext-Menü (rechte Maustaste), Show zusätzlich auch mit Doppelclick
        #self.canvas_gallery.bind("<Button-1>", canvas_gallery_exclude)
        self.canvas_gallery.bind("<Double-Button-1>", self.canvas_gallery_show)
        self.canvas_gallery.bind('<Return>', self.canvas_gallery_show)    # show FSImage for selected thumbnail
        # Pfeitasten fürs scrollen
        self.canvas_gallery.bind("<Left>",  lambda event: self.xview("scroll", -1, "units"))
        self.canvas_gallery.bind("<Right>", lambda event: self.xview("scroll",  1, "units"))
        self.canvas_gallery.bind("<Prior>", lambda event: self.xview("scroll", -1, "page")) # Bind to PageUp
        self.canvas_gallery.bind("<Next>",  lambda event: self.xview("scroll",  1, "page"))  # Bind to PageDown    
        # Bind the context menu to the canvas widget
        self.canvas_gallery.bind("<Button-3>", self.show_context_menu)    
        self.canvas_gallery.bind('<Motion>', self.tooltip_imagefile)    
        self.canvas_gallery.bind('<Button-1>', self.canvas_button_1)    
        self.root.bind("<Configure>", self.on_window_resize)
        self.root.bind("<Destroy>",   self.on_window_destroy)
        # strg-z, y
        self.canvas_gallery.bind('<Control-z>', lambda event: self.process_undo(event))
        self.canvas_gallery.bind('<Control-y>', lambda event: self.process_redo(event))
        self.canvas_gallery.bind('+', lambda event: self.delay_decr(event))
        self.canvas_gallery.bind('-', lambda event: self.delay_incr(event))
        self.canvas_gallery.bind('0', lambda event: self.delay_deflt(event))
        self.canvas_gallery.bind('<FocusOut>', self.focus_out)
        self.lb_gen.bind('<Double-1>', self.lb_gen_double)
        self.lb_camera.bind('<Double-1>', self.lb_camera_double)

        self.t_text1.bind('<Double-1>', self.text1_double)  # show FSImage for selected line
        self.t_text1.bind('<Button-1>', self.text1_single)  # synchronize zext / gallery
        self.t_text1.bind('<Key>', self.text1_key)
        # handler for arrow up / down must be called AFTER the Text-class handler or the bind-handler is 1 step ahead
        self.t_text1.bindtags(('Text', '.!frame.!text', '.', 'all'))
        print("Bindtags: %s " % str(self.t_text1.bindtags()))

        cb_num.config(command = self.on_cb_num_toggle)
        combobox_indir.bind('<Double-1>', self.combobox_indir_double)
        combobox_outdir.bind('<Double-1>', self.combobox_outdir_double)
        combobox_indir.bind("<<ListboxSelect>>", lambda event: self.combobox_indir_check_exist(event))
        combobox_outdir.bind("<<ListboxSelect>>", lambda event: self.combobox_outdir_check_exist(event))
        button_indir_from_list.config(command = self.combobox_indir_double)  
        button_outdir_from_list.config(command = self.combobox_outdir_double)  
        
        self.label_indir.config(text = default_indir)
        self.label_outdir.config(text = default_outdir)
        self.l_label1.config(text = "Messages")
        self.label_num.config(text = "0")
        self.dict_gen_files = {}
        self.dict_gen_files_delete = {}
        Globals.thumbnails = {}
        images = []
        self.dict_image_lineno = {}
        self.title = self.root.title()
        oldcamera = ""

        
        # Fenstergröße
        Globals.screen_width  = int(self.root.winfo_screenwidth() * 0.9)
        Globals.screen_height = int(self.root.winfo_screenheight() * 0.8)
        print("Bildschirm ist " + str(Globals.screen_width) + " x " + str(Globals.screen_height))
        width,height=Globals.screen_width,Globals.screen_height
        v_dim=str(width)+'x'+str(height)
        self.root.geometry(v_dim)
        #my_w.maxsize(300,220)  # (maximum ) width , ( maximum) height
        #my_w.minsize(250,220)  # (minimum ) width , ( minimum) height
        self.root.resizable(False, False)
        self.tt = Dateimeister.ToolTip(self.canvas_gallery, "no images available", delay=0, follow = True)
        
        # Menubar
        menubar = Menu(self.root)
        self.filemenu = Menu(menubar, tearoff=0)
        self.filemenu.add_command(label="New", command=self.donothing)
        self.filemenu.add_command(label="Open config", command=self.open_config)
        self.filemenu.add_command(label="Save config", command=self.save_config)
        self.filemenu.add_command(label="Save config as...", command=self.saveas_config)
        self.filemenu.add_command(label="Apply config", command=self.apply_config)
        menubar.add_cascade(label="File", menu=self.filemenu)
        self.recentmenu = Menu(menubar, tearoff=0)
        self.filemenu.add_cascade(label="Open Recent", menu=self.recentmenu)
        self.filemenu.add_separator()
        self.filemenu.add_command(label="Exit", command=self.root.quit)
        self.filemenu.entryconfig(0, state=DISABLED)
        self.filemenu.entryconfig(1, state=DISABLED) # open after Browse / Edit, we need indir and type
        self.filemenu.entryconfig(2, state=DISABLED)
        self.filemenu.entryconfig(3, state=DISABLED)
        self.filemenu.entryconfig(4, state=DISABLED)
        self.filemenu.entryconfig(5, state=DISABLED)
        
        # camera menu
        cameramenu = Menu(menubar, tearoff=0)
        cameramenu.add_command(label="Edit Cameras...", command = self.menu_cameras_edit)
        cameramenu.add_command(label="Diatisch", command = self.menu_diatisch)
        menubar.add_cascade(label="Tools", menu=cameramenu)

        helpmenu = Menu(menubar, tearoff=0)
        helpmenu.add_command(label="Help Index", command=self.donothing)
        helpmenu.add_command(label="About...", command=self.donothing)
        menubar.add_cascade(label="Help", menu=helpmenu)

        self.root.config(menu=menubar)
        
        # fill in combobox
        result = DX.get_indirs(Globals.config_files_xml)
        dict_filename_usedate = {}
        for tfile in result:
            #print("infile: " + tfile)
            attribute = result[tfile]
            searchattr = 'usedate'
            for attribut in attribute:
                #print("  " + attribut + " = " + attribute[attribut])
                if attribut == searchattr:
                    dict_filename_usedate[tfile] = attribute[searchattr]
            
        # descending by usedate
        sorted_d = dict( sorted(dict_filename_usedate.items(), key=operator.itemgetter(1), reverse=True))
        # make list
        ii = 0
        indexes = []
        for tfile in sorted_d:
            combobox_indir.insert(END, tfile)
            if not os.path.isdir(tfile):
                #print("INDIR: " + tfile + " INDEX: " + str(ii))
                indexes.append(ii) # list of indizes to grey out because dir does not exist
            ii += 1
        if ii > 0:
            combobox_indir.select_set(0)
            button_indir_from_list.config(state = NORMAL)
        else: 
            button_indir_from_list.config(state = DISABLED)
        for ii in indexes:
            combobox_indir.itemconfig(ii, fg="gray")

        # fill out combobox
        result = DX.get_outdirs(Globals.config_files_xml)
        dict_filename_usedate = {}
        for tfile in result:
            #print("infile: " + tfile)
            attribute = result[tfile]
            searchattr = 'usedate'
            for attribut in attribute:
                #print("  " + attribut + " = " + attribute[attribut])
                if attribut == searchattr:
                    dict_filename_usedate[tfile] = attribute[searchattr]
            
        # descending by usedate
        sorted_d = dict( sorted(dict_filename_usedate.items(), key=operator.itemgetter(1), reverse=True))
        # make list
        ii = 0
        indexes = []
        for tfile in sorted_d:
            combobox_outdir.insert(END, tfile)
            if not os.path.isdir(tfile):
                print("OUTDIR: " + tfile + " INDEX: " + str(ii))
                indexes.append(ii) # list of indizes to disable because dir does not exist
            ii += 1
        if ii > 0:
            combobox_outdir.select_set(0)
            button_outdir_from_list.config(state = NORMAL)
        else: 
            button_outdir_from_list.config(state = DISABLED)
        for ii in indexes:
            combobox_outdir.itemconfig(ii, fg="gray")
        
    def donothing(self):
        print("Menuitem not yet implemented")
    
    def timer_end(self):
        print("Timer has elapsed")

    def lb_gen_double(self, event):
        self.Button_be_pressed(event)
    
    def lb_camera_double(self, event):
        self.B_camera_press(event)

    def combobox_indir_double(self, event = None):
        selected_indices = combobox_indir.curselection()
        indir = ",".join([combobox_indir.get(i) for i in selected_indices]) # because listbox has single selection
        self.label_indir.config(text = indir)

    def combobox_outdir_double(self, event = None):
        selected_indices = combobox_outdir.curselection()
        outdir = ",".join([combobox_outdir.get(i) for i in selected_indices]) # because listbox has single selection
        self.label_outdir.config(text = outdir)

    def combobox_indir_check_exist(self, event):
        index = combobox_indir.curselection()[0]
        indir = combobox_indir.get(index) # because listbox has single selection
        print("current selection is: " + indir + " INDEX: " + str(index))
        if not os.path.isdir(indir):
            combobox_indir.selection_clear(index) # dont select, MessageBox
            messagebox.showerror("showerror", "Indir: " + indir + " does not exist, choose another one")
    
    def combobox_outdir_check_exist(self, event):
        index = combobox_outdir.curselection()[0]
        outdir = combobox_outdir.get(index) # because listbox has single selection
        print("current selection is: " + outdir + " INDEX: " + str(index))
        if not os.path.isdir(outdir):
            combobox_outdir.selection_clear(index) # dont select, MessageBox
            messagebox.showerror("showerror", "outdir: " + outdir + " does not exist, choose another one")
        
    def open_config(self):
        # get config_files for indir / type
        
        endung = 'xml'
        self.config_file = fd.askopenfilename(initialdir = os.path.join(datadir, Globals.config_files_subdir), filetypes=[("config files", endung)])
        self.filemenu.entryconfig(4, state=NORMAL)
        self.root.title(self.title + ' ' + self.config_file)
        self.filemenu.entryconfig(2, state=NORMAL)

    def apply_config(self):
        tree = ET.parse(self.config_file)
        xmlroot = tree.getroot()
        time = xmlroot.attrib['time']
        print(time)    
        for thumbnail in xmlroot.findall('thumbnail'):
            #print (thumbnail.attrib['filename'])   
            image = thumbnail.find('image').text
            mystate = thumbnail.find('state').text
            #print(image)
            #print(mystate)
            # apply config
            if image in _dict_thumbnails[Globals.imagetype]:
                if _dict_thumbnails[Globals.imagetype][image] in Globals.thumbnails[Globals.imagetype]:
                    if mystate == "state.INCLUDE":
                        _dict_thumbnails[Globals.imagetype][image].setState(state.INCLUDE, None, False)
                    else:
                        _dict_thumbnails[Globals.imagetype][image].setState(state.EXCLUDE, None, False)
                else:
                    print("thumbnail for " + Globals.imagetype + " file " + image + " not found")
                    print(Globals.thumbnails)
            else:
                print("Imagefile: " + image + " not found in _dict thumdnails of type " + Globals.imagetype)
        self.historize_process()
        self.write_cmdfile(Globals.imagetype)


    def save_config(self): # Config-xml speichern
        print("Config File is: " + self.config_file)
        if self.config_file != "":
            self.write_config(self.config_file)
            # update config-file-entry in xml. will automatically create new entry if type or infile does not exist
            self.update_config_xml(self.config_file)
        else:
            self.saveas_config()

    def saveas_config(self): # Config-xml unter neuem Namen sichern
        endung = 'xml'
        self.config_file = fd.asksaveasfilename(initialdir = os.path.join(datadir, Globals.config_files_subdir), filetypes=[("config files", endung)])
        if (len(self.config_file) > 0):
            match = re.search(rf".*?{endung}$", self.config_file)
            if match:
                filename = self.config_file
            else:
                filename = self.config_file + '.' + endung
                self.config_file = filename
            self.write_config(filename)
            # update config-file-entry in xml. will automatically create new entry if type or infile does not exist
            self.update_config_xml(self.config_file)
            
            self.root.title(self.title + ' ' + self.config_file)
            self.filemenu.entryconfig(2, state=NORMAL) # Save
            self.filemenu.entryconfig(3, state=NORMAL) # Save As
            self.filemenu.entryconfig(4, state=NORMAL) # Apply config

    def update_config_xml(self, config_file): # Config-xml unter neuem Namen sichern und update
        # update config-file-entry in xml. will automatically create new entry if type or infile does not exist
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
        indir = self.label_indir.cget('text')
        # lower and slash instead of backslash
        indir = re.sub(r'\\', '/', indir).lower()
        my_config_file = re.sub(r'\\', '/', self.config_file).lower()
        #print("*** new config_file: " + my_config_file)

        result, sorted_d = self.get_dict_of_config_files(indir, Globals.imagetype)
        if my_config_file not in result: # this is a new file, so we have to clean up the xml entries in order to stay within max_configfiles
            # delete oldest files until max_configfiles - 1 is reached (because a new one will be created)
            #get dict descending by usedate and result with all attributes
            # in the first pass delete all Entries where file does not exist,afterwards delete entries for existing files if necessary
            # delete only if new config-file does not exist
            for loop in range(1, 3):
                result, sorted_d = self.get_dict_of_config_files(indir, Globals.imagetype) # we have to do this because list of config_files is changed between loops
                list_cfgfiles = []
                for t_cfg in sorted_d:
                    list_cfgfiles.append(t_cfg)
                num_to_delete = len(list_cfgfiles) - int(max_configfiles) + 1
                if num_to_delete > 0:
                    #print(str(list_cfgfiles))
                    ii = 0
                    for t in reversed(list_cfgfiles): # now the oldest are on top
                        if ii < num_to_delete:
                            if loop == 1: # in the first pass only delete entries for not existing files
                                if not os.path.isfile(t):
                                    DX.delete_cfgfile(Globals.config_files_xml, indir, Globals.imagetype, t)
                                    ii += 1
                            else: # delete also existing files if necessary
                                DX.delete_cfgfile(Globals.config_files_xml, indir, Globals.imagetype, t)
                                ii += 1
                        else:
                            break
        # now create new entry for my_config_file
        DX.new_cfgfile(Globals.config_files_xml, indir, Globals.imagetype, my_config_file, ts, self.num_images)
        # update usedate in Globals.config_files_xml
        DX.update_cfgfile(Globals.config_files_xml, indir, Globals.imagetype, my_config_file, ts, self.num_images)
        # finally update the recent files menu
        self.update_recent_menu(indir, Globals.imagetype)

    def update_recent_menu(self, indir, imagetype):
        # descending by usedate
        result, sorted_d = self.get_dict_of_config_files(indir, imagetype)
        #print("get_dict_of_config_files: " + str(sorted_d))
        
        self.recentmenu.delete(0, "end")
        ii = 0
        for item in sorted_d:
            usedate      = result[item]['usedate']
            mynum_images = result[item]['num_images']
            labeltext = item + ' (usedate: ' + usedate + ' ,images: ' + mynum_images + ')'
            self.recentmenu.add_command(label=labeltext, command = lambda item=item: self.recent_config(item))
            print("  config_file: " + labeltext)
            if not os.path.isfile(item):
                self.recentmenu.entryconfig(ii, state = DISABLED)
            ii += 1
        if ii == 0:
            self.filemenu.entryconfig(5, state=DISABLED)


    def write_config(self, filename): # Config-xml unter neuem Namen sichern
        file1 = open(filename, "w")
        
        s = '<?xml version="1.0" encoding="iso-8859-1"?>' + "\n"
        file1.write(s)
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())

        s = '<thumbnails time="' + ts + '">' + "\n"
        file1.write(s)
        for thumbnail in Globals.thumbnails[Globals.imagetype]:
            s = "    <thumbnail filename=\"" + thumbnail.getFile() + "\">\n"
            file1.write(s)
            s = "        <image>" + str(thumbnail.getFile()) + "</image>\n"
            file1.write(s)
            s = "        <state>" + str(thumbnail.getState()) + "</state>\n"
            file1.write(s)
            s = "    </thumbnail>\n"
            file1.write(s)
        s = '</thumbnails>' + "\n"
        file1.write(s)
        # Closing file
        file1.close()
        
    def get_dict_of_config_files(self, pindir, imagetype): # returns dict sorted by usedate asc
        # lower and slash instead of backslash
        indir = re.sub(r'\\', '/', pindir).lower()
        result = DX.get_cfgfiles(Globals.config_files_xml, indir, imagetype)
        dict_filename_usedate = {}
        for cfg_file in result:
            print("config_file: " + cfg_file)
            attribute = result[cfg_file]
            searchattr = 'usedate'
            for attribut in attribute:
                print("  " + attribut + " = " + attribute[attribut])
                if attribut == searchattr:
                    dict_filename_usedate[cfg_file] = attribute[searchattr]
            
        # descending by usedate
        sorted_d = dict( sorted(dict_filename_usedate.items(), key=operator.itemgetter(1), reverse=True))
        return result, sorted_d


    def recent_config(self, item):
        print("** Menuitem selected: " + item)
        self.config_file = item
        self.filemenu.entryconfig(4, state=NORMAL)
        self.root.title(self.title + ' ' + self.config_file)
        self.filemenu.entryconfig(2, state=NORMAL)
    

    def tooltip_imagefile(self, event):
        tsnow = datetime.now()
        tdiff = abs(tsnow - self.timestamp)
        #print("*** Timer has finished, microsecons is: ", tdiff.microseconds)
        if  tdiff.microseconds > 100000:
            #print("Timer has finished, microsecons is: ", tdiff.microseconds)
            self.timestamp = tsnow
        else:
            return
        # Tooltip
        #x, y = self.canvas_gallery.winfo_pointerxy()
        text = "no image available"
        if len(Globals.thumbnails) > 0:
            canvas_x = self.canvas_gallery.canvasx(event.x)
            canvas_y = self.canvas_gallery.canvasy(event.y)
            thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
            if thumbnail is not None:
                text = thumbnail.getFile()
                #print("Image clicked: " + text)
            if text != self.tooltiptext:
                self.tt.update(text)
                self.tooltiptext = text
                self.stop_all_players()
                # if file is video, play video
                if thumbnail is not None:
                    player = thumbnail.getPlayer()
                    if player is not None: # this is a video
                        player.pstart()
                        player.setDelay(Globals.delay_default)
                        fps   = player.getFPS()
                        fc    = player.getFrameCount()
                        delay = player.getDelay()
                        frames_per_second = 1000 / delay
                        duration_in_seconds = fc / frames_per_second
                        #print ("FPS is: ", fps, " Total Num of Frames is: ", fc, " Delay is: ", delay, " calc duration is: " + str(duration_in_seconds))
                        self.context_menu.entryconfig(2, state="normal")
                    else:
                        self.context_menu.entryconfig(2, state="disabled")

    def focus_out(self, event):
        #print("***lost Focus")
        a = 0
        #self.stop_all_players()
        

    def on_window_resize(self, event): # das funktioniert nicht rihtig. Die übergebenen Zahlen sind falsch und der Handler wird unglaublich oft aufgerufen
        width = event.width
        height = event.height
        #print("Window resized to width: " + str(width) + " height: " + str(height))

    def Press_indir(self, *args):
        if _debug:
            print('Dateimeister_support.Press_indir')
            for arg in args:
                # print ('    another arg:', arg)
                pass
            sys.stdout.flush()
        indir = fd.askdirectory() 
        print ("indir %s" % indir)
        #self.clear_textbox(combobox_indir)
        self.label_indir.config(text = indir)

    def Press_outdir(self, *args):
        if _debug:
            print('Dateimeister_support.Press_outdir')
            sys.stdout.flush()
        #outdir = fd.askopenindir() 
        outdir = fd.askdirectory() 
        print ("outdir %s" % outdir)
        #self.clear_textbox(combobox_outdir)
        self.label_outdir.config(text = outdir)

    def B_camera_press(self, *args):
        global oldcamera
        if _debug:
            print('Dateimeister_support.B_camera_press')
            for arg in args:
                #print ('    another arg:', arg)
                sys.stdout.flush()
        # get selected indices
        selected_indices = self.lb_camera.curselection()
        thiscamera = ",".join([self.lb_camera.get(i) for i in selected_indices]) # because we have a single choice listbox
        print ("Kamera ist " + thiscamera)
        self.clear_textbox(self.o_camera)
        self.insert_text(self.o_camera, thiscamera)
        self.button_be.config(state = DISABLED) # browse / edit will throw error if not preceded by generate after chosing camera
        self.button_call.config(state = NORMAL)
        if thiscamera != oldcamera:
            self.button_undo.config(state = DISABLED)    
            self.button_redo.config(state = DISABLED)
            self.clear_text(self.t_text1)
            self.canvas_gallery.delete("all")
            self.filemenu.entryconfig(1, state=DISABLED)
            self.button_exclude.config(state = DISABLED)
            self.button_include.config(state = DISABLED)
            self.button_exec.config(state = DISABLED)
            Globals.button_duplicates.config(state = DISABLED)
            self.label_num.config(text = "0")
            self.clear_textbox(self.lb_gen)
            oldcamera = thiscamera
            if Globals.imagetype in Globals.thumbnails:
                print("try to delete thumbnails...")
                Globals.thumbnails[Globals.imagetype].clear()
            if Globals.imagetype in _dict_thumbnails:
                print("try to delete dict_thumbnails...")
                _dict_thumbnails[Globals.imagetype] = {}

    def Press_generate(self, *args):
        global _dict_firstname_fullname, _dict_duplicates, _dict_duplicates_sourcefiles, \
            _outdir, dict_source_target, dict_relpath, dict_gen_files_delrelpath, dict_source_target_tooold, dict_outdirs, _dict_file_image
        global _processid_high, _processid_akt, _list_processids, _stack_processids
        if _debug:
            print('Dateimeister_support.B_camera_press')
            for arg in args:
                #print ('    another arg:', arg)
                pass
            sys.stdout.flush()
        
        # cleanup
        self.close_child_windows()
        # reset all process-states
        _processid_akt  = 0
        _processid_high = 0
        _list_processids = []
        _stack_processids = []
        self.button_undo.config(state = DISABLED)    
        self.button_redo.config(state = DISABLED)
        
        self.clear_text(self.t_text1)
        self.canvas_gallery.delete("all")

        # get indir, outdir, camera
        indir  = self.label_indir.cget('text')
        outdir = self.label_outdir.cget('text')
        thiscamera = self.o_camera.get();
        if not indir:
            messagebox.showerror("showerror", "kein Indir ausgewählt")
            self.b_button1.focus_set()
            return None
        if not outdir:
            messagebox.showerror("showerror", "kein outdir ausgewählt")
            self.b_button_outdir.focus_set()
            return None
        if not thiscamera:
            messagebox.showerror("showerror", "keine Kamera ausgewählt")
            self.b_button2.focus_set()
            return None
        if self.cb_recursive_var.get():
            recursive = "j"
        else:
            recursive = "n"
        if self.cb_prefix_var.get():
            self.use_camera_prefix = True
        else:
            self.use_camera_prefix = False
        if self.cb_addrelpath_var.get():
            addrelpath  = "j"
        else:
            addrelpath  = "n"
        print ("INDIR is  " + indir)
        
        # we try to open the templatefile. we do it here because one does not have to stop the program when file not found. 
        # Just correct it and run generate again
        self.get_templates() # read them into dict_templates (global)
        
        self.clear_text(self.t_text1)
        self.clear_textbox(self.lb_gen)

        _dict_duplicates = {}
        owndir = os.getcwd()
        self.dict_gen_files = {}
        self.dict_gen_files_delete = {}
        dict_source_target = {}
        dict_source_target_jpeg = {}
        dict_source_target_tooold = {}
        dict_relpath = {}
        dict_gen_files_delrelpath = {}
        _dict_firstname_fullname = {}
        dict_outdirs = {}

        # now make an entry for this indir / outdir. For indir we use the already existing function for config_files without type / config_file
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())

        this_i = re.sub(r'\\', '/', indir).lower()
        # delete indir-entries from xml if number gt than max from ini, oldest first
        self.new_dir_in_xml('indir', max_indirs, this_i, ts)

        this_o = re.sub(r'\\', '/', outdir).lower()
        # delete outdir-entries from xml if number gt than max from ini, oldest first
        self.new_dir_in_xml('outdir', max_outdirs, this_o, ts)

        for dateityp in self.dict_cameras[thiscamera]:
            # cleanup
            # in Python kann man offenbar nicht automatisch einen Eintrag anlegen, indem man ein Element an die Liste hängt
            if dateityp in Globals.thumbnails:
                Globals.thumbnails[dateityp].clear() # damit werden implizit jetzt alle Bilder gelöscht
            else:
                Globals.thumbnails[dateityp] = []

            subdir = self.dict_subdirs[dateityp]
            thisoutdir = outdir + "/" + subdir
            _outdir = thisoutdir # for setting title of duplicate-window
            dict_outdirs[dateityp] = thisoutdir
            endung= self.dict_cameras[thiscamera][dateityp]
            if self.use_camera_prefix:
                target_prefix = thiscamera + '_'
            else:
                target_prefix = ''
            dict_source_target[dateityp] = {}
            dict_relpath[dateityp] = {}
            dict_source_target[dateityp], dict_source_target_jpeg[dateityp], dict_source_target_tooold[dateityp] = \
              DG.dateimeister(dateityp, endung, indir, thisoutdir, addrelpath, recursive, self.cb_newer_var.get(), target_prefix, dict_relpath[dateityp])
            dict_relpath[dateityp] = dict(reversed(list(dict_relpath[dateityp].items())))
            for ii in dict_relpath[dateityp]:
                print(" > ", ii, " files: ", dict_relpath[dateityp][ii])
            num_files = 0
            for thisfile in dict_source_target[dateityp]:
                #print("IN: " + thisfile + " OUT: " + dict_source_target[dateityp][thisfile])
                num_files += 1
            print(dateityp + " F NUM: " + str(num_files))
            # save name for cmdfile
            cmd_file_name = "_copy_" + dateityp + '.cmd'
            cmd_file_full = os.path.join(datadir, Globals.cmd_files_subdir, cmd_file_name)
            # generierte Dateien in dict festhalten
            self.dict_gen_files[dateityp] = cmd_file_full
            #print("self.dict_gen_files[dateityp]: ", str(self.dict_gen_files[dateityp]), " datadir is: ", datadir)

            # save name for delete files
            # important: subdir MUST NOT start with a slash!
            cmd_file_name_delete = "_delete_" + dateityp + '.cmd'
            cmd_file_full_delete = os.path.join(datadir, Globals.cmd_files_subdir, cmd_file_name_delete)
            # generierte Dateien in dict festhalten
            self.dict_gen_files_delete[dateityp] = cmd_file_full_delete
            #print("dict_gen_files_delete[dateityp]: ", str(self.dict_gen_files_delete[dateityp]))

            # save name for delrelpath files
            cmd_file_name_delrelpath = "_delrelpath_" + dateityp + '.cmd'
            cmd_file_full_delrelpath = os.path.join(datadir, Globals.cmd_files_subdir, cmd_file_name_delrelpath)
            # generierte Dateien in dict festhalten
            dict_gen_files_delrelpath[dateityp] = cmd_file_full_delrelpath
            #print("dict_gen_files_delrelpath[dateityp]: ", str(dict_gen_files_delrelpath[dateityp]))

            _dict_duplicates[dateityp] = {}
            print ("OUTDIR is " + thisoutdir + " ENDUNG is " + endung)
            #print ("OUTFILE is " + os.environ["OUTFILE"])
            # wenn die Endung wegen mehrerer Möglichkeiten (jpeg, jpg) mehr al 1 Eintrag hat, nehmen wir den letzten
            #print("'(.*?)\.({:s})' 'PIC_{:s}_$1.$2'".format(dateityp, thiscamera))
            self.clear_text(self.t_text1)
            # wir tragen die Dubletten ein       
            lineno = 0
            for this_sourcefile in dict_source_target[dateityp]:
                lineno += 1
                #print(line)
                dupl_target_file = dict_source_target[dateityp][this_sourcefile].upper() #for duplicate target  check ignore case
                if dupl_target_file not in _dict_duplicates[dateityp]:
                    _dict_duplicates[dateityp][dupl_target_file] = []
                _dict_duplicates[dateityp][dupl_target_file].append(this_sourcefile) # Duplicates  
            # remove singles from  _dict_duplicates, we use a copy because we must not delete entries during iteration
            # create _dict_duplicates_sourcefiles , key = sourcefile, value = targetfile
            _dict_duplicates_sourcefiles[dateityp] = {}
            dict_h = {}
            dict_h = copy.deepcopy(_dict_duplicates[dateityp])
            for mytarget in dict_h:
                #print("Duplcate Key: " + mytarget) 
                mylist = dict_h[mytarget]
                if len(mylist) == 1: # only 1 file
                    del _dict_duplicates[dateityp][mytarget]
                    #print("nodupl: ", str(mylist))
                else:
                    for mysource in mylist:
                        _dict_duplicates_sourcefiles[mysource] = mytarget
            #print("_dict_duplicates: " + str(_dict_duplicates[dateityp])) 

            # alle Dateien aus der gerade verarbeiteten cmd-Datei tragen wir in _dict_firstname_fullname ein, wenn type = JPEG
        regpattern = r'[\/\\]([^\/\\.]+)\.([^\/\\.]+)' # zwischen dem letzten / bzw. \ und dem letzten Punkt steht der Vorname, Nachname danach
        regpattern_source = r'"([^"]+)"' # Sourcefile
        target_file = ""
        source_file = ""
        #print("JPEGs: " + str(dict_source_target_jpeg["JPEG"]))
        for this_sourcefile in dict_source_target_jpeg["JPEG"]:
            lineno += 1
            b_match = False
            match = re.search(regpattern, this_sourcefile)
            if match:
                firstname = match.group(1)
                lastname  = match.group(2).upper()
                #print("GENERATE: firstname / lastname = " + firstname + " / " + lastname)
                b_match = True
            else: 
                #print("GENERATE unable to find firstname, lastname in: " + line)
                a = 1
            if (b_match == True):
                # Show error if no process_type available
                if lastname.upper() not in self.dict_process_image:
                    messagebox.showerror("GENERATE", "Section process_type, no entry in ini-file found for: " + lastname)
                    print("dict_process_image is: " + str(self.dict_process_image))
                    exit()
                process_type = self.dict_process_image[lastname].upper()
                if (process_type == "JPEG"):
                    if firstname.upper() not in _dict_firstname_fullname:
                        _dict_firstname_fullname[firstname.upper()] = []
                    _dict_firstname_fullname[firstname.upper()].append(this_sourcefile) # es kann ja in den ganzen Verzeichnissen mehrere jpegs mit demselben Vornamen geben  

        self.l_label1.config(text = "Output from Dateimeister")
                
        # die generierten Dateien in die Listbox eintragen
        for key in self.dict_gen_files:
            self.lb_gen.insert(END, key)
        self.lb_gen.select_set(0)
        if self.lb_gen.size() > 0:
            self.button_be.config(state = NORMAL)
        self.filemenu.entryconfig(1, state=DISABLED)
        self.button_exclude.config(state = DISABLED)
        self.button_include.config(state = DISABLED)
        self.button_exec.config(state = DISABLED)
        Globals.button_duplicates.config(state = DISABLED)
        self.label_num.config(text = "0")
        os.chdir(owndir)
        self.write_cmdfiles()
    
    def Button_be_pressed(self, *args):
        global _canvas_gallery_width_visible
        global _canvas_gallery_width_images
        global _canvas_gallery_width_all
        global _lastposition, _dict_file_image
        global _dict_duplicates, _duplicates, _dict_duplicates_sourcefiles, dict_source_target, _win_messages
        global _processid_high, _processid_akt, _list_processids, _stack_processids

        if _debug:
            print('Dateimeister_support.Press_be_out')
            for arg in args:
                #print ('    another arg:', arg)
                pass
            sys.stdout.flush()

        # reset all process-states
        _processid_akt  = 0
        _processid_high = 0
        _list_processids = []
        _stack_processids = []
        self.button_undo.config(state = DISABLED)    
        self.button_redo.config(state = DISABLED)
        self.config_file = ""   # after change of imagetype (possibly) has to be selected new by user
        self.root.title(self.title)
        
        self.clear_text(self.t_text1)
        self.canvas_gallery.delete("all")

        if not self.lb_gen.curselection() == ():
            selected_indices = self.lb_gen.curselection()
        else:
            messagebox.showerror("showerror", "no Imagetype selected")
            self.lb_gen.focus_set()
            return None
        thistype = ",".join([self.lb_gen.get(i) for i in selected_indices]) # weil wir single für die Listbox gewählt haben
        #print("self.dict_gen_files: ", str(self.dict_gen_files))
        filename = self.dict_gen_files[thistype]
        imagetype = thistype
        Globals.imagetype = imagetype # auch in globaler Variable festhalten, da wir das an vielen Stellen brauchen
        subdir = self.dict_subdirs[imagetype]
        self.stop_all_players() # should not continue running 
        # in Python kann man offenbar nicht automatisch einen Eintrag anlegen, indem man ein Element an die Liste hängt
        if imagetype in Globals.thumbnails:
            Globals.thumbnails[imagetype].clear() # damit werden implizit jetzt alle Bilder gelöscht
        else:
            Globals.thumbnails[imagetype] = []
        
        # cleanup
        self.close_child_windows()
        
        self.l_label1.config(text = "Output from Dateimeister : " + filename)
        self.dict_image_lineno[imagetype] = {} # in Python muss das sein, sonst gehts in der nächsten Ebene nicht
        lineno = 0
        #print(str(dict_source_target))
        for this_sourcefile in dict_source_target[imagetype]:
            this_targetfile = dict_source_target[imagetype][this_sourcefile]
            lineno += 1
            source_without_dir = re.sub(re.escape(self.label_indir.cget('text')), '', this_sourcefile)
            source_without_dir = re.sub(r'^[\\\/]', '', source_without_dir)
            target_without_dir = re.sub(re.escape(self.label_outdir.cget('text')), '', this_targetfile)
            target_without_dir = re.sub(r'[\\\/]', '/', target_without_dir) # replace all backslashes by slash
            my_subdir = subdir
            my_subdir = re.sub(r'[\\\/]', '/', my_subdir) # replace all backslashes by slash
            target_without_dir = re.sub(re.escape(my_subdir), '', target_without_dir) # replace subdir
            target_without_dir = re.sub(r'^[\\\/]+', '', target_without_dir) # replace first slash
            text_w = 80
            #thisline = "{source:<{len1}s}{target:<{len1}s}\n".format(len1 = text_w, source = source_without_dir, target = target_without_dir)
            thisline = "{source:<{len1}s}{target:<{len1}s}\n".format(len1 = text_w, source = this_sourcefile, target = this_targetfile)
            self.insert_text(self.t_text1, thisline)
            self.dict_image_lineno[imagetype][this_sourcefile] = lineno
        
        # wir suchen in der cmd-Datei die Endung für jedes Imagefile. Damit suchen wir in dict_process_image nach einem Eintrag
        # wenn JPEG, dann verarbeiten wir die Zeile und verwenden das mutmaßliche JPEG_Bild in der Gallerie. Wenn use_jpeg gefunden wird
        # suchen wir nach einem passenden JPEG. Falls die Endung im dict nicht gefunden wird, verwenden wir ebenfalls use_jpeg. Später
        # können hier passende RAW-DLLs aufgerufen werden, z.b. mit Name der DLL in der Ini-Datei
        canvas_height = self.canvas_gallery.winfo_height()
        canvas_width  = self.canvas_gallery.winfo_width()
        _canvas_gallery_width_visible = self.canvas_gallery.winfo_width() # Fensterbreite
        _lastposition = 0
        _dict_thumbnails[imagetype] = {}
        _dict_thumbnails_lineno[imagetype] = {}
        self.num_images = 0
        for file in dict_source_target[imagetype]:
            self.num_images += 1
            this_targetfile = dict_source_target[imagetype][file]
            # wir brauchen die Endung der Datei und den Vornamen
            regpattern = r'[\/\\]([^\/\\."]+)\.([^\/\\."]+)' # zwischen dem letzten / bzw. \ und dem letzten Punkt steht der Vorname, Nachname danach
            match = re.search(regpattern, file)
            if match:
                firstname  = match.group(1)
                lastname   = match.group(2).upper()
                #print("firstname / lastname = " + firstname + " / " + lastname)
            else: 
                print("unable to find firstname, lastname for: " + file)
            # wir brauchen die Methode aus der ini-Datei, mit der wir das Bild verarbeiten sollen
            process_type = self.dict_process_image[lastname].upper()
            #print("Process Type is: " + process_type)
            player = None # only for video
            if (process_type == "JPEG"):
                showfile = file # Image-file to show in Canvas
            elif process_type == "USE_JPEG":
                if firstname.upper() in _dict_firstname_fullname:
                    showfile = _dict_firstname_fullname[firstname.upper()][-1]
                    #print ("*** JPEG found for " + file + " using " + showfile)
                else:
                    showfile = "none"
                    print ("*** No JPEG found for " + file + " using " + showfile)
                    process_type = "none" # rectangle instead
            elif process_type == 'VIDEO':
                print("try to create new videoplayer...")
                # create new videoplayer
                player   = DV.VideoPlayer(self.root, file, self.canvas_gallery, canvas_width, canvas_height, _lastposition)
                image_width, image_height, pimg = player.get_pimg()
                showfile = file
            else: # hier später mal ein Aufruf, um RAW oder was auch immer nach JPEG zu konvrtieren, aber jetzt erstmal Default nciht gefunden anzeigen
                showfile = "none"
            if file in _dict_duplicates_sourcefiles: # for storing in Thumbnail
                duplicate = 'j'
            else:
                duplicate = 'n'
            #print ("Process-type, file" , process_type, ' ', file)
            this_lineno = self.dict_image_lineno[imagetype][file]
            # distance from border for text-boxes
            dist_text  = 10
            # distance from border for image-frame
            dist_frame = 20
            if  process_type != "none": 
                if process_type != 'VIDEO': # we have to convert image to photoimage
                    img  = Image.open(showfile)
                    image_width_orig, image_height_orig = img.size
                    faktor = canvas_height / image_height_orig
                    newsize = (int(image_width_orig * faktor), int(image_height_orig * faktor))
                    r_img = img.resize(newsize, Image.Resampling.NEAREST)
                    image_width, image_height = r_img.size
                    #print("try to print " + file + " width is " + str(image_width) + "(" + str(image_width_orig) + ")" + " height is " + str(image_height) + "(" + str(image_height_orig) + ")" \
                    #   + " factor is " + str(faktor))
                    pimg = ImageTk.PhotoImage(r_img)
                # an den Thumbnails führen wir einige Attribute, außerdem sorgt die Liste dafür, dass der Garbage-Kollektor das Bild nicht löscht.
                # indem wir es in eine Liste einfügen, bleibt der Referenz-Count > 0
                id = self.canvas_gallery.create_image(_lastposition, 0, anchor='nw',image = pimg, tags = 'images')
                text_id = self.canvas_gallery.create_text(_lastposition + dist_text, dist_text, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
                rect_id = self.canvas_gallery.create_rectangle(self.canvas_gallery.bbox(text_id), outline="blue", fill = "white", tag = 'rect')
                text_id_num = self.canvas_gallery.create_text(_lastposition + dist_text, image_height - dist_text, text=str(self.num_images), fill="red", font=('Helvetica 10 bold'), anchor =  "sw", tag = "numbers")
                rect_id_num = self.canvas_gallery.create_rectangle(self.canvas_gallery.bbox(text_id_num), outline="blue", fill = "white", tag = "rect_numbers")
                # the frame for selected image, consisting of 4 lines because there is no opaque rectangle in tkinter
                north_west = (_lastposition + dist_frame, dist_frame)
                north_east = (_lastposition + image_width - dist_frame, dist_frame)
                south_west = (_lastposition + dist_frame, image_height - dist_frame)
                south_east = (_lastposition + image_width - dist_frame, image_height - dist_frame)
                line_north = self.canvas_gallery.create_line(north_west, north_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_east  = self.canvas_gallery.create_line(north_east, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_south = self.canvas_gallery.create_line(south_west, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_west  = self.canvas_gallery.create_line(north_west, south_west, dash=(1, 1), fill = "red", tags="imageframe")
                frameids = (line_north, line_east, line_south, line_west)
                
                if player is not None:
                    player.setId(id)
                myimage = MyThumbnail(pimg, self, _lastposition, _lastposition + image_width, file, showfile, id, \
                    text_id, rect_id, frameids, this_lineno, player, duplicate, self.canvas_gallery, dict_source_target[imagetype][file], self.t_text1)
                if file in dict_source_target_tooold[imagetype]: #start with state.exclude
                    myimage.setState(state.EXCLUDE, None, False)
                    myimage.set_tooold(True)
                    self.canvas_gallery.itemconfig(text_id, text="EXC OVW")
                Globals.thumbnails[imagetype].append(myimage)
                _dict_thumbnails[imagetype][file] = myimage # damit können wir auf thumbnails mit den Sourcefilenamen zugreifen, z.B. für Duplicates
                _dict_thumbnails_lineno[imagetype][str(this_lineno)] = myimage # damit können wir auf thumbnails mit der lineno in text widget zugreifen
                _lastposition += image_width + Globals.gap 
                if myimage.getDuplicate() == 'j':
                    text_id_dup = self.canvas_gallery.create_text(_lastposition - Globals.gap - dist_text, dist_text, text="DUP", fill="green", font=('Helvetica 10 bold'), anchor =  tk.NE, tag = "dup_text")
                    rect_id_dup = self.canvas_gallery.create_rectangle(self.canvas_gallery.bbox(text_id_dup), outline="blue", fill = "white", tag = 'dup_rect')
                #print ("*** File " + file + " Type " + imagetype + " Lineno: " + str(self.dict_image_lineno[imagetype][file]))
                if process_type != 'VIDEO':
                    img.close()
            else: # wir haben kein Bild, ein Rechteck einfügen
                image_height = canvas_height
                image_width  = int(canvas_height * 4 / 3)
                id = self.canvas_gallery.create_rectangle(_lastposition, 0, _lastposition + image_width, canvas_height, fill="blue", tags = 'images')
                text_id = self.canvas_gallery.create_text(_lastposition + dist_text, dist_text, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
                rect_id = self.canvas_gallery.create_rectangle(self.canvas_gallery.bbox(text_id), outline="blue", fill = "white")
                text_id_num = self.canvas_gallery.create_text(_lastposition + dist_text, image_height - dist_text, text=str(self.num_images), fill="red", font=('Helvetica 10 bold'), anchor =  "sw", tag = "numbers")
                rect_id_num = self.canvas_gallery.create_rectangle(self.canvas_gallery.bbox(text_id_num), outline="blue", fill = "white", tag = "rect_numbers")
                # the frame for selected image, consisting of 4 lines because there is no opaque rectangle in tkinter
                north_west = (_lastposition + dist_frame, dist_frame)
                north_east = (_lastposition + image_width - dist_frame, dist_frame)
                south_west = (_lastposition + dist_frame, image_height - dist_frame)
                south_east = (_lastposition + image_width - dist_frame, image_height - dist_frame)
                line_north = self.canvas_gallery.create_line(north_west, north_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_east  = self.canvas_gallery.create_line(north_east, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_south = self.canvas_gallery.create_line(south_west, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_west  = self.canvas_gallery.create_line(north_west, south_west, dash=(1, 1), fill = "red", tags="imageframe")
                frameids = (line_north, line_east, line_south, line_west)
                myimage = MyThumbnail(0, self, _lastposition, _lastposition + image_width, file, showfile, id, \
                    text_id, rect_id, frameids, this_lineno, player, duplicate, self.canvas_gallery, dict_source_target[imagetype][file], self.t_text1)
                if file in dict_source_target_tooold[imagetype]: #start with state.exclude
                    myimage.setState(state.EXCLUDE, None, False)
                    myimage.set_tooold(True)
                    self.canvas_gallery.itemconfig(text_id, text="EXC OVW")
                Globals.thumbnails[imagetype].append(myimage)
                _dict_thumbnails[imagetype][file] = myimage
                _dict_thumbnails_lineno[imagetype][str(this_lineno)] = myimage # damit können wir auf thumbnails mit der lineno in text widget zugreifen
                _lastposition += image_width + Globals.gap 
                if myimage.getDuplicate() == 'j':
                    text_id_dup = self.canvas_gallery.create_text(_lastposition - Globals.gap - dist_text, dist_text, text="DUP", fill="green", font=('Helvetica 10 bold'), anchor =  tk.NE, tag = "dup_text")
                    rect_id_dup =self.canvas_gallery.create_rectangle(self.canvas_gallery.bbox(text_id_dup), outline="blue", fill = "white", tag = 'dup_rect')
                #print ("*** File " + file + " Type " + imagetype + " Lineno: " + str(self.dict_image_lineno[imagetype][file]))
        self.canvas_gallery.tag_raise("dup_rect")
        self.canvas_gallery.tag_raise("dup_text")
        self.canvas_gallery.tag_raise("rect")
        self.canvas_gallery.tag_raise("text")
        self.canvas_gallery.tag_raise("line")
        self.canvas_gallery.tag_raise("rect_numbers")
        self.canvas_gallery.tag_raise("numbers")
        #self.canvas_gallery.tag_raise("imageframe")
        # the frame for selected image
        # Globals.gap haben wir einmal zuviel (fürs letzte) gezählt
        _lastposition -= Globals.gap
        #print ("Canvas_gallery sichtbare Breite : " + str(_canvas_gallery_width_visible))
        # damit wir am Ende auch bis zum letzten einzelnen Bild scrollen können, fügen wir ein Rechteck ein
        if len(Globals.thumbnails[imagetype]) > 0: 
            thumbnail = Globals.thumbnails[imagetype][-1]
            rect_len = _canvas_gallery_width_visible - (thumbnail.getEnd() - thumbnail.getStart() + Globals.gap)
            self.canvas_gallery.create_rectangle(_lastposition, 0, _lastposition + rect_len, canvas_height, fill="yellow")
            self.canvas_gallery.config(scrollregion = self.canvas_gallery.bbox('all')) 
            _canvas_gallery_width_images = self.canvas_gallery.bbox('images')[2]
            _canvas_gallery_width_all    = self.canvas_gallery.bbox('all')[2]
            #print ("Canvas_gallery totale Breite(Images): " + str(_canvas_gallery_width_images) + " totale Breite(All): " + str(_canvas_gallery_width_all) \
            #    + " visible: " + str(_canvas_gallery_width_visible) + " lastposition: " + str(_lastposition))
        
        # Pfeiltasten für Scrollen einrichten
        self.canvas_gallery.focus_set()
        self.button_include.config(state = NORMAL)
        self.button_exclude.config(state = NORMAL)
        #print(_dict_duplicates)
        self.historize_process()
        if len(Globals.thumbnails[imagetype]) > 0:
            self.filemenu.entryconfig(1, state=NORMAL)
            self.filemenu.entryconfig(3, state=NORMAL)
        
        else: # if no images available we dont need config files
            self.filemenu.entryconfig(1, state=DISABLED)
            self.filemenu.entryconfig(2, state=DISABLED)
            self.filemenu.entryconfig(3, state=DISABLED)
            self.filemenu.entryconfig(4, state=DISABLED)
        _duplicates = False
        
        for mytarget in _dict_duplicates[imagetype]:
            #print("Duplcate Key: " + mytarget) 
            mylist = _dict_duplicates[imagetype][mytarget]
            if len(mylist) > 1: # es gibt 1...n Duplicates
                _duplicates = True
                break
        
        if self.num_images > 0: # config makes no sense for zero images
            self.filemenu.entryconfig(5, state=NORMAL)
            # get the config-files for indir / type:
            indir = self.label_indir.cget('text')
                
            # finally update recent menu
            self.update_recent_menu(indir, imagetype)
        
        if _duplicates:
            Globals.button_duplicates.config(state = NORMAL)
        else:
            Globals.button_duplicates.config(state = DISABLED)
        
        self.label_num.config(text = str(self.num_images))
        self.button_exec.config(state = NORMAL)
        self.write_cmdfile(imagetype)
        if _win_messages is not None: # stop MyMessagesWindow-Objekt
            _win_messages.close_handler()
            _win_messages = None
        self.canvas_gallery.xview('moveto', 0)

    def state_gen_required(self):
        self.button_be.config(state = DISABLED) # browse / edit will throw error if not generate after chosing camera
        self.button_undo.config(state = DISABLED)    
        self.button_redo.config(state = DISABLED)
        self.clear_text(self.t_text1)
        self.canvas_gallery.delete("all")
        self.filemenu.entryconfig(1, state=DISABLED)
        self.button_exclude.config(state = DISABLED)
        self.button_include.config(state = DISABLED)
        self.button_exec.config(state = DISABLED)
        Globals.button_duplicates.config(state = DISABLED)
        #button_call.config(state = DISABLED)
        self.label_num.config(text = "0")
        self.clear_textbox(self.lb_gen)
        if Globals.imagetype in Globals.thumbnails:
            print("try to delete thumbnails...")
            Globals.thumbnails[Globals.imagetype].clear()
        if Globals.imagetype in _dict_thumbnails:
            print("try to delete dict_thumbnails...")
            _dict_thumbnails[Globals.imagetype] = {}

    def new_dir_in_xml(self, dirtype, max_dirs, dir_chosen, ts):
        do_del = True
        if dirtype == 'indir':
            d = DX.get_indirs(Globals.config_files_xml)
            if dir_chosen in d:
                do_del = False # existing dir, no cleanup
        elif dirtype == 'outdir':
            d = DX.get_outdirs(Globals.config_files_xml)
            if dir_chosen in d:
                do_del = False # existing dir, no cleanup
        # delete dir-entrie(s) from Globals.config_files_xml only if a new one has been selected
        print("do_del: " + str(do_del) + " dir_chosen: " + dir_chosen)
        if do_del: # 2 pass: in the first we delete entries with not existing dir, in the second existing dirs (if necessary)
            for loop in range(1,3): # 3 is excluded
                if dirtype == 'indir':
                    d = DX.get_indirs(Globals.config_files_xml)
                elif dirtype == 'outdir':
                    d = DX.get_outdirs(Globals.config_files_xml)
                # sort descending by usedate
                dict_dir_usedate = {}
                for ii in d:
                    dict_dir_usedate[ii] = d[ii]['usedate'] # dir -> usedate
                sorted_d = dict( sorted(dict_dir_usedate.items(), key=operator.itemgetter(1), reverse=True))
                list_dirs = []
                for tdir in sorted_d:
                    list_dirs.append(tdir)
                num_to_delete = len(list_dirs) - int(max_dirs) + 1 # +1 for we will make a new dir later. already deleted dirs are no more in DX.get_dirs 
                if loop == 1:
                    # delete only not existing dirs
                    if num_to_delete > 0:
                        ii = 0
                        for t in reversed(list_dirs): # now the oldest are on top
                            if not os.path.isdir(t):
                                if ii < num_to_delete:
                                    if dirtype == 'indir':
                                        DX.delete_indir(Globals.config_files_xml, t)
                                    elif dirtype == 'outdir':
                                        DX.delete_outdir(Globals.config_files_xml, t)
                                    ii += 1
                                else:
                                    break
                elif loop == 2:
                    # delete existing dirs if necessary
                    if num_to_delete > 0:
                        ii = 0
                        for t in reversed(list_dirs): # now the oldest are on top
                            if ii < num_to_delete:
                                if dirtype == 'indir':
                                    DX.delete_indir(Globals.config_files_xml, t)
                                elif dirtype == 'outdir':
                                    DX.delete_outdir(Globals.config_files_xml, t)
                                ii += 1
                            else:
                                break
        # will add xml node if not existing or update usedate if existing
        if dirtype == 'indir':
            DX.new_indir (Globals.config_files_xml, dir_chosen, "", "", ts, 0)
        if dirtype == 'outdir':
            DX.new_outdir(Globals.config_files_xml, dir_chosen, ts)

    def close_child_windows(self): #closes duplicates, fs-images and exec-windows    
        global _dict_file_image, _win_messages
        # cleanup
        self.stop_all_players() # should not continue running 
        if self.win_duplicates is not None: # stop MyDuplicates-Objekt
            self.win_duplicates.close_handler()
            self.win_duplicates = None
        # delete all fsimage by close-call
        for t in _dict_file_image:
            u = _dict_file_image[t]
            u.close_handler_external()
        _dict_file_image = {}
        if _win_messages is not None: # stop MyMessagesWindow-Objekt
            _win_messages.close_handler()
            _win_messages = None

    def get_templates(self):
        global dict_templates
        dict_templates = {}
        try:
            file = open(templatefile)
        except FileNotFoundError:
            print("File does not exist: " + templatefile)
        templates = file.read().replace('\n', '<<<NL>>>')
        #print(templates)
        regpattern = r'\[([^\]]+)\](.*?)\[/\1\]'
        list_t = re.findall(regpattern, templates)
        for ii in list_t:
            templatename = ii[0].upper()
            template     = ii[1]
            #print("templatename: " + templatename)
            #print(template)
            dict_templates[templatename] = template
        
        templates = re.sub(r'<<<NL>>>', '\n', templates)
        #print(templates)
            
    def button_exec_pressed(self):
        global _win_messages
        if _win_messages is not None: # stop MyMessagesWindow-Objekt
            _win_messages.close_handler()
            _win_messages = None
        _win_messages = MyMessagesWindow(self, Globals.imagetype, self.dict_gen_files[Globals.imagetype], self.dict_gen_files_delete[Globals.imagetype], dict_gen_files_delrelpath[Globals.imagetype]) 

    def write_cmdfiles(self):
        for imagetype in dict_source_target:
            self.write_cmdfile(imagetype)

    def canvas_gallery_show(self, event):
        #print('bbox', self.canvas_gallery.bbox('images'))
        self.canvas_gallery.focus_set()

        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            item_id = thumbnail.getId()
            self.display_image(thumbnail)
            print("Text sroll to lineno: ", str(thumbnail.getLineno()))
            thumbnail.scrollTextToLineno()

    def canvas_image_show(self):
        print("Context menu show")
        self.canvas_gallery_show(_event)

    def delay_decr(self, event): # speed +
        self.canvas_gallery.focus_set()
        delta = -5
        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                if delay + delta > 5:
                    player.setDelay(delay + delta)

    def delay_incr(self, event): # speed -
        self.canvas_gallery.focus_set()
        delta = 5
        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                if delay + delta < 200:
                    player.setDelay(delay + delta)

    def delay_deflt(self, event): # speed normal
        self.canvas_gallery.focus_set()
        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                player.setDelay(Globals.delay_default)

    def xview(self, *args):
        #print (*args)
        global _canvas_gallery_width_visible
        global _canvas_gallery_width_images
        global _canvas_gallery_width_all
        s1 = 0.0
        s2 = 1.0
        scrolldelta = 0
        width_scrollbar = self.scroll_canvas_x.winfo_width()
        canvas_x = int(self.canvas_gallery.canvasx(0))
        canvas_y = int(self.canvas_gallery.canvasy(0))
        #print ("Scroll totale Breite(Images): " + str(_canvas_gallery_width_images) + " totale Breite(All): " + str(_canvas_gallery_width_all) \
        #    + " visible: " + str(_canvas_gallery_width_visible)  + " canvas_x: " + str(canvas_x))
        slider_width = int((_canvas_gallery_width_visible / _canvas_gallery_width_all) * width_scrollbar)
        # aktuelle Scroll-Position des Canvas
        # aktuelle position der Scrollbar
        scrollposition = self.scroll_canvas_x.get()[0]
        
        # wenn wir die Pfeiltasten betätigen, wollen wir auf den Anfang des nächsten (vorherigen) Bildes scrollen.
        # wenn das aktuelle Bild nur teilweise zusehen ist, scrollen wir bei Linkstaste auf den Bildbeginn
        if len(args) == 3 and args[2] == "units":
            # den scrollbetrag auf die Größe des Bildes am linken Rand setzen
            thumbnail, index = self.get_thumbnail_by_position(canvas_x + 11, canvas_y)
            if thumbnail is not None:
                if int(args[1]) > 0:
                    scrolldelta = (thumbnail.getEnd() - canvas_x + Globals.gap)
                else:
                    if canvas_x - thumbnail.getStart() > 10: # Bild links abgeschnitten, an den Anfang scrollen
                        scrolldelta = (thumbnail.getStart() - canvas_x) # ist dann negativ, was wir ja wollen
                        #print("Bild links abgeschnitten, weil canvas_x = " + str(canvas_x) + " und Bildstart = " + str(thumbnail.getStart()))
                    else: #Bild ist vollständig zu sehen, also zurück zum nächsten
                        if index > 0: # es gibt einen Vorgänger
                            scrolldelta = (Globals.thumbnails[Globals.imagetype][index - 1].getStart()) - canvas_x
                            #print("Vorgänger ist: " + Globals.thumbnails[Globals.imagetype][index - 1].getFile() + " Start: " + str(Globals.thumbnails[Globals.imagetype][index - 1].getStart())\
                            #    + " canvas_x is: " + str(canvas_x) + " scrolldelta is: " + str(scrolldelta))
                
                new_canvas_x = canvas_x + scrolldelta
                # nach links scrollen machr keinen Sinn, wenn wir schon ganz links stehen, analog rechts
                if (int(args[1]) < 0 and canvas_x <= 0) or (int(args[1]) > 0 and new_canvas_x >= _canvas_gallery_width_images):
                   return
                s2 = new_canvas_x / _canvas_gallery_width_all
                s1 = (new_canvas_x - slider_width) / _canvas_gallery_width_all
                #print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
            self.scroll_canvas_x.set(s1, s2)
            self.canvas_gallery.xview('moveto', s2)
        elif len(args) == 3 and args[2] == "page":
            #print("Args: ", str(args))
            # wenn wir eine Seite nach rechts scrollen sollen, soll das Bild, das jetzt ganz oder teilweise am rechten Bildrand zu sehen ist, am linken Bildrand erscheinen
            # wenn wir 1 Seite nach links scrollen sollen, soll der Vorgänger des Bildes vollständig am rechten Bildrand sichtbar sein. Wenn das dazu führt,
            # das das Bild am linken Bildrand abgeschnitten ist, scrollen wir auf dessen Anfang
            thumbnail_last = Globals.thumbnails[Globals.imagetype][-1]
            if int(args[1]) > 0: # scroll right
                # get thumbnail at left border
                posx = canvas_x
                dothumbnail = True
                while dothumbnail: #while because canvas_x could be on gap
                    thumbnail_current, index_current = self.get_thumbnail_by_position(posx, canvas_y)
                    if thumbnail_current is None:
                        posx += Globals.gap
                        #print("current retry...")
                    else: #found
                        dothumbnail = False
                # get thumbnail at right border
                posx = canvas_x + _canvas_gallery_width_visible # start
                dothumbnail = True
                while dothumbnail:
                    thumbnail, index = self.get_thumbnail_by_position(posx, canvas_y)
                    if thumbnail is not None:
                        # we have to check, if whole canvas is filled by a very wide image (panorama), in which case we scroll by width of canvas
                        if thumbnail == thumbnail_current:
                            scrolldelta = _canvas_gallery_width_visible
                        else:
                            tfile = thumbnail.getFile()
                            #print("Image at right: " + tfile + " last: " + thumbnail_last.getFile() + " last-end: " + str(thumbnail_last.getEnd()))
                            scrolldelta = min(thumbnail.getStart() - canvas_x, thumbnail_last.getStart() - canvas_x)
                            dothumbnail = False
                    else: # no thumbnail, we check if there are no more images at right
                        #print("scrolling right, end of last image: " + str(thumbnail_last.getFile()) + " " + str(thumbnail_last.getEnd()) + \
                        #  " End of canvas: " + str(canvas_x + _canvas_gallery_width_visible))
                        if canvas_x + _canvas_gallery_width_visible >= thumbnail_last.getEnd(): # no image at right position of canvas, do nothing
                            #print("*** reached the end of scrolling right, end of last image: " + str(thumbnail_last.getFile()) + " " + str(thumbnail_last.getEnd()) + " End of canvas: " + str(canvas_x + _canvas_gallery_width_visible))
                            dothumbnail = False
                            return
                        else: #could be gap, so look at position - gap
                            posx -= Globals.gap
                #print("Scroll right 1 page, scrolldelta: " + str(scrolldelta))
                        
            else: # scroll left
                posx = canvas_x
                dothumbnail = True
                while dothumbnail: #while because canvas_x could be on gap
                    thumbnail_current, index_current = self.get_thumbnail_by_position(posx, canvas_y)
                    if thumbnail_current is None:
                        posx += Globals.gap
                        #print("current retry...")
                    else: #found
                        dothumbnail = False
                targetposition = max(thumbnail_current.getEnd() - _canvas_gallery_width_visible, 0) # scroll to the target which is width_visible ahead of position of left
                posx = targetposition
                dothumbnail = True
                while dothumbnail: #while because targetposition could be on gap
                    thumbnail_target, index_target = self.get_thumbnail_by_position(posx, canvas_y)
                    if thumbnail_target is None:
                        posx += Globals.gap
                        #print("target retry...")
                    else: #found
                        dothumbnail = False
                tfile = thumbnail_target.getFile()
                cfile = thumbnail_current.getFile()
                #print("Target for scroll left: " + tfile + " position: " + str(targetposition) + " current at left border: " + cfile + " start: " + str(thumbnail_current.getStart()))
                # we have to check, if whole canvas is filled by a very wide image (panorama), in which case we scroll by width of canvas
                if thumbnail_target == thumbnail_current:
                    scrolldelta = -_canvas_gallery_width_visible
                else:
                    # if leftmost visible would completely disappear by scroll left, target is nect thumbnail
                    a = targetposition - thumbnail_target.getStart() # actual scrollamount, we need the thumbnail acual at left side of cnvas
                    #b = canvas_x - thumbnail_current.getStart()
                    b = thumbnail_current.getEnd() - canvas_x # visible pixels
                    if b < a: # current would disappear by scrolling, so take the next image
                        if index_target + 1 < len(Globals.thumbnails[Globals.imagetype]):
                            thumbnail_target = Globals.thumbnails[Globals.imagetype][index_target + 1]
                            #print("*** thumbnail_current would disappear after scroll left")
                    scrolldelta = (thumbnail_target.getStart() - canvas_x)
                #print("Scroll left 1 page, scrolldelta: " + str(scrolldelta))

            new_canvas_x = canvas_x + scrolldelta
            # nach links scrollen machr keinen Sinn, wenn wir schon ganz links stehen, analog rechts
            if (int(args[1]) < 0 and canvas_x <= 0) or (int(args[1]) > 0 and new_canvas_x >= _canvas_gallery_width_images):
               return
            s2 = new_canvas_x / _canvas_gallery_width_all
            s1 = (new_canvas_x - slider_width) / _canvas_gallery_width_all
            #print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
            self.scroll_canvas_x.set(s1, s2)
            self.canvas_gallery.xview('moveto', s2)
        else:
            #if (1 == 0):
                #return
            self.canvas_gallery.xview(*args)

    def text1_single(self, event): # synchronize text / gallery
        (row, col) = self.t_text1.index(tk.CURRENT).split(".")
        print(row, col)
        if Globals.imagetype != "" and row in _dict_thumbnails_lineno[Globals.imagetype]:
            thumbnail = _dict_thumbnails_lineno[Globals.imagetype][row]
            self.scrollToImage(thumbnail)
            thumbnail.scrollTextToLineno() # select this line

        # we dont need the following code anymore because we have a method to scroll canvas to the lineno associated with thumbnail
        # but here we have a usefull code to get the text line after mouse click
        lstart = "%d.0" % int(row)
        lend   = "%d.0 lineend" % int(row)
        # tindex = "%d.0, %d.0 lineend" % (lineno, lineno + 1)
        line    = self.t_text1.get(lstart, lend)
        regpattern = r'[\/\\]([^\/\\.]+)\.([^\/\\.]+)' 
        #print(self.t_text1.index(f"@{event.x},{event.y}"), self.t_text1.index("current"), line)
        
    def text1_double(self, event): # synchronize text / gallery and display FSImage 
        (row, col) = self.t_text1.index(tk.CURRENT).split(".")
        print(row, col)
        if Globals.imagetype != "" and row in _dict_thumbnails_lineno[Globals.imagetype]:
            thumbnail = _dict_thumbnails_lineno[Globals.imagetype][row]
            if thumbnail is not None:
                self.scrollToImage(thumbnail)
                thumbnail.scrollTextToLineno() # select this line
                self.display_image(thumbnail)
        return("break")  # should stop event processing but doesn't  

    def text1_key(self, event): # called for every keyboard input
        (row, col) = self.t_text1.index(tk.INSERT).split(".")
        #print("Event x: ", event.x, " Event y: ",event.y)
        #print("Event is " + str(event))
        print("Key pressed: ")
        print(event.char, event.keysym, event.keycode)
        print(row, col)
        if event.keysym == 'Up' or event.keysym == 'Down':
            if Globals.imagetype != "" and row in _dict_thumbnails_lineno[Globals.imagetype]:
                thumbnail = _dict_thumbnails_lineno[Globals.imagetype][row]
                self.scrollToImage(thumbnail)
                thumbnail.scrollTextToLineno() # select this line
        self.t_text1.mark_set(tk.INSERT, "%d.%d" % (int(row), 0))


    def scrollToImage(self, thumbnail): # scroll to start-position of thumbnail identified by filename
        global _canvas_gallery_width_visible
        global _canvas_gallery_width_images
        global _canvas_gallery_width_all
        s1 = 0.0
        s2 = 1.0
        width_scrollbar = self.scroll_canvas_x.winfo_width()
        slider_width = int((_canvas_gallery_width_visible / _canvas_gallery_width_all) * width_scrollbar)
        # aktuelle Scroll-Position des Canvas
        canvas_x = self.canvas_gallery.canvasx(0)
        canvas_y = self.canvas_gallery.canvasy(0)
        # aktuelle position der Scrollbar
        scrollposition = self.scroll_canvas_x.get()[0]
        
        # den scrollbetrag auf die Größe des Bildes am linken Rand setzen
        if thumbnail is not None:
            scrolldelta = (thumbnail.getEnd() - canvas_x + Globals.gap)
            new_canvas_x = thumbnail.getStart()
            s2 = new_canvas_x / _canvas_gallery_width_all
            s1 = (new_canvas_x - slider_width) / _canvas_gallery_width_all
            #print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
        self.scroll_canvas_x.set(s1, s2)
        self.canvas_gallery.xview('moveto', s2)

    def display_image(self, thumbnail):
        global _dict_file_image
        file = thumbnail.getShowfile()
        # wenn das Bild schon in einem Fenster angezeigt wird, dann verwenden wir dieses
        if file in _dict_file_image:
            print ("FSImage exists for file: " + file)
            fs_image = _dict_file_image[file]
            player = fs_image.getPlayer()
            if player is not None: # this is a video
                print ("FSImage restart file: " + file)
                player.restart()
                fs_image.setPlaystatus('play') # Status, Buttontext
        else: # ein neues Objekt anlegen und in _dict_file_image eintragen
            if file != 'none':
                print ("FSImage does not exist for file: " + file)
                fs_image = MyFSImage(file, thumbnail, _dict_file_image, self)
                _dict_file_image[file] = fs_image

    def show_context_menu(self, event):
        global context_men, _event
        # das Event müssen wir speichern, da die eigenlichen Funktionen die x und y benötigen
        _event = event
        # falls wir keine anzeigbare Datei haben, müssen wir show-Item disablen
        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            if thumbnail.getImage() == 0:
                print(" No Image availabl for " + thumbnail.getFile())
                self.context_menu.entryconfig(1, state="disabled")
            else:
                self.context_menu.entryconfig(1, state="normal")
            if thumbnail.getState() == state.INCLUDE:
                self.context_menu.entryconfig(0, label = "Exclude " + thumbnail.getFile())
            else:
                self.context_menu.entryconfig(0, label = "Include " + thumbnail.getFile())
        self.context_menu.entryconfig(1, label = "Show " + thumbnail.getFile())
        self.context_menu.post(event.x_root, event.y_root)

    def canvas_button_1(self, event):  # we need an event to set focus to canvas in order for the arrow keys to work and we scroll text box
        self.canvas_gallery.focus_set()
        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            item_id = thumbnail.getId()
            print("Text sroll to lineno: ", str(thumbnail.getLineno()))
            thumbnail.scrollTextToLineno()

    def canvas_gallery_exclude(self, event):
        #print('bbox', self.canvas_gallery.bbox('images'))
        self.canvas_gallery.focus_set()

        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            linenew = ""
            #print("State is: " + str(thumbnail.getState()))
            if thumbnail.getState() == state.INCLUDE:
                thumbnail.setState(state.EXCLUDE)
            else: # toggle to not exclude, delete Item
                thumbnail.setState(state.INCLUDE)
        self.historize_process()
        
    def Button_exclude_all(self, *args):
        for thumbnail in Globals.thumbnails[Globals.imagetype]:
            if thumbnail.getState() == state.INCLUDE:
                thumbnail.setState(state.EXCLUDE, None, False)
        self.historize_process()
        self.write_cmdfile(Globals.imagetype)
                
    def Button_include_all(self, *args):
        for thumbnail in Globals.thumbnails[Globals.imagetype]:
            if thumbnail.getState() == state.EXCLUDE:
                thumbnail.setState(state.INCLUDE, None, False)
        self.historize_process()
        self.write_cmdfile(Globals.imagetype)
     
    def canvas_image_exclude(self): # used for exclude and include
        print("Context menu exlude")
        self.canvas_gallery_exclude(_event)

    def canvas_video_restart(self):
        print("Context menu restart")
        self.canvas_gallery.focus_set()

        canvas_x = self.canvas_gallery.canvasx(_event.x)
        canvas_y = self.canvas_gallery.canvasy(_event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # this is a video
                player.restart()
                
        
    # Undo /Redo Funktionen
    def process_undo(self, event):
        global _processid_akt, _processid_high, _processid_incr, _list_processids, _stack_processids
        print("ctrl_z pressed.")
        # if there is a predecessor in list_processids (len > 1):
        #   move processid_akt from list_processids to undo-stack, then apply new act (predecessor) giving the processids from act and undone
        num_elements = len(_list_processids)
        if num_elements <= 1:
            messagebox.showinfo("UNDO", "no further processes which can be undone")
        else:
            processid_undone = _list_processids[-1] # last element
            _stack_processids.append(processid_undone)
            _list_processids.pop() # removes last element
            _processid_akt = _list_processids[-1] # "new" last element
            print (" UNDO List Processids: " + str(_list_processids) + " REDO Stack Processids: " + str(_stack_processids))
            self.apply_process_id(_processid_akt)
            self.endis_buttons()

    def process_redo(self, event):
        global _processid_akt, _processid_high, _processid_incr, _list_processids, _stack_processids
        print("ctrl_y pressed.")
        # if there is an element in stack processids (len > 1):
        #   move last processid from stack processids to list_processids, then apply new act (moved from stack) giving the processids from act and predecessor of list_processids
        num_elements = len(_stack_processids)
        if num_elements < 1:
            messagebox.showinfo("REDO", "no further processes which can be redone")
        else:
            processid_predecessor = _list_processids[-1] # last element
            processid_redone = _stack_processids[-1] # last element
            _list_processids.append(processid_redone)
            _stack_processids.pop() # removes last element
            _processid_akt = _list_processids[-1] # "new" last element
            print (" REDO List Processids: " + str(_list_processids) + " REDO Stack Processids: " + str(_stack_processids))
            self.apply_process_id(_processid_akt)
            self.endis_buttons()

    def endis_buttons(self): # disable / enable buttons depending on processids
        global _processid_akt, _processid_high, _processid_incr, _list_processids, _stack_processids
        if len(_list_processids) > 1:
            self.button_undo.config(state = NORMAL)
        else:
            self.button_undo.config(state = DISABLED)
        if len(_stack_processids) > 0:
            self.button_redo.config(state = NORMAL)
        else:
            self.button_redo.config(state = DISABLED)

    def apply_process_id(self, process_id):
        # set thumbnail-states according actual processid
        global _processid_akt, _processid_high, _processid_incr
        i = 0
        for thumbnail in Globals.thumbnails[Globals.imagetype]:
            thumbnail.setState(self.dict_status_image[process_id][i], None, False)
            i += 1
        self.update_button_state()
        self.write_cmdfile(Globals.imagetype)
        
    def historize_process(self):
        global _processid_akt, _processid_high, _processid_incr, _list_processids, _stack_processids
        _processid_high += _processid_incr
        _processid_akt = _processid_high
        print ("Processid_high is now: " + str(_processid_high) + " Processid_akt is now: " + str(_processid_akt))
        # wir bilden jetzt zu der aktuellen processid eine Liste der states der thumbnails
        self.dict_status_image[_processid_akt] = []
        for thumbnail in Globals.thumbnails[Globals.imagetype]:
            self.dict_status_image[_processid_akt].append(thumbnail.getState())
        self.update_button_state() # refer to function comment
        
        _list_processids.append(_processid_akt)
        # UNDO / REDO disabeln, wenn Aktion nicht möglich, weil es keine frühere / spätere Bearbeitung gibt
        self.endis_buttons()

    def update_button_state(self): # enabled / disabled include / Exclude buttons

        #wir ermitteln, ob alle include oder exlude haben. In diesem Falls
        # disabeln wir exclude / Include All, was ja keinen Sinn hat und ggf.
        # die Historie unötig aufbläht
        count_states = 0
        count_exclude = 0
        count_include = 0
        for thumbnail in Globals.thumbnails[Globals.imagetype]:
            if thumbnail.getState() == state.EXCLUDE:
                count_exclude += 1
            if thumbnail.getState() == state.INCLUDE:
                count_include += 1
            count_states += 1
        if count_exclude == count_states:
            self.button_exclude.config(state = DISABLED)
        else:
            self.button_exclude.config(state = NORMAL)
        if count_include == count_states:
            self.button_include.config(state = DISABLED)
        else:
            self.button_include.config(state = NORMAL)

    def button_undo_pressed(self):
        self.process_undo((0, 0))
        
    def button_redo_pressed(self):
        self.process_redo((0, 0))
    # Ende undo / redo-Funktionen

    def button_duplicates(self):
        for mytarget in _dict_duplicates[Globals.imagetype]:
            #print("Duplcate Key: " + mytarget) 
            mylist = _dict_duplicates[Globals.imagetype][mytarget]
            if len(mylist) > 1: # es gibt 1...n Duplicates
                print("Duplcate Key: " + mytarget)
                for mysource in mylist:
                    print("   " + mysource)
        self.win_duplicates = MyDuplicates(self) 
       
    def menu_cameras_edit(self):
        global _win_camera
        _win_camera = MyCameraTreeview(self) 

    def menu_diatisch(self):
        global _win_diatisch
        _win_diatisch = DIAT.Diatisch() 

    def on_window_destroy(self, a):
        a = 1
        #print ("Destroy called.")
        #self.root.instance.destroy()
        #self.root.withdraw()

    def on_cb_num_toggle(self):
        if cb_num_var.get():
            self.canvas_gallery.itemconfigure("rect_numbers", state="normal")
            self.canvas_gallery.itemconfigure("numbers", state="normal")
        else:
            self.canvas_gallery.itemconfigure("rect_numbers", state="hidden")
            self.canvas_gallery.itemconfigure("numbers", state="hidden")


    def clear_textbox(self, o):
        o.delete(0, 'end')
        
    def clear_text(self, o):
        o.delete(1.0, 'end')

    def insert_text(self, o, str):
        o.insert('end', str)

    def get_thumbnail_by_position(self, canvas_x, canvas_y):
        index = -1
        found = False
        if Globals.imagetype != "":
            for thumbnail in Globals.thumbnails[Globals.imagetype]:
                start = thumbnail.getStart()
                end   = thumbnail.getEnd()
                if (canvas_x >= start and canvas_x <= end):
                    index = Globals.thumbnails[Globals.imagetype].index(thumbnail)
                    #print("retrieved " + thumbnail.getFile() + " Index: " + str(index))
                    found = True
                    break
            if not found:
                thumbnail = None
                index = None
        else:
            thumbnail = None
            index = None
        return (thumbnail, index)

    def get_camera_xml(self): # returns dict with all cameras, types and suffixes
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
        cameraname = "Retina Reflex"
        ctype      = "JPEG"
        suffix     = "JPG"
        rc = DX.new_camera_type_suffix(Globals.config_files_xml, cameraname, ctype, suffix, ts) 
        suffix     = "JPEG"
        rc = DX.new_camera_type_suffix(Globals.config_files_xml, cameraname, ctype, suffix, ts) 
        ctype      = "VIDEO"
        suffix     = "MOV"
        rc = DX.new_camera_type_suffix(Globals.config_files_xml, cameraname, ctype, suffix, ts) 
        # dateimeister_config_xml.py returns suffixes as list we need them as a comma separated string
        dict_cameras = {}
        dict_cameras = DX.get_cameras_types_suffixes(Globals.config_files_xml)
        #print("Cameras: " + str(dict_cameras))
        dict_t = {}
        for camera in dict_cameras:
            dict_t[camera] = {}
            type_num = 0
            for type in dict_cameras[camera]:
                type_num += 1
                suffixes = ", ".join(dict_cameras[camera][type])
                dict_t[camera][type] = suffixes
                print("Camera: " + camera + " Type: " + type + " Suffixes: " + suffixes)
                if len(suffixes) == 0:
                    messagebox.showerror("INIT", "Camera " + camera + " type " + type + " no suffix defined")
                    exit()
            if type_num == 0:
                messagebox.showerror("INIT", "Camera " + camera + " no type defined")
                exit()

        dict_s = {}
        dict_s = DX.get_subdirs(Globals.config_files_xml)
        for imagetype in dict_s:
            print("Subdir {:s}, {:s}".format(imagetype, dict_s[imagetype]))
        
        dict_pi = {}
        dict_pi = DX.get_process_image(Globals.config_files_xml)
        for t in dict_pi:
            print("Process Image  {:s}, {:s}".format(t, dict_pi[t]))
        
        self.lb_camera.delete(0, END)
        for key in dict_t:
            self.lb_camera.insert(END, key)
        self.lb_camera.selection_set(END)

        return dict_t, dict_s, dict_pi

    def stop_all_players(self):
        # stop all video players
        if Globals.imagetype is not None and Globals.imagetype != "":
            for imagetype in self.dict_subdirs:
                if imagetype in Globals.thumbnails:
                    for t in Globals.thumbnails[Globals.imagetype]: # stop all running players
                        thisplayer = t.getPlayer()
                        if thisplayer is not None:
                            if thisplayer.getRun(): # running
                                thisplayer.pstop()
                                #print ("Stop player for: " + t.getFile() + " playertype: " + imagetype)
     
    def write_cmdfile(self, imagetype):
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
        template_copy       = dict_templates["COPY"]
        template_delete     = dict_templates["DELETE"]
        template_delrelpath = dict_templates["DELRELPATH"]
        template_empty      = dict_templates["EMPTY"]
        header = Globals.uncomment + ' generated by dateimeister ' + ts + '\n'
        # copy files
        cmd_file_full = self.dict_gen_files[imagetype] # filename was already built by generate()
        thiscmdfile = open(cmd_file_full, 'w')
        thiscmdfile.write(header) 
        dict_files = dict_source_target[imagetype]
        for sourcefile in dict_files:
            comment = ""
            do_include = False
            #print(imagetype + ', ' + sourcefile)
            if imagetype in _dict_thumbnails and sourcefile in _dict_thumbnails[imagetype]:
                thumbnail = _dict_thumbnails[imagetype][sourcefile]
                if thumbnail.getState() == state.EXCLUDE:
                    comment = Globals.uncomment
                else: # we have to incluse this file even if it is too old
                    do_include = True
            # we also have to check if file is too old but only if include us not requqested by thumbnail (manually included)
            if do_include == False:
                if imagetype in dict_source_target_tooold and sourcefile in dict_source_target_tooold[imagetype]:
                    comment = Globals.uncomment 
            targetfile = dict_files[sourcefile]
            if platform == "WINDOWS":
                targetfile = re.sub(r'/', '\\\\', targetfile) # replace / by \
            elif platform == "UNIX":
                targetfile = re.sub(r'\\', '/', targetfile) # replace \ by /
            str_ret = template_copy
            str_ret = str_ret.replace('<source>', sourcefile)
            str_ret = str_ret.replace('<target>', targetfile)
            str_ret = re.sub(r'<<<NL>>>', '\n', str_ret) # reconstruct newline in template
            thiscmdfile.write(comment + str_ret + '\n')
        thiscmdfile.close()

        # delete files
        cmd_file_full = self.dict_gen_files_delete[imagetype] # filename was already built by generate()
        thiscmdfile = open(cmd_file_full, 'w')
        thiscmdfile.write(header) 
        dict_files = dict_source_target[imagetype]
        for sourcefile in dict_files:
            comment = ""
            do_include = False
            #print(imagetype + ', ' + sourcefile)
            if imagetype in _dict_thumbnails and sourcefile in _dict_thumbnails[imagetype]:
                thumbnail = _dict_thumbnails[imagetype][sourcefile]
                if thumbnail.getState() == state.EXCLUDE:
                    comment = Globals.uncomment
                else: # we have to incluse this file even if it is too old
                    do_include = True
            # we also have to check if file is too old but only if include us not requqested by thumbnail (manually included)
            if do_include == False:
                if imagetype in dict_source_target_tooold and sourcefile in dict_source_target_tooold[imagetype]:
                    comment = Globals.uncomment 
            targetfile = dict_files[sourcefile]
            if platform == "WINDOWS":
                targetfile = re.sub(r'/', '\\\\', targetfile) # replace / by \
            elif platform == "UNIX":
                targetfile = re.sub(r'\\', '/', targetfile) # replace \ by /
            str_ret = template_delete
            str_ret = str_ret.replace('<source>', sourcefile)
            str_ret = str_ret.replace('<target>', targetfile)
            str_ret = re.sub(r'<<<NL>>>', '\n', str_ret) # reconstruct newline in template
            thiscmdfile.write(comment + str_ret + '\n')
        thiscmdfile.close()
        
        # delrelpath files : remove addrelpath-generated files, but only if empty
        cmd_file_full = dict_gen_files_delrelpath[imagetype] # filename was already built by generate()
        thiscmdfile = open(cmd_file_full, 'w')
        thiscmdfile.write(header)
        outdir = dict_outdirs[imagetype]
        # for cmd we need backslash, for Unix slash
        if platform == "WINDOWS":
            outdir = re.sub(r'/', '\\\\', outdir) # replace / by \
        elif platform == "UNIX":
            outdir = re.sub(r'\\', '/', outdir) # replace \ by /
        stroutfile = "@set OUTDIR=" + outdir + '\n'
        thiscmdfile.write(stroutfile) 
        for relpath in dict_relpath[imagetype]:
            comment = ""
            str_ret = template_delrelpath
            if platform == "WINDOWS":
                str_ret = str_ret.replace('<trenner>', '\\')
                relpath = re.sub(r'/', '\\\\', relpath) # replace / by \
            elif platform == "UNIX":
                str_ret = str_ret.replace('<trenner>', '/')
                relpath = re.sub(r'\\', '/', relpath) # replace \ by /
            str_ret = str_ret.replace('<relpath>', relpath)
            str_ret = re.sub(r'<<<NL>>>', '\n', str_ret) # reconstruct newline in template
            thiscmdfile.write(comment + str_ret + '\n')
        # add the script
        str_ret = template_empty
        str_ret = re.sub(r'<<<NL>>>', '\n', str_ret) # reconstruct newline in template
        l = str_ret.split('\n')
        for ii in l:
           thiscmdfile.write(ii + '\n') 
        thiscmdfile.close()

# #############################################################
if __name__ == '__main__':
    '''Main entry point for the application.'''
    root = tk.Tk()
    app = Dateimeister_support(root)

 





