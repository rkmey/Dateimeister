#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    Oct 14, 2023 03:20:47 PM CEST  platform: Windows NT

import sys
import os
import configparser 
import re
import locale
import ctypes
import time
import operator
import threading
import copy
import subprocess
import shutil
import argparse

import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
from tkinter import filedialog as fd
from tkinter import messagebox
from tkinter import Scrollbar
from tkinter import ttk
from tkinter import Frame
from tkinter import Label
from tkinter import Canvas
from tkinter import Menu
from tkinter.font import Font

from time import gmtime, strftime

import xml.etree.ElementTree as ET
    
from PIL import Image, ImageTk
from datetime import datetime, timezone

import Dateimeister
import dateimeister_config_xml as DX
import dateimeister_video as DV
import Diatisch as DIAT
import dateimeister_generator as DG
import Undo_Redo as UR
import Dateimeister_FSimage as FS
import Dateimeister_messages as DM

#from Dateimeister import ToolTip

from enum import Enum

INCLUDE = 1
EXCLUDE = 2
    
# variables used by more than 1 class
class Globals:
    imagetype = ""
    use_imagetype = False # set to true by sort radiobauttons: we just want to sort new and redisplay the selected imagetype
    screen_width = 0
    screen_height = 0
    uncomment = ""
    gap = 10
    button_duplicates   = None
    config_files_xml    = None
    config_files_subdir = None
    cmd_files_subdir    = None
    datadir = ""
    dict_thumbnails = {}
    dict_duplicates = {}
    outdir = ""
    list_result_diatisch = []

class MyThumbnail:
    #image = "" # hier stehen Klassenvariablen, im Gegensatz zu den Instanzvariablen

    # The class "constructor" - It's actually an initializer 
    def __init__(self, image, pmain, start, end, file, mts, showfile, id, text_id, rect_id, frameids, lineno, player, duplicate, canvas, targetfile, \
      text = None, parent = None, tooold = False):
        self.main = pmain
        self.image = image
        self.start = start
        self.end   = end
        self.file = file
        self.mts  = mts
        self.showfile = showfile
        self.image_id = id
        self.state_id_text = text_id
        self.state_id_rect = rect_id
        self.frameids = frameids
        self.lineno = lineno
        self.player = player 
        self.targetfile = targetfile
        self.fsimage = None
        self.dupl = None
        self.state = INCLUDE
        self.canvas = canvas
        self.text = text
        self.parent = parent
        self.duplicate = duplicate
        self.tooold = tooold
        self.setState(self.state)
        
    def getImage(self):
        #print("*** retrieve Image ")
        return self.image    

    def getStart(self):
        return self.start    

    def getEnd(self):
        return self.end    

    def getFile(self):
        return self.file    
    def getShowfile(self):
        return self.showfile    

    def setId(self, id):
        self.image_id = id    
    def getId(self):
        return self.image_id    

    def set_tooold(self, tooold):
        self.tooold = tooold    
    def get_tooold(self):
        return self.tooold    

    def getDuplicate(self):
        return self.duplicate    

    def setState(self, state, caller = None, do_save = True):
        if state != self.state:
            state_changed = True
        else:
            state_changed = False
        self.state = state # neuer Status
        if self.text is not None:
            # change line in text
            # die Textzeile beschaffen
            lstart = "%d.0" % (self.lineno)
            lend   = "%d.0 lineend" % (self.lineno)
            # tindex = "%d.0, %d.0 lineend" % (lineno, lineno + 1)
            line    = self.text.get(lstart, lend)
            #print ("Retrieved Textline: " + line)
        if self.state == INCLUDE:
            self.canvas.itemconfigure(self.state_id_text, state='hidden')
            self.canvas.itemconfigure(self.state_id_rect, state='hidden')
            if self.text is not None:
                linenew = line
                linenew = re.sub(rf"{Globals.uncomment}", '', linenew)
                self.text.delete(lstart, lend) # without delete / insert highlighttag does not work. Bug in Python?
                self.text.insert(lstart, line)
                self.text.tag_add("include", lstart, lend) # normal foreground
                self.scrollTextToLineno()
        if self.state == EXCLUDE and state_changed:
            self.canvas.itemconfigure(self.state_id_text, state='normal')
            self.canvas.itemconfigure(self.state_id_rect, state='normal')
            if self.text is not None:
                linenew = line
                linenew = re.sub(r"^", f"{Globals.uncomment}", linenew)
                self.text.delete(lstart, lend) # without delete / insert highlighttag does not work. Bug in Python?
                self.text.insert(lstart, line)
                self.text.tag_add("exclude", lstart, lend) # exclude foreground(grey)
                self.scrollTextToLineno()
        if self.parent is not None:
            self.parent.setState(state, caller)
        if self.fsimage is not None:
            self.fsimage.exclude_call(state) # synchronisiert das FSImge, falls vorhanden
            print("FSImage Exclude-Call")
        if self.dupl is not None:
            #print("dupl is: " + str(self.dupl) + "caller is: " + str(caller))
            if caller != self.dupl: # to avoid loop
                self.dupl.exclude_call(self, state) # synchronisiert das Duplicate, falls vorhanden
                #print("Duplicate Exclude-Call")
        if state_changed and do_save:
            self.main.write_cmdfile(Globals.imagetype)
            print ("setState: SAVE requested")
    def getState(self):
        return self.state   

    def getLineno(self):
        return self.lineno    

    def setLineno(self, lineno):
        self.lineno = lineno 
        
    def scrollTextToLineno(self): # reset all lines to "unselect", keep exclude / include Info, hide frame
        for t in Globals.thumbnails[Globals.imagetype]:
            lineno = t.getLineno()
            lstart = "%d.0" % (lineno)
            lend   = "%d.0 lineend" % (lineno)
            line    = self.text.get(lstart, lend) # text widget is the same for all thumbnails
            # without delete / insert tag_add will not work. Bug in tkinter?
            self.text.delete(lstart, lend) # without delete / insert highlighttag does not work. Bug in Python?
            self.text.insert(lstart, line)
            #print("try to select line " + line)
            if t.getState() == INCLUDE:
                self.text.tag_add("normal_include", lstart, lend)
            else:
                self.text.tag_add("normal_exclude", lstart, lend)
            self.canvas.itemconfigure("imageframe", state = 'hidden')
        # now set tag for this thumbnail
        lstart = "%d.0" % (self.lineno)
        lend   = "%d.0 lineend" % (self.lineno)
        line    = self.text.get(lstart, lend)
        # without delete / insert tag_add will not work. Bug in tkinter?
        self.text.delete(lstart, lend) # without delete / insert highlighttag does not work. Bug in Python?
        self.text.insert(lstart, line)
        #self.text.mark_set(tk.INSERT, "%d.%d" % (self.lineno, 0))
        #print("try to select line " + line)
        if self.getState() == INCLUDE:
            self.text.tag_add("select_include", lstart, lend)
        else:
            self.text.tag_add("select_exclude", lstart, lend)
        self.text.see(lstart)
        lineinfo = self.text.dlineinfo(lstart)
        self.text.yview_scroll(lineinfo[1], 'pixels' )
        #self.canvas.itemconfigure("imageframe", state = 'normal')
        #print("Frameids: " + str(self.frameids))
        for frameid in self.frameids:
            self.canvas.itemconfigure(frameid, state = 'normal')

    def register_FSimage(self, fsimage):
        self.fsimage = fsimage

    def register_Dupl(self, dupl):
        self.dupl = dupl

    def getPlayer(self):
        return self.player   

    def getTargetfile(self):
        return self.targetfile   

    def __del__(self):
        if self.player is not None:
            self.player.pstop()
            del self.player
        width = self.end -self.start 
        #print("*** Deleting MyThumbnail-Objekt. " + self.file + " lineno in cmdfile " + str(self.lineno))


# display and process duplicates
class MyDuplicates:

    # The class "constructor" - It's actually an initializer 
    def __init__(self, pmain):
        self.player = None
        self.main = pmain
        self.thumbnails_duplicates = {}
        self.dict_thumbnails_duplicates = {}
        # register at thumbnail, so it can call us for reacting to state
        # Create secondary (or popup) window.
        self.root3 = tk.Toplevel()
        self.w3 = Dateimeister.Toplevel_dupl(self.root3)
        self.f = self.w3.Canvas_dupl
        self.f.delete('all')
        self.w3.Button_dupl.config(command = self.dupl_handler)
        self.root3.protocol("WM_DELETE_WINDOW", self.close_handler)

        width,height=Globals.screen_width,Globals.screen_height
        v_dim=str(width)+'x'+str(height)
        self.root3.geometry(v_dim)
        self.root3.resizable(False, False)
        title = self.root3.title()
        self.root3.title(title + " for " + Globals.outdir)

        # horizontal scrollbar for cancas
        self.H_I = Scrollbar(self.f, orient = HORIZONTAL, command = self.xview)
        #self.H_I.config(command=self.f.xview)
        self.f.config(xscrollcommand=self.H_I.set)
        self.H_I.pack(side=BOTTOM, fill=BOTH)
        # Bind keys to canvas for scrolling
        self.f.bind("<Left>",  lambda event: self.xview("scroll", -1, "units"))
        self.f.bind("<Right>", lambda event: self.xview("scroll",  1, "units"))
        self.f.bind("<Double-Button-1>", self.canvas_show)
        self.f.focus_set()
        
        # Listbox
        # vertical scrollbar for lisrbox
        self.V_L = Scrollbar(self.w3.Listbox_dupl, orient = VERTICAL)
        self.V_L.config(command = self.w3.Listbox_dupl.yview)                    
        self.V_L.pack(side=RIGHT, fill=BOTH)
        self.w3.Listbox_dupl.config(yscrollcommand = self.V_L.set) 
        self.w3.Listbox_dupl.bind('<Double-1>', self.lb_double)
        for key in Globals.dict_duplicates[Globals.imagetype]:
            self.w3.Listbox_dupl.insert(END, key)
        self.w3.Listbox_dupl.select_set(0)

        # Create the context menu
        self.context_menu = tk.Menu(self.f, tearoff=0)
        self.context_menu.add_command(label="Exclude", command=self.canvas_image_exclude)    
        self.context_menu.add_command(label="Show"   , command=self.canvas_image_show)    
        self.context_menu.add_command(label="Restart", command=self.canvas_video_restart)    

        self.f.bind("<Button-3>", self.show_context_menu)    
        self.f.bind('<Motion>', self.tooltip_imagefile)    
        self.f.bind('+', lambda event: self.delay_decr(event))
        self.f.bind('-', lambda event: self.delay_incr(event))
        self.f.bind('0', lambda event: self.delay_deflt(event))
        
        self.dict_child_parent = {}
        self.timestamp = datetime.now()
        self.tooltiptext = ""
        self.tt = Dateimeister.ToolTip(self.f, "no images available", delay=0, follow = True)
        
        self.dict_file_image = {}
        Globals.button_duplicates.config(state = DISABLED) # Duplicates Window must not exist more than once

    def exclude_call(self, parent, state): # react to request from outside, outside is root - thumbnail
        print("MyDuplicate.Exclude called, State = " + str(state))
        # we have to find child for parent ( this is the thumbnail in main window)
        for child in self.dict_child_parent:
            myparent = self.dict_child_parent[child]
            if myparent == parent:
                break
        child.setState(state, self)
    
    def canvas_image_exclude(self): # calls canvas_exclude with self.event
        print("Context menu exlude")
        self.canvas_exclude(self.event)

    def canvas_exclude(self, event):
        self.f.focus_set()

        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            if thumbnail.getState() == INCLUDE:
                thumbnail.setState(EXCLUDE, self)
            else: # toggle to not exclude, delete Item
                thumbnail.setState(INCLUDE, self)
            self.main.historize_process()

    def canvas_image_show(self):
        print("Context menu show")
        self.canvas_show(self.event)

    def canvas_show(self, event):
        self.f.focus_set()

        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            item_id = thumbnail.getId()
            self.display_image(thumbnail)

    def display_image(self, thumbnail):
        file = thumbnail.getShowfile()
        # wenn das Bild schon in einem Fenster angezeigt wird, dann verwenden wir dieses
        if file in self.dict_file_image:
            print ("FSImage exists for file: " + file)
            fs_image = self.dict_file_image[file]
            player = fs_image.getPlayer()
            if player is not None: # this is a video
                print ("FSImage restart file: " + file)
                player.restart()
                fs_image.setPlaystatus('play') # Status, Buttontext
        else: # ein neues Objekt anlegen und in self.dict_file_image eintragen
            print ("FSImage does not exist for file: " + file)
            fs_image = FS.MyFSImage(file, thumbnail, self.dict_file_image, self.main, "", "Include", "Exclude", "Included", "Excluded", self.main.debug)
            self.dict_file_image[file] = fs_image

    def canvas_video_restart(self):
        print("Context menu restart")
        self.f.focus_set()

        canvas_x = self.f.canvasx(self.event.x)
        canvas_y = self.f.canvasy(self.event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # this is a video
                player.restart()

    def show_context_menu(self, event):
        # das Event müssen wir speichern, da die eigenlichen Funktionen die x und y benötigen
        self.event = event
        # falls wir keine anzeigbare Datei haben, müssen wir show-Item disablen
        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            if thumbnail.getImage() == 0:
                print(" No Image availabl for " + thumbnail.getFile())
                self.context_menu.entryconfig(1, state="disabled")
            else:
                self.context_menu.entryconfig(1, state="normal")
            if thumbnail.getState() == INCLUDE:
                self.context_menu.entryconfig(0, label = "Exclude " + thumbnail.getFile())
            else:
                self.context_menu.entryconfig(0, label = "Include " + thumbnail.getFile())
            self.context_menu.entryconfig(1, label = "Show " + thumbnail.getFile())
            self.context_menu.post(event.x_root, event.y_root)
    
    def tooltip_imagefile(self, event):
        tsnow = datetime.now()
        tdiff = abs(tsnow - self.timestamp)
        milliseconds = tdiff.days * 86400 * 1000 + tdiff.seconds * 1000 + tdiff.microseconds / 1000
        if  milliseconds > 200:
            #print("Timer has finished, milliseconds is: ", milliseconds) if self.debug else True
            self.timestamp = tsnow
        else:
            return
        # Tooltip
        #x, y = canvas.winfo_pointerxy()
        text = "no image available"
        # canvas is drawn before the thumbnails are created, so check existence and length
        if Globals.imagetype in self.thumbnails_duplicates and len(self.thumbnails_duplicates[Globals.imagetype]) > 0:
            canvas_x = self.f.canvasx(event.x)
            canvas_y = self.f.canvasy(event.y)
            thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
            if thumbnail is not None:
                text = thumbnail.getFile()
                #print("Image clicked: " + text)
            if text != self.tooltiptext:
                self.tt.update(text)
                self.tooltiptext = text
                self.stop_all_players()
                # if file is video, play video
                if thumbnail is not None:
                    player = thumbnail.getPlayer()
                    if player is not None: # this is a video
                        player.pstart()
                        fps   = player.getFPS()
                        player.setDelay(int(1000 / fps))
                        fc    = player.getFrameCount()
                        delay = player.getDelay()
                        frames_per_second = 1000 / delay
                        duration_in_seconds = fc / frames_per_second
                        #print ("FPS is: ", fps, " Total Num of Frames is: ", fc, " Delay is: ", delay, " calc duration is: " + str(duration_in_seconds))
                        self.context_menu.entryconfig(2, state="normal")
                    else:
                        self.context_menu.entryconfig(2, state="disabled")
                        
    def delay_decr(self, event): # speed +
        self.f.focus_set()
        delta = -5
        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                if delay + delta > 5:
                    player.setDelay(delay + delta)

    def delay_incr(self, event): # speed -
        self.f.focus_set()
        delta = 5
        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                if delay + delta < 200:
                    player.setDelay(delay + delta)

    def delay_deflt(self, event): # speed normal
        self.f.focus_set()
        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                player.setDelay(int(1000 / player.getFPS()))
                
    def lb_double(self, event):
        cs = self.w3.Listbox_dupl.curselection()
        self.thisduplicate = self.w3.Listbox_dupl.get(cs)
        #print("Duplicate selected: " + self.thisduplicate)
        self.display_duplicate(self.thisduplicate)
    
    def scrollx(self, amount, unit):
        #print("scroll command: " + str(amount) + ' ' + unit)
        self.f.xview_scroll(amount, unit)
        return "break"
     
    def dupl_handler(self):
        cs = self.w3.Listbox_dupl.curselection()
        self.thisduplicate = self.w3.Listbox_dupl.get(cs)
        #print("Duplicate selected: " + self.thisduplicate)
        self.display_duplicate(self.thisduplicate)

    def close_handler(self): #calles when window is closing
        print("ToDo, cleanup when window is closed")
        self.stop_all_players() # unregister to avoid calls after duplicate has been destroyed
        for child in self.dict_child_parent:
            parent = self.dict_child_parent[child]
            parent.register_Dupl(None)
        self.root3.destroy()
        for t in self.dict_file_image: # destroy all FSImages
            u = self.dict_file_image[t]
            u.close_handler_external()
        Globals.button_duplicates.config(state = NORMAL)
        self.main.win_duplicates = None
        
    def stop_all_players(self):
        # stop all video players
        Globals.button_duplicates.config(state = DISABLED)
        if Globals.imagetype in self.thumbnails_duplicates:
            for t in self.thumbnails_duplicates[Globals.imagetype]: # stop all running players
                thisplayer = t.getPlayer()
                if thisplayer is not None:
                    if thisplayer.getRun(): # running
                        thisplayer.pstop()
                        #print ("Stop player for: " + t.getFile())
    
    def display_duplicate(self, target_file):
        self.main.stop_all_players() # should not continue running 
        self.f.delete('all')
        self.thumbnails_duplicates[Globals.imagetype] = []
        self.dict_thumbnails_duplicates[Globals.imagetype] = {}
        list_duplicate_sourcefiles = Globals.dict_duplicates[Globals.imagetype][target_file]
        self.lastposition = 0
        self.num_images = 0
        # distance from border for text-boxes
        dist_text  = 10
        # distance from border for image-frame
        dist_frame = 20
        height_scrollbar = self.H_I.winfo_height()

        for source_file in list_duplicate_sourcefiles:
            thumbnail = Globals.dict_thumbnails[Globals.imagetype][source_file]
            showfile = thumbnail.getShowfile()
            state = thumbnail.getState() # we want to use the current state and copy it to the duplicate-thumbnail
            if showfile != 'none':
                canvas_height = self.f.winfo_height() - self.H_I.winfo_height()
                canvas_width  = self.f.winfo_width()
                self.canvas_width_visible = self.f.winfo_width() # Fensterbreite
                player = None
                if thumbnail.getPlayer() is not None: # Video
                    print("try to create new videoplayer...")
                    # create new videoplayer
                    player   = DV.VideoPlayer(self.root3, showfile, self.f, canvas_width, canvas_height, self.lastposition)
                    image_width, image_height, pimg = player.get_pimg()
                else: # still image
                    img  = Image.open(showfile)
                    image_width_orig, image_height_orig = img.size
                    faktor = canvas_height / image_height_orig
                    newsize = (int(image_width_orig * faktor), int(image_height_orig * faktor))
                    r_img = img
                    r_img.thumbnail(newsize)
                    image_width, image_height = r_img.size
                    print("try to print " + showfile + " width is " + str(image_width) + "(" + str(image_width_orig) + ")" + " height is " + str(image_height) + "(" + str(image_height_orig) + ")" \
                       + " factor is " + str(faktor))
                    pimg = ImageTk.PhotoImage(r_img)
                id = self.f.create_image(self.lastposition, 0, anchor='nw',image = pimg, tags = 'images')
                text_id = self.f.create_text(self.lastposition + dist_text, dist_text, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
                rect_id = self.f.create_rectangle(self.f.bbox(text_id), outline="blue", fill = "white", tag = 'rect')
                # the frame for selected image, consisting of 4 lines because there is no opaque rectangle in tkinter
                north_west = (self.lastposition + dist_frame, dist_frame)
                north_east = (self.lastposition + image_width - dist_frame, dist_frame)
                south_west = (self.lastposition + dist_frame, image_height - dist_frame)
                south_east = (self.lastposition + image_width - dist_frame, image_height - dist_frame)
                line_north = self.f.create_line(north_west, north_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_east  = self.f.create_line(north_east, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_south = self.f.create_line(south_west, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_west  = self.f.create_line(north_west, south_west, dash=(1, 1), fill = "red", tags="imageframe")
                frameids = (line_north, line_east, line_south, line_west)

                self.f.tag_raise("rect")
                self.f.tag_raise("text")
                self.f.tag_raise("line")
                #self.f.tag_raise("imageframe")
                if player is not None:
                    player.setId(id)
                # we must also create a thumbnail_list for duplicate images, or the garbage collector will delete images
                mts = os.stat(showfile).st_mtime
                myimage = MyThumbnail(pimg, self.main, self.lastposition, self.lastposition + image_width, showfile, mts, showfile, id, \
                    text_id, rect_id, frameids, 0, player, 'j', self.f, None, None, thumbnail)
                self.thumbnails_duplicates[Globals.imagetype].append(myimage)
                myimage.setState(state)
                self.dict_thumbnails_duplicates[Globals.imagetype][showfile] = myimage # damit können wir auf thumbnails mit den Sourcefilenamen zugreifen, z.B. für Duplicates
                self.lastposition += image_width + Globals.gap 
            else: # wir haben kein Bild, ein Rechteck einfügen
                image_height = canvas_height
                image_width  = int(canvas_height * 4 / 3)
                id = self.f.create_rectangle(self.lastposition, 0, self.lastposition + image_width, canvas_height, fill="blue", tags = 'images')
                text_id = self.f.create_text(self.lastposition, 0, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
                rect_id = self.f.create_rectangle(self.f.bbox(text_id), outline="blue", fill = "white")
                # the frame for selected image, consisting of 4 lines because there is no opaque rectangle in tkinter
                north_west = (self.lastposition + dist_frame, dist_frame)
                north_east = (self.lastposition + image_width - dist_frame, dist_frame)
                south_west = (self.lastposition + dist_frame, image_height - dist_frame)
                south_east = (self.lastposition + image_width - dist_frame, image_height - dist_frame)
                line_north = self.f.create_line(north_west, north_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_east  = self.f.create_line(north_east, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_south = self.f.create_line(south_west, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_west  = self.f.create_line(north_west, south_west, dash=(1, 1), fill = "red", tags="imageframe")
                frameids = (line_north, line_east, line_south, line_west)
                self.f.tag_raise("text")
                #self.f.tag_raise("imageframe")
                mts = os.stat(showfile).st_mtime
                myimage = MyThumbnail(0, self.main, self.lastposition, self.lastposition + image_width, showfile, mts, showfile, id, \
                    text_id, rect_id, frameids, 0, player, 'j', self.f, None, None, thumbnail)
                self.thumbnails_duplicates[Globals.imagetype].append(myimage)
                self.dict_thumbnails_duplicates[Globals.imagetype][showfile] = myimage
                self.lastposition += image_width + Globals.gap 
            self.num_images += 1
            # register at parent-thumbnail, so it can call us for reacting to state
            # we need a dict with child-parent-thumbnails in order to unregister on close
            self.dict_child_parent[myimage] = thumbnail # child -> parent
            thumbnail.register_Dupl(self)
        # Globals.gap haben wir einmal zuviel (fürs letzte) gezählt
        self.lastposition -= Globals.gap
        # damit wir am Ende auch bis zum letzten einzelnen Bild scrollen können, fügen wir ein Rechteck ein
        if len(self.thumbnails_duplicates[Globals.imagetype]) > 0: 
            thumbnail = self.thumbnails_duplicates[Globals.imagetype][-1]
            rect_len = self.canvas_width_visible - (thumbnail.getEnd() - thumbnail.getStart() + Globals.gap)
            self.f.create_rectangle(self.lastposition, 0, self.lastposition + rect_len, canvas_height, fill="yellow")
            self.f.config(scrollregion = self.f.bbox('all')) 
            self.canvas_width_images = self.f.bbox('images')[2]
            self.canvas_width_all    = self.f.bbox('all')[2]
            #print ("Canvas totale Breite(Images): " + str(self.canvas_width_images) + " totale Breite(All): " + str(self.canvas_width_all) \
            #    + " visible: " + str(self.canvas_width_visible) + " lastposition: " + str(self.lastposition))
        
        for child in self.dict_child_parent:
            parent = self.dict_child_parent[child]
            print("Child file / parent file is: " + child.getFile() + ' / ' + parent.getFile())
        #print("self.thumbnails_duplicates is: " + str(self.thumbnails_duplicates))
        self.f.focus_set()

    def xview(self, *args):
        print (*args)
        s1 = 0.0
        s2 = 1.0
        scrolldelta = 0
        width_scrollbar = self.H_I.winfo_width()
        #print ("Scroll Canvas totale Breite(Images): " + str(self.canvas_width_images) + " totale Breite(All): " + str(self.canvas_width_all) \
        #    + " visible: " + str(self.canvas_width_visible) + " Scrollbarwidth: " + str(width_scrollbar) + " BBOX: " + str(self.f.bbox('all')))
        slider_width = int((self.canvas_width_visible / self.canvas_width_all) * width_scrollbar)
        # aktuelle Scroll-Position des Canvas
        canvas_x = self.f.canvasx(0)
        canvas_y = self.f.canvasy(0)
        # aktuelle position der Scrollbar
        scrollposition = self.H_I.get()[0]
        
        #print("scroll_position_H_I: " + str(canvas_x) + " scroll_position Scrollbar: " + str(scrollposition))
        # wenn wir die Pfeiltasten betätigen, wollen wir auf den Anfang des nächsten (vorherigen) Bildes scrollen.
        # wenn das aktuelle Bild nur teilweise zusehen ist, scrollen wir bei Linkstaste auf den Bildbeginn
        if len(args) == 3 and args[2] == "units":
            # den scrollbetrag auf die Größe des Bildes am linken Rand setzen
            thumbnail, index = self.get_thumbnail_by_position(canvas_x + 11, canvas_y)
            if thumbnail is not None:
                if int(args[1]) > 0:
                    scrolldelta = (thumbnail.getEnd() - canvas_x + Globals.gap)
                else:
                    if canvas_x - thumbnail.getStart() > 10: # Bild links abgeschnitten, an den Anfang scrollen
                        scrolldelta = (thumbnail.getStart() - canvas_x) # ist dann negativ, was wir ja wollen
                        #print("Bild links abgeschnitten, weil canvas_x = " + str(canvas_x) + " und Bildstart = " + str(thumbnail.getStart()))
                    else: #Bild ist vollständig zu sehen, also zurück zum nächsten
                        if index > 0: # es gibt einen Vorgänger
                            scrolldelta = (self.thumbnails_duplicates[Globals.imagetype][index - 1].getStart()) - canvas_x
                            #print("Vorgänger ist: " + Globals.thumbnails[Globals.imagetype][index - 1].getFile() + " Start: " + str(Globals.thumbnails[Globals.imagetype][index - 1].getStart())\
                            #    + " canvas_x is: " + str(canvas_x) + " scrolldelta is: " + str(scrolldelta))
                
                new_canvas_x = canvas_x + scrolldelta
                # nach links scrollen machr keinen Sinn, wenn wir schon ganz links stehen, analog rechts
                if (int(args[1]) < 0 and canvas_x <= 0) or (int(args[1]) > 0 and new_canvas_x >= self.canvas_width_images):
                   return
                s2 = new_canvas_x / self.canvas_width_all
                s1 = (new_canvas_x - slider_width) / self.canvas_width_all
                print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
            self.H_I.set(s1, s2)
            self.f.xview('moveto', s2)
        else:
            #if (1 == 0):
                #return
            self.f.xview(*args)

    def get_thumbnail_by_position(self, canvas_x, canvas_y):
        index = -1
        found = False
        for thumbnail in self.thumbnails_duplicates[Globals.imagetype]:
            start = thumbnail.getStart()
            end   = thumbnail.getEnd()
            if (canvas_x >= start and canvas_x <= end):
                index = self.thumbnails_duplicates[Globals.imagetype].index(thumbnail)
                #print("retrieved " + thumbnail.getFile() + " Index: " + str(index))
                found = True
                break
        if not found:
            thumbnail = None
            index = None
        return (thumbnail, index)

    def __del__(self):
        self.a = 1
        print("*** Deleting MyDuplicates-Objekt. Outdir is " + str(Globals.outdir))


# Camera Treeview
class MyCameraTreeview:

    # The class "constructor" - It's actually an initializer 
    def __init__(self, pmain, cameraname = None):
        self.main = pmain
        self.cameraname = cameraname
        self.root = tk.Toplevel()
        self.w = Dateimeister.Toplevel_treeview_camera(self.root)
        self.root.protocol("WM_DELETE_WINDOW", self.close_handler)

        if cameraname is not None:
            self.root.title(cameraname)
        else:
            self.root.title("Cameras")
        width,height=Globals.screen_width,Globals.screen_height
        v_dim=str(width)+'x'+str(height)
        self.root.geometry(v_dim)
        self.root.resizable(True, True)
        self.tv = self.w.Scrolledtreeview_camera
        self.tv.heading("#0", text="Camera")
        self.tv.heading("#1", text="Last modification")
        self.tv.heading("#2", text="Type Subdir")
        self.tv.heading("#3", text="Suffix Process")
        self.tv.config(selectmode = tk.BROWSE)
        # bind select events
        self.tv.tag_bind("camera", "<<TreeviewSelect>>", self.item_selected_camera)
        self.tv.tag_bind("type",   "<<TreeviewSelect>>", self.item_selected_type)
        self.tv.tag_bind("suffix", "<<TreeviewSelect>>", self.item_selected_suffix)
        
        self.entry_camera = self.w.Entry_camera
        self.label_camera = self.w.Label_camera
        self.entry_type = self.w.Entry_type
        self.label_type = self.w.Label_type
        self.entry_suffix = self.w.Entry_suffix
        self.label_suffix = self.w.Label_suffix
        self.entry_subdir = self.w.Entry_subdir
        self.label_subdir = self.w.Label_subdir
        self.button_apply = self.w.Button_apply
        self.button_apply.config(command = self.apply_new)
        self.button_cancel = self.w.Button_cancel
        self.button_cancel.config(command = self.cancel_new)
        self.button_camera_new = self.w.Button_camera_new
        self.button_camera_new.config(command = self.camera_new)
        self.root.bind('<Return>', self.apply_new)

        self.label_camera.config(text = "new item")

        # Undo /Redo Funktionen
        self.button_undo = self.w.Button_undo
        self.button_redo = self.w.Button_redo
        self.button_undo.config(command = self.button_undo_h)
        self.button_redo.config(command = self.button_redo_h)
        self.button_undo.config(state = DISABLED)
        self.button_redo.config(state = DISABLED)
        self.root.bind('<Control-z>', lambda event: self.process_undo(event))
        self.root.bind('<Control-y>', lambda event: self.process_redo(event))

        # Create the context menus
        self.context_menu = tk.Menu(self.tv, tearoff=0)
        #self.context_menu.add_command(label="new suffix", command=self.type_new_suffix)    
        self.context_menu.add_command(label="change"    , command=self.type_change)    
        self.context_menu.add_command(label="delete"    , command=self.type_delete)    
        self.tv.bind("<Button-3>", self.set_selection_by_button3) # selects item at mouse position just like left-click   
        self.proctype_menu = Menu(self.context_menu, tearoff=0)

        # some instance variables 
        # select item, tag, text
        self.item = ""
        self.tag  = ""
        self.text = ""
        self.event = []
        self.context_menu_required = False
        self.newitem = "" 
        self.camera = ""
        self.ctype  = ""
        self.suffix = ""
        self.proctype = ""
        self.subdir = ""
        self.dict_camera_iid = {}  # initial, refresh after applying changed xml       
        self.dict_subdirs = {}
        self.dict_process_image = {}
        self.locked = False
        self.entry_camera.config(state = DISABLED)                  
        self.entry_type.config(state = DISABLED)                  
        self.entry_suffix.config(state = DISABLED)                  
        self.entry_subdir.config(state = DISABLED)                  

        # Undo /Redo control
        self.UR = UR.Undo_Redo_Camera(self.main.debug_p)
        self.dict_processid_xmlfile = {}
        # historize initial state
        self.historize_process()
        # Undo /Redo control end

        self.lock_treeview(False)
        # populate proctype submenue with proctypes from ini
        self.update_proctype_menu()
            
        # fille treeview from xml
        self.treeview_from_xml(Globals.config_files_xml)
    
    def new_text(self, o, text):
        o.delete(0, 'end')
        o.insert('end', text)

    def treeview_clear(self):    
        for i in self.tv.get_children():
           self.tv.delete(i)
        self.root.update()    

    def lock_treeview(self, block):
        if block == False: #set to not lockes
            self.locked = False # remove lock from treeview
            ttk.Style().configure("Treeview", background="white", foreground="black", fieldbackground="white")
            # also enable camera_new Button
            self.button_camera_new.config(state = NORMAL)
        else: #
            self.locked = True # remove lock from treeview
            ttk.Style().configure("Treeview", background="lightgrey", foreground="black", fieldbackground="lightgrey")
            # also disable camera_new Button
            self.button_camera_new.config(state = DISABLED)
    
    
    def treeview_from_xml(self, xml):
        #retrieve cameras from xml-file
        #get usedates
        # get dict Type -> Subdir
        self.dict_subdirs = {}
        self.dict_subdirs = DX.get_subdirs(xml)
        self.dict_process_image = {}
        self.dict_process_image = DX.get_process_image(xml)
        self.treeview_clear()
        self.dict_camera_iid = {}
        dict_cameras_usedate = DX.get_cameras_usedate(xml)
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
        dict_cameras = DX.get_cameras_types_suffixes(xml)
        dict_type_without_suffix = {}
        for camera in dict_cameras:
            ctype_num = 0
            usedate = dict_cameras_usedate[camera]
            cid = self.tv.insert("", tk.END, text = camera, values = (usedate, "", ""), tag = ("camera"))
            self.dict_camera_iid[camera] = cid
            dict_type_without_suffix[camera] = {}
            for ctype in dict_cameras[camera]:
                ctype_num += 1
                if ctype in self.dict_subdirs:
                    subdir = self.dict_subdirs[ctype]
                else: # error: each type needs a subdir
                    subdir = "!"
                tid = self.tv.insert(cid, tk.END, text = ctype, values = ("", subdir, ""), tag = ("type"))
                csuffix_num = 0
                for csuffix in dict_cameras[camera][ctype]:
                    csuffix_num += 1
                    if csuffix in self.dict_process_image:
                        process_image = self.dict_process_image[csuffix]
                    else: # error: each type needs a subdir
                        process_image = "!"
                    sid = self.tv.insert(tid, tk.END, text = csuffix, values = ("", "", process_image), tag = ("suffix"))
                    #print("Camera: " + camera + " Type: " + ctype + " Suffix: " + csuffix + " camera_usedate: " + usedate)
                if csuffix_num == 0:
                    dict_type_without_suffix[camera][ctype] = tid
        if ctype_num == 0:
            messagebox.showinfo("INIT", "Camera " + camera + " no type defined. At least 1 is needed", parent = self.root)
        for camera in dict_type_without_suffix: # ask for missing suffix
            dict_types = dict_type_without_suffix[camera]
            for ctype in dict_types:
                tid = dict_type_without_suffix[camera][ctype]
                self.open_camera(camera) # expand camera node
                messagebox.showinfo("MyCameraTreeview", "Camera " + camera + " type " + ctype + " no suffix defined. At least 1 is needed", parent = self.root)
                self.tv.focus(tid)
                self.tv.selection_set(tid)
                self.context_menu_required = True
                self.retrieve_item(self.event)
                self.type_new_suffix()

    # called when selected depending on bindings defined for tags
    def item_selected_camera(self, event):
        self.retrieve_item(event)
    def item_selected_type(self, event):
        self.retrieve_item(event)
    def item_selected_suffix(self, event):
        self.retrieve_item(event)
    
    
    # retrieves item tag and text for the selected item and show context menu if button-3 pressed or from program
    def retrieve_item(self, event):
        if self.locked == False: # there is no incomplete work (e.g. new type without suffix)
            try:
                # Get the Id of the first selected item.
                self.item = self.tv.selection()[0]
                print("Item selected: " , str(self.tv.selection()))
            except IndexError:
                # If the tuple is empty, there is no selected item.
                messagebox.showwarning(message="Nothin selected", title="Treeview Selection", parent = self.root)
            else:
                # Get and display the text of the selected item.
                self.text = self.tv.item(self.item, option="text")
                self.tag  = self.tv.item(self.item,  option="tag")[0]
                #messagebox.showinfo(message = self.tag, title="Treeview Selection", parent = self.root) 
                if self.context_menu_required:
                    if self.tag.upper() == "CAMERA":
                        self.context_menu.delete(0, 10)
                        self.context_menu.insert_command(0, label = self.text + " new type...", command=self.camera_new_type)
                        self.context_menu.insert_command(1, label = self.text + " change...", command=self.camera_change)
                        self.context_menu.insert_command(2, label = self.text + " delete", command=self.camera_delete)
                    elif self.tag.upper() == "TYPE":
                        self.context_menu.delete(0, 10)
                        self.context_menu.insert_command(0, label = self.text + " new suffix...", command=self.type_new_suffix)
                        self.context_menu.insert_command(1, label = self.text + " change...", command=self.type_change)
                        self.context_menu.insert_command(2, label = self.text + " delete", command=self.type_delete)
                        self.context_menu.insert_command(3, label = self.text + " subdir...", command=self.type_subdir)
                    elif self.tag.upper() == "SUFFIX": # suffix nothing new possible
                        self.context_menu.delete(0, 10)
                        self.context_menu.insert_command(0, label = self.text + " change...", command=self.suffix_change)
                        self.context_menu.insert_command(1, label = self.text + " delete", command=self.suffix_delete)
                        self.context_menu.add_cascade(label="Select processing type", menu = self.proctype_menu) # add submenu of processing types
                    self.context_menu.post(self.event.x_root, self.event.y_root)
                self.context_menu_required = False
        else: # locked
            print("retrieve_item is locked")

            
    def update_proctype_menu(self):
        # descending by usedate
        self.proctype_menu.delete(0, "end")
        # populate proctype_menu
        for item in self.main.dict_proctypes: # from main, filled in dateimeister_support.init from inifile
            print("Process Image  {:s}, {:s}".format(item, self.main.dict_proctypes[item]))
            labeltext = self.main.dict_proctypes[item]
            self.proctype_menu.add_command(label=labeltext, command = lambda item=item: self.proctype_apply(item))
        
    def proctype_apply(self, i): # react to proctype_menu, i is proctype-key from submenu 
        proctype = self.main.dict_proctypes[i].upper()
        camera, ctype, suffix, iid = self.get_camera_type_suffix(self.item)
        self.camera = camera
        self.ctype  = ctype
        self.suffix = suffix
        self.proctype = proctype
        self.newitem = "PROCTYPE_NEW"
        print("** Menuitem selected: " + i + " proctype is: " + proctype + " for suffix: " + suffix)
        self.enable_processing(False, False, False, False, False, "", "", "", "") # enable/ disable entries, buttons, return key
        self.apply_new()

    # handler for mouse right click in treeview
    def set_selection_by_button3(self, event):
        iid = self.tv.identify('item', event.x, event.y)
        self.event = event
        print("button 3 clicked, iid is: " + str(iid)) 
        if iid:
            # mouse pointer over item
            self.tv.focus(iid)
            self.tv.selection_set(iid)
            self.context_menu_required = True
            print(" iid is: " + str(iid)) 
        else:
            # mouse pointer not over item
            # occurs when items do not fill frame
            # no action required
            pass        
        
    # command handler for camera new button
    def camera_new(self):
        print(self.text + " camera new selected by button")
        self.newitem = "CAMERA_NEW" 
        self.enable_processing(True, True, True, False, True, "", "", "", "") # enable/ disable entries, buttons, return key

    # the command handlers for treeview context menu
    def camera_change(self):
        print(self.text + " camera change selected from context menu")
        camera, iid = self.get_camera(self.item)
        self.newitem = "CAMERA_RENAME" 
        self.camera = camera
        self.enable_processing(True, False, False, False, True, self.camera, "", "", "") # enable/ disable entries, buttons, return key

    def camera_delete(self):
        print(self.text + " camera delete selected from context menu")
        camera, iid = self.get_camera(self.item)
        self.newitem = "CAMERA_DELETE" 
        self.camera = camera
        self.enable_processing(False, False, False, False, False, "", "", "", "") # enable/ disable entries, buttons, return key
        self.apply_new() # needed because we now ally-button / return key for which ally_new is the command handler. so we have to call it explicitly
    
    def camera_new_type(self):
        print(self.text + " camera new type selected from context menu")
        # ask for suffix name
        camera, iid = self.get_camera(self.item)
        self.newitem = "TYPE_NEW" 
        self.camera = camera
        self.enable_processing(False, True, True, False, True, self.camera, "", "", "") # enable/ disable entries, buttons, return key
    
    def type_change(self):
        print(self.text + " type change selected from context menu")
        # ask for type name
        camera, ctype, iid = self.get_camera_type(self.item)
        self.entry_camera.delete(0, 'end')
        self.entry_camera.focus_set()
        self.newitem = "TYPE_RENAME" 
        self.camera = camera
        self.ctype  = ctype
        self.enable_processing(False, True, False, False, True, self.camera, self.ctype, "", "") # enable/ disable entries, buttons, return key

    def type_delete(self):
        print(self.text + " type delete selected from context menu")
        camera, ctype, iid = self.get_camera_type(self.item)
        self.newitem = "TYPE_DELETE" 
        self.camera = camera
        self.ctype  = ctype
        self.enable_processing(False, False, False, False, False, "", "", "", "") # enable/ disable entries, buttons, return key
        self.apply_new()

    def type_new_suffix(self):
        print(self.text + " type new suffix selected from context menu or from treeview_from_xml because new type has no suffix")
        # ask for suffix name
        camera, ctype, iid = self.get_camera_type(self.item)
        self.entry_camera.delete(0, 'end')
        self.entry_camera.focus_set()
        self.newitem = "SUFFIX_NEW" 
        self.camera = camera
        self.ctype  = ctype
        self.suffix = self.text
        self.enable_processing(False, False, True, False, True, self.camera, self.ctype, "", "") # enable/ disable entries, buttons, return key
 
    def type_subdir(self):
        print(self.text + " type subdir selected from context menu")
        # ask for type name
        camera, ctype, iid = self.get_camera_type(self.item)
        self.entry_camera.delete(0, 'end')
        self.entry_camera.focus_set()
        self.newitem = "TYPE_SUBDIR" 
        self.camera = camera
        self.ctype  = ctype
        self.enable_processing(False, False, False, True, True, self.camera, self.ctype, "", "") # enable/ disable entries, buttons, return key

    def suffix_change(self):
        print(self.text + " suffix change selected from context menu")
        # ask for suffix name
        camera, ctype, suffix, iid = self.get_camera_type_suffix(self.item)
        self.entry_camera.delete(0, 'end')
        self.entry_camera.focus_set()
        self.newitem = "SUFFIX_RENAME" 
        self.camera = camera
        self.ctype  = ctype
        self.suffix = self.text
        self.enable_processing(False, False, True, False, True, self.camera, self.ctype, "", "") # enable/ disable entries, buttons, return key

    def suffix_delete(self):
        print(self.text + " suffix delete selected from context menu")
        camera, ctype, suffix, iid = self.get_camera_type_suffix(self.item)
        self.newitem = "SUFFIX_DELETE" 
        self.camera = camera
        self.ctype  = ctype
        self.suffix = self.text
        self.enable_processing(False, False, False, False, False, "", "", "", "") # enable/ disable entries, buttons, return key
        self.apply_new()

    def enable_processing(self, b_camera, b_type, b_suffix, b_subdir, b_buttons, text_camera, text_ctype, text_suffix, text_subdir):
        # enable all entries, just for setting text
        self.entry_camera.config(state = NORMAL)                  
        self.entry_type.config(state = NORMAL)                  
        self.entry_suffix.config(state = NORMAL)                  
        self.entry_subdir.config(state = NORMAL)                  
        # fill entries with selection from treeview
        self.new_text(self.entry_camera, text_camera)
        self.new_text(self.entry_type, text_ctype)
        self.new_text(self.entry_suffix, text_suffix)
        self.dict_subdirs = DX.get_subdirs(Globals.config_files_xml)
        if text_ctype in self.dict_subdirs:
            suffix = self.dict_subdirs[self.ctype]
            print("Suffix for ctype " + text_ctype + " is " + suffix)
            self.new_text(self.entry_subdir, suffix)
        else:
            self.new_text(self.entry_subdir, "")

        # initially disable all entries, buttons and return key, can be overridden
        self.root.unbind('<Return>')
        self.button_apply.config(state = DISABLED)
        self.button_cancel.config(state = DISABLED)
        self.entry_camera.config(state = DISABLED)                  
        self.entry_type.config(state = DISABLED)                  
        self.entry_suffix.config(state = DISABLED)                  
        self.entry_subdir.config(state = DISABLED)                  
        focus = False
        if b_camera == True:
            self.entry_camera.config(state = NORMAL, background = 'yellow')
            self.entry_camera.focus_set()
            focus = True

        if b_type == True:
            self.entry_type.config(state = NORMAL, background = 'yellow')
            if not focus: # dont override focus from higher level object
                self.entry_type.focus_set()
                focus = True

        if b_suffix == True:
            self.entry_suffix.config(state = NORMAL, background = 'yellow')
            if not focus: # dont override focus from higher level object
                self.entry_suffix.focus_set()
                focus = True

        if b_subdir == True:
            self.entry_subdir.config(state = NORMAL, background = 'yellow')
            if not focus: # dont override focus from higher level object
                self.entry_subdir.focus_set()
                focus = True

        # finally enable button if something has to be done
        if b_buttons:
            self.button_apply.config(state = NORMAL)
            self.button_cancel.config(state = NORMAL)
            self.root.bind('<Return>', self.apply_new)
        self.lock_treeview(True) # suppress further commands from context-menu until this transaction has finished


    def get_camera_type_suffix(self, iid): # find parent of parent of suffix
        iid = self.item 
        suffix = self.text
        iid = self.tv.parent(iid)
        ctype = self.tv.item(iid, option="text")
        iid = self.tv.parent(iid)
        camera = self.tv.item(iid, option="text")
        return camera, ctype, suffix, iid # iid of camra
        
    def get_camera_type(self, iid): # find parent of type
        iid = self.item 
        ctype = self.text
        iid = self.tv.parent(iid)
        camera = self.tv.item(iid, option="text")
        return camera, ctype, iid # iid of camera
        
    def get_camera(self, iid): # find parent of type
        iid = self.item 
        camera = self.tv.item(iid, option="text")
        return camera, iid # iid of camera

    def apply_new(self, event = None):
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
        if self.newitem == "SUFFIX_NEW":
            suffix = self.entry_suffix.get().upper()
            if suffix is not None and suffix != "":
                rc = DX.new_camera_type_suffix(Globals.config_files_xml, self.camera, self.ctype, suffix, ts) 
            else: # entry_suffix is empty
                messagebox.showinfo("MyCameraTreeview", "Camera " + self.camera + " type " + ctype + \
                 " no suffix defined. At least 1 is needed  or press cancel", parent = self.root)
                self.entry_suffix.focus_set()
                return
        elif self.newitem == "SUFFIX_RENAME":
            suffix_new = self.entry_suffix.get().upper()
            rc = DX.update_camera_type_suffix(Globals.config_files_xml, self.camera, self.ctype, self.suffix, suffix_new, ts)
            self.suffix = suffix_new
        elif self.newitem == "SUFFIX_DELETE":
            suffix = self.suffix
            rc = DX.update_camera_type_suffix(Globals.config_files_xml, self.camera, self.ctype, suffix, "", ts)  # empty newname will delete suffix
            print("delete suffix rc: " + str(rc))
        elif self.newitem == "TYPE_NEW":
            ctype  = self.entry_type.get().upper()
            if ctype is not None and ctype != "":
                suffix = self.entry_suffix.get().upper()
                if suffix is None or suffix == "":
                    messagebox.showinfo("MyCameraTreeview", "Camera " + self.camera + " type " + ctype + \
                     " no suffix defined. At least 1 is needed  or press cancel", parent = self.root)
                    self.entry_suffix.focus_set()
                    return
                else:
                    rc = DX.new_camera_type_suffix(Globals.config_files_xml, self.camera, ctype, suffix, ts)
            else: # entry_type is empty
                messagebox.showinfo("MyCameraTreeview", "Camera " + self.camera + " no type defined. Please enter type or press cancel", parent = self.root)
                self.entry_type.focus_set()
                return
        elif self.newitem == "TYPE_RENAME":
            type_new = self.entry_type.get().upper()
            rc = DX.update_camera_type(Globals.config_files_xml, self.camera, self.ctype, type_new, ts) 
            self.ctype = type_new
        elif self.newitem == "TYPE_DELETE":
            #print(" delete requested for: " + self.camera + '.' + self.ctype)
            rc = DX.update_camera_type(Globals.config_files_xml, self.camera, self.ctype, "", ts)  # empty newname will delete suffix
        elif self.newitem == "TYPE_SUBDIR":
            # create new subdir in xml or update if type-subdir already exists
            subdir = self.entry_subdir.get()
            rc = DX.new_subdir(Globals.config_files_xml, self.ctype, subdir)
            if rc == 0:
                print("subdir node does not exist, make new for type: " + self.ctype + " subdir: " + subdir)
            elif rc == 1:
                print("subdir already exists, update subdir for type: " + self.ctype + " subdir: " + subdir)
        elif self.newitem == "PROCTYPE_NEW":
            # create new process_image in xml or update if suffix already exists
            rc = DX.new_process_image(Globals.config_files_xml, self.suffix, self.proctype)
            if rc == 0:
                print("process_image node does not exist, make new for suffix: " + self.suffix + " process: " + self.proctype)
            elif rc == 1:
                print("process_image already exists, update proctype for suffix: " + self.suffix + " process: " + self.proctype)
        elif self.newitem == "CAMERA_NEW":
            camera  = self.entry_camera.get().upper()
            if camera is not None and camera != "":
                ctype = self.entry_type.get().upper()
                if ctype is None or ctype == "":
                    messagebox.showinfo("MyCameraTreeview", "Camera " + self.camera + \
                     " no type defined. At least 1 is needed  or press cancel", parent = self.root)
                    self.entry_type.focus_set()
                    return
                else: # check if suffix is given
                    self.camera = camera
                    suffix = self.entry_suffix.get().upper()
                    if suffix is None or suffix == "":
                        messagebox.showinfo("MyCameraTreeview", "Camera " + self.camera + " type " + ctype + \
                         " no suffix defined. At least 1 is needed  or press cancel", parent = self.root)
                        self.entry_suffix.focus_set()
                        return
                    else: # create new camera / type /suffix
                        rc = DX.new_camera_type_suffix(Globals.config_files_xml, camera, ctype, suffix, ts)
            else: # entry_type is empty
                messagebox.showinfo("MyCameraTreeview", "Camera " + self.camera + " no camera defined. Please enter camera or press cancel", parent = self.root)
                self.entry_camera.focus_set()
                return
        elif self.newitem == "CAMERA_RENAME":
            print(" rename requested for: " + self.camera)
            camera_new = self.entry_camera.get().upper()
            rc = DX.update_camera(Globals.config_files_xml, self.camera, camera_new)
            self.camera = camera_new
        elif self.newitem == "CAMERA_DELETE":
            print(" delete requested for: " + self.camera)
            rc = DX.update_camera(Globals.config_files_xml, self.camera, "") # empty newname will delete camera

        self.treeview_from_xml(Globals.config_files_xml) # refresh treeview from changed xml
        if self.camera is not None and self.camera != "":
            self.open_camera(self.camera) # expand camera node
        self.enable_processing(False, False, False, False, False, "", "", "", "") # enable/ disable entries, buttons, return key
        self.lock_treeview(False)
        # main window needs new camera data
        self.update_main_window()
        self.historize_process()

    def cancel_new(self, event = None):
        if self.camera is not None and self.camera != "":
            self.open_camera(self.camera) # expand camera node
        self.enable_processing(False, False, False, False, False, "", "", "", "") # enable/ disable entries, buttons, return key
        self.lock_treeview(False)

    def open_camera(self, camera):
        if camera in self.dict_camera_iid:
            iid = self.dict_camera_iid[camera]
            #print ("try to open iid " + iid)
            self.tv.item(iid, open=True)
            item_children = self.tv.get_children(iid)
            print(item_children)
            for iid_child in item_children:
                self.tv.item(iid_child, open=True)

    def update_main_window(self):
        # cleanup: close all child windows of main except this one because nothing can be changed which affects camera window
        #self.state_gen_required()
        self.main.dict_cameras, self.main.dict_subdirs, self.main.dict_process_image = self.main.get_camera_xml()
        #print("update_main_window dict_camera: " + str(self.main.dict_cameras))



    # Undo /Redo functions
    def process_undo(self, event):
        print("ctrl_z pressed.")
        rc, p_now, p_before = self.UR.process_undo()
        if not rc: # undo was not possible
            messagebox.showinfo("UNDO", "no further processes which can be undone", parent = self.root)
        else:
            self.apply_process_id(p_now, p_before)
            self.endis_buttons()

    def process_redo(self, event):
        print("ctrl_y pressed.")
        rc, p_now, p_before = self.UR.process_redo()
        if not rc:
            messagebox.showinfo("REDO", "no further processes which can be redone", parent = self.root)
        else:
            self.apply_process_id(p_now, p_before)
            self.endis_buttons()

    def button_undo_h(self, event = None):
        print("Button Undo pressed")
        self.process_undo(event)
        
    def button_redo_h(self, event = None):
        print("Button Redo pressed")
        self.process_redo(event)

    def endis_buttons(self): # disable / enable buttons depending on processids
        rc_undo, rc_redo = self.UR.endis_buttons()
        if rc_undo:
            self.button_undo.config(state = NORMAL)
        else:
            self.button_undo.config(state = DISABLED)
        if rc_redo:
            self.button_redo.config(state = NORMAL)
        else:
            self.button_redo.config(state = DISABLED)


    def apply_process_id(self, process_id, processid_predecessor):
        # apply xml for actual processid
        # copy xml for processid_akt to "normal" xml and apply it
        xml_filename = self.dict_processid_xmlfile[process_id]
        print("apply_process_id, xml to apply is: ", xml_filename)
        # copy historized xml to "normal" xml
        sourcefile = xml_filename
        targetfile = Globals.config_files_xml
        try:
            shutil.copy(sourcefile, targetfile)
            #print("Source file copied to destination successfully.")
         
        # If source and destination are same
        except shutil.FileNotFoundError:
            print("Source file " + sourcefile + " not found.")
         
        # If source not exists
        except shutil.SameFileError:
            print("Source and destination represents the same file.")
         
        # If there is any permission issue
        except PermissionError:
            print("Permission denied.")
         
        # For other errors
        except:
            print("Error occurred while copying file.")
        # now apply xml
        self.treeview_from_xml(Globals.config_files_xml) # refresh treeview from changed xml
        if self.camera is not None and self.camera != "":
            self.open_camera(self.camera) # expand camera node
        
    def historize_process(self):
        self.UR.historize_process()
        processid_akt = self.UR.get_processid_akt()
        # wir we save the current xml-file to firstname-<processid>.xml
        # E:/Arbeit/python/Dateimeister_vor_git/daten/config/dateimeister_configfiles.xml
        config_dir = os.path.join(Globals.datadir, Globals.config_files_subdir)
        xml_filename = Globals.config_files_xml
        # replace last . by <processid>.
        xml_filename = re.sub(r'\.([^\.]+)$', rf"_{processid_akt}.\1", xml_filename) # reconstruct newline in template
        self.dict_processid_xmlfile[processid_akt] = xml_filename
        print("historize_process, new xml is: ", xml_filename)
        # save actual xml (changed by the action which called historize_processorize) to a config file with xml_filename containing the actual processid
        sourcefile = Globals.config_files_xml
        targetfile = xml_filename
        try:
            shutil.copy(sourcefile, targetfile)
            #print("Source file copied to destination successfully.")
         
        # If source and destination are same
        except shutil.FileNotFoundError:
            print("Source file " + sourcefile + " not found.")
         
        # If source not exists
        except shutil.SameFileError:
            print("Source and destination represents the same file.")
         
        # If there is any permission issue
        except PermissionError:
            print("Permission denied.")
         
        # For other errors
        except:
            print("Error occurred while copying file.")

        self.endis_buttons()

    # Ende undo /redo-Funktionen


    def close_handler(self): #calles when window is closing:
        self.root.destroy()

    def __del__(self):
        self.a = 1
        #print("*** Deleting Camera-Treeview-Objekt.")



class Dateimeister_support:
    def __init__(self, root, debug):
        self.root = root
        self.root.protocol( 'WM_DELETE_WINDOW' , self.root.destroy)
        # Creates a toplevel widget.
        self.w = Dateimeister.Toplevel1(self.root)
        self.dict_process_image = {}
        self.win_duplicates = None
        self.dict_status_image = {}
        self.codepage = ""
        self.config_file = ""
        self.tooltiptext = ""
        self.context_menu = None
        self.timestamp = datetime.now()
        self.use_camera_prefix = True
        if debug == 'Y' or debug == 'y':
            self.debug   = True # debug all
            self.debug_p = True # debug process history
        elif debug == 'N' or debug == 'n':
            self.debug   = False # no debug all
            self.debug_p = False # no debug process history
        elif debug == 'P' or debug == 'p':
            self.debug   = False # no debug all
            self.debug_p = True  # debug process history
        else:
            print("Debug parameter {:s} not allowed, only j, n or p".format(debug))
            exit(-1)

        # Undo /Redo control
        self.UR = UR.Undo_Redo_Dateimeister(self.debug_p)
        # Undo /Redo control end

        self.win_messages = None
        self.dict_thumbnails_lineno = {}
        self.dict_duplicates_sourcefiles = {}
        self.duplicates = False
        self.dict_outdirs = {}
        self.dict_source_target = {}
        self.dict_relpath = {}
        self.dict_gen_files_delrelpath = {}
        self.dict_source_target_tooold = {}
        self.win_diatisch = None
        self.dict_lb_camera_index = {}
        self.diatisch_camera_name = "DIATISCH" # name used for insert / retrieve index in listbox
        
        self.init()
        self.root.mainloop()

    def init(self):
        windll = ctypes.windll.kernel32
        self.codepage = windll.GetUserDefaultUILanguage()
        self.language = locale.windows_locale[ windll.GetUserDefaultUILanguage() ]
        os.environ["LANGUAGE"]    = self.language
        
        print("Codepage is: " + str(self.codepage) + " language is: " + self.language)
        
        inifile = "Dateimeister.ini" 
        config = configparser.ConfigParser() 
        config.read(inifile)
        default_indir  = config["dirs"]["indir"]
        default_outdir = config["dirs"]["outdir"]
        Globals.datadir = config["dirs"]["datadir"]
        Globals.config_files_subdir = config["dirs"]["config_files_subdir"]
        Globals.cmd_files_subdir    = config["dirs"]["cmd_files_subdir"]
        Globals.config_files_xml = config["misc"]["config_files_xml"]
        
        # read process_types from ini because depemdent on dateimeister implementation
        self.dict_proctypes = config["proc_types"]
        for t in self.dict_proctypes:
            print("Proctype: " + self.dict_proctypes[t]) 
        
        Globals.uncomment = config["misc"]["uncomment"] + " "        
        self.templatefile = config["misc"]["templatefile"]
        #max number of config_file-, indir-, outdir-entries in xml
        self.max_configfiles = config["misc"]["max_configfiles"]
        self.max_indirs      = config["misc"]["max_indirs"]
        self.max_outdirs     = config["misc"]["max_outdirs"]
        self.platform = config["misc"]["platform"].upper()
        if self.platform != "UNIX" and self.platform != "WINDOWS":
            messagebox.showerror("INIT", "Platform must be Windows or Unix, not " + platform)
            exit()
        
        self.dict_templates = {}
        self.dict_file_image = {}


        # configure some controls
        self.o_camera  = self.w.Entry_camera
        self.lb_camera = self.w.Listbox_camera
        self.lb_camera.configure(exportselection=False)
        self.b_button1 = self.w.Button1
        self.b_button2 = self.w.Button2
        self.b_button2.config(command=self.B_camera_press)
        self.b_button_indir = self.w.Button1
        self.b_button_indir.config(command=self.Press_indir)
        self.b_button_outdir = self.w.Button_outdir
        self.b_button_outdir.config(command=self.Press_outdir)
        self.button_call = self.w.Button_call
        self.button_call.config(command = self.Press_generate)
        self.button_exec = self.w.Button_exec
        self.button_exec.config(command = self.button_exec_pressed)
        self.Button_exclude = self.w.Button_exclude
        self.Button_exclude.config(command=self.Button_exclude_all)
        self.Button_include = self.w.Button_include
        self.Button_include.config(command=self.Button_include_all)

        # get all camera information and fill camera-listbox
        self.dict_cameras, self.dict_subdirs, self.dict_process_image = self.get_camera_xml()
        #print("self.dict_process_image is: " + str(self.dict_process_image))

        self.t_text1 = self.w.Text1
        # set font
        font_tuple = ("Lucida Console", 10, "normal")
        self.t_text1.config(font = font_tuple)
        self.t_text1.tag_configure("normal_include", foreground="black", background = "white")
        self.t_text1.tag_configure("select_include", foreground="red", background = "white")
        self.t_text1.tag_configure("normal_exclude", foreground="lightgrey", background = "darkgrey")
        self.t_text1.tag_configure("select_exclude", foreground="red", background = "darkgrey")
        
        self.l_label1 = self.w.Label1
        self.label_num = self.w.Label_num
        self.lb_gen   = self.w.Listbox_gen
        self.button_include = self.w.Button_include
        self.button_exclude = self.w.Button_exclude
        self.button_include.config(state = DISABLED)
        self.button_exclude.config(state = DISABLED)
        self.button_undo = self.w.Button_undo
        self.button_redo = self.w.Button_redo
        self.button_undo.config(state = DISABLED)
        self.button_redo.config(state = DISABLED)
        self.button_undo.configure(command=self.button_undo_h)
        self.button_redo.configure(command=self.button_redo_h)
        Globals.button_duplicates = self.w.Button_duplicates
        Globals.button_duplicates.config(state = DISABLED)
        self.button_be = self.w.Button_be
        self.button_be.config(state = DISABLED)
        self.button_be.config(command = self.Button_be_pressed)
        self.button_exec.config(state = DISABLED)
        self.button_call.config(state = DISABLED) # generate-Button
        Globals.button_duplicates.configure(command=self.button_duplicates)
        
        self.label_indir  = self.w.Label_indir
        self.label_outdir = self.w.Label_outdir
        self.button_indir_from_list = self.w.Button_indir_from_list
        self.button_outdir_from_list = self.w.Button_outdir_from_list
        
        # Scrollbars
        V = Scrollbar(self.w.Frame1)
        V.place(relx = 1, rely = 0, relheight = .976, relwidth = .01, anchor = tk.NE)
        V.config(command=self.t_text1.yview)
        self.t_text1.config(yscrollcommand=V.set)  
        H = Scrollbar(self.w.Frame1, orient = HORIZONTAL)
        H.place(relx = 0, rely = 1, relheight = 0.024, relwidth = .99, anchor = tk.SW)
        H.config(command=self.t_text1.xview)
        self.t_text1.config(xscrollcommand=H.set)  
        self.t_text1.configure(wrap="none")
        
        self.cb_recursive = self.w.Checkbutton1
        self.cb_recursive.config(command = self.state_gen_required)
        self.cb_recursive_var = self.w.cb1_val
        self.cb_recursive_var.set(1)
        
        self.cb_prefix = self.w.Checkbutton_use_camera_name
        self.cb_prefix.config(command = self.state_gen_required)
        self.cb_prefix_var = self.w.cb_prefix_var
        self.cb_prefix_var.set(1)

        self.cb_addrelpath = self.w.Checkbutton_addrelpath
        self.cb_addrelpath.config(command = self.state_gen_required)
        self.cb_addrelpath_var = self.w.cb_addrelpath_var
        self.cb_addrelpath_var.set(0)

        self.cb_newer = self.w.Checkbutton_newer
        self.cb_newer.config(command = self.state_gen_required)
        self.cb_newer_var = self.w.cb_newer_var
        self.cb_newer_var.set(0)

        self.cb_num = self.w.Checkbutton_num
        self.cb_num_var = self.w.cbnum_var
        self.cb_num_var.set(1)

        self.combobox_indir = self.w.TCombobox_indir
        self.combobox_indir_var = self.w.combobox_indir
        self.combobox_indir.configure(exportselection=False)
        self.combobox_outdir = self.w.TCombobox_outdir
        self.combobox_outdir_var = self.w.combobox_outdir
        self.combobox_outdir.configure(exportselection=False)
        
        # Scrollbars
        VI = Scrollbar(self.combobox_indir, orient= VERTICAL)
        VI.place(relx = 1, rely = 0, relheight = 1, relwidth = .015, anchor = tk.NE)
        VI.config(command = self.combobox_indir.yview)
        self.combobox_indir.config(yscrollcommand = VI.set)
        VO = Scrollbar(self.combobox_outdir, orient= VERTICAL)
        VO.place(relx = 1, rely = 0, relheight = 1, relwidth = .015, anchor = tk.NE)
        VO.config(command = self.combobox_outdir.yview)
        self.combobox_outdir.config(yscrollcommand = VO.set)
        #listbox camera
        VC = Scrollbar(self.w.Frame_camera, orient= VERTICAL)
        VC.place(relx = 1, rely = 0.01, relheight = .96, relwidth = .03, anchor = tk.NE)
        VC.config(command = self.lb_camera.yview)
        self.lb_camera.config(yscrollcommand = VC.set)
        
        self.canvas_gallery = self.w.Canvas1
        # Scrollbars
        self.scroll_canvas_x = tk.Scrollbar(self.root, orient="horizontal", command=self.xview)
        #self.scroll_canvas_x.pack(side=BOTTOM, fill=BOTH)
        self.scroll_canvas_x.place(relx = .015, rely = .96, relheight = 0.015, relwidth = .97, anchor = tk.NW)
        self.canvas_gallery.config(xscrollcommand = self.scroll_canvas_x.set, scrollregion=self.canvas_gallery.bbox("all"))

        # Create the context menu
        self.context_menu = tk.Menu(self.canvas_gallery, tearoff=0)
        self.context_menu.add_command(label="Exclude", command=self.canvas_image_exclude)    
        self.context_menu.add_command(label="Show"   , command=self.canvas_image_show)    
        self.context_menu.add_command(label="Restart", command=self.canvas_video_restart)    
      
        # Events
        # Button 1 single haben wir deaktiviert, weil double immer auch zuerst single auslöst
        # deshalb exlude und show über Kontext-Menü (rechte Maustaste), Show zusätzlich auch mit Doppelclick
        #self.canvas_gallery.bind("<Button-1>", canvas_gallery_exclude)
        self.canvas_gallery.bind("<Double-Button-1>", self.canvas_gallery_show)
        self.canvas_gallery.bind('<Return>', self.canvas_gallery_show)    # show FSImage for selected thumbnail
        # Pfeitasten fürs scrollen
        self.canvas_gallery.bind("<Left>",  lambda event: self.xview("scroll", -1, "units"))
        self.canvas_gallery.bind("<Right>", lambda event: self.xview("scroll",  1, "units"))
        self.canvas_gallery.bind("<Prior>", lambda event: self.xview("scroll", -1, "page")) # Bind to PageUp
        self.canvas_gallery.bind("<Next>",  lambda event: self.xview("scroll",  1, "page"))  # Bind to PageDown    
        # Bind the context menu to the canvas widget
        self.canvas_gallery.bind("<Button-3>", self.show_context_menu)    
        self.canvas_gallery.bind('<Motion>', self.tooltip_imagefile)    
        self.canvas_gallery.bind('<Button-1>', self.canvas_button_1)    
        self.root.bind("<Configure>", self.on_window_resize)
        self.root.bind("<Destroy>",   self.on_window_destroy)
        # strg-z, y
        self.canvas_gallery.bind('<Control-z>', lambda event: self.process_undo(event))
        self.canvas_gallery.bind('<Control-y>', lambda event: self.process_redo(event))
        self.canvas_gallery.bind('+', lambda event: self.delay_decr(event))
        self.canvas_gallery.bind('-', lambda event: self.delay_incr(event))
        self.canvas_gallery.bind('0', lambda event: self.delay_deflt(event))
        self.canvas_gallery.bind('<FocusOut>', self.focus_out)
        self.lb_gen.bind('<Double-1>', self.lb_gen_double)
        self.lb_camera.bind('<Double-1>', self.lb_camera_double)

        self.t_text1.bind('<Double-1>', self.text1_double)  # show FSImage for selected line
        self.t_text1.bind('<Button-1>', self.text1_single)  # synchronize zext / gallery
        self.t_text1.bind('<Key>', self.text1_key)
        # handler for arrow up / down must be called AFTER the Text-class handler or the bind-handler is 1 step ahead
        self.t_text1.bindtags(('Text', '.!frame.!text', '.', 'all'))
        print("Bindtags: %s " % str(self.t_text1.bindtags()))

        self.cb_num.config(command = self.on_cb_num_toggle)
        self.combobox_indir.bind('<Double-1>', self.combobox_indir_double)
        self.combobox_outdir.bind('<Double-1>', self.combobox_outdir_double)
        self.combobox_indir.bind("<<ListboxSelect>>", lambda event: self.combobox_indir_check_exist(event))
        self.combobox_outdir.bind("<<ListboxSelect>>", lambda event: self.combobox_outdir_check_exist(event))
        self.button_indir_from_list.config(command = self.combobox_indir_double)  
        self.button_outdir_from_list.config(command = self.combobox_outdir_double)  
        
        self.label_indir.config(text = default_indir)   # may be overridden later with first listbox entry
        self.label_outdir.config(text = default_outdir) # may be overridden later with first listbox entry
        self.l_label1.config(text = "Messages")
        self.label_num.config(text = "0")
        self.dict_gen_files = {}
        self.dict_gen_files_delete = {}
        Globals.thumbnails = {}
        images = []
        self.dict_image_lineno = {}
        self.title = self.root.title()
        self.oldcamera = ""

        
        # Fenstergröße
        Globals.screen_width  = int(self.root.winfo_screenwidth() * 0.9)
        Globals.screen_height = int(self.root.winfo_screenheight() * 0.8)
        print("Bildschirm ist " + str(Globals.screen_width) + " x " + str(Globals.screen_height))
        width,height=Globals.screen_width,Globals.screen_height
        v_dim=str(width)+'x'+str(height)
        self.root.geometry(v_dim)
        #my_w.maxsize(300,220)  # (maximum ) width , ( maximum) height
        #my_w.minsize(250,220)  # (minimum ) width , ( minimum) height
        self.root.resizable(False, False)
        self.tt = Dateimeister.ToolTip(self.canvas_gallery, "no images available", delay=0, follow = True)
        
        # Menubar
        menubar = Menu(self.root)
        self.filemenu = Menu(menubar, tearoff=0)
        self.filemenu.add_command(label="New", command=self.donothing)
        self.filemenu.add_command(label="Open config", command=self.open_config)
        self.filemenu.add_command(label="Save config", command=self.save_config)
        self.filemenu.add_command(label="Save config as...", command=self.saveas_config)
        self.filemenu.add_command(label="Apply config", command=self.apply_config)
        menubar.add_cascade(label="File", menu=self.filemenu)
        self.recentmenu = Menu(menubar, tearoff=0)
        self.filemenu.add_cascade(label="Open Recent", menu=self.recentmenu)
        self.filemenu.add_separator()
        self.filemenu.add_command(label="Exit", command=self.root.quit)
        self.filemenu.entryconfig(0, state=DISABLED)
        self.filemenu.entryconfig(1, state=DISABLED) # open after Browse / Edit, we need indir and type
        self.filemenu.entryconfig(2, state=DISABLED)
        self.filemenu.entryconfig(3, state=DISABLED)
        self.filemenu.entryconfig(4, state=DISABLED)
        self.filemenu.entryconfig(5, state=DISABLED)
        
        # camera menu
        cameramenu = Menu(menubar, tearoff=0)
        cameramenu.add_command(label="Edit Cameras...", command = self.menu_cameras_edit)
        cameramenu.add_command(label="Diatisch", command = self.menu_diatisch)
        menubar.add_cascade(label="Tools", menu=cameramenu)

        helpmenu = Menu(menubar, tearoff=0)
        helpmenu.add_command(label="Help Index", command=self.donothing)
        helpmenu.add_command(label="About...", command=self.donothing)
        menubar.add_cascade(label="Help", menu=helpmenu)

        self.root.config(menu=menubar)
        
        # fill in combobox
        result = DX.get_indirs(Globals.config_files_xml)
        dict_filename_usedate = {}
        for tfile in result:
            #print("infile: " + tfile)
            attribute = result[tfile]
            searchattr = 'usedate'
            for attribut in attribute:
                #print("  " + attribut + " = " + attribute[attribut])
                if attribut == searchattr:
                    dict_filename_usedate[tfile] = attribute[searchattr]
            
        # descending by usedate
        sorted_d = dict( sorted(dict_filename_usedate.items(), key=operator.itemgetter(1), reverse=True))
        # make list
        ii = 0
        indexes = []
        use_as_dir = True
        for tfile in sorted_d:
            self.combobox_indir.insert(END, tfile)
            if not os.path.isdir(tfile):
                #print("INDIR: " + tfile + " INDEX: " + str(ii))
                indexes.append(ii) # list of indizes to grey out because dir does not exist
            else:
                if use_as_dir: 
                    self.label_indir.config(text = tfile) # first entry is last used
                    use_as_dir = False
            ii += 1
        if ii > 0:
            self.combobox_indir.select_set(0)
            self.button_indir_from_list.config(state = NORMAL)
        else: 
            self.button_indir_from_list.config(state = DISABLED)
        for ii in indexes:
            self.combobox_indir.itemconfig(ii, fg="gray")

        # fill out combobox
        result = DX.get_outdirs(Globals.config_files_xml)
        dict_filename_usedate = {}
        for tfile in result:
            #print("infile: " + tfile)
            attribute = result[tfile]
            searchattr = 'usedate'
            for attribut in attribute:
                #print("  " + attribut + " = " + attribute[attribut])
                if attribut == searchattr:
                    dict_filename_usedate[tfile] = attribute[searchattr]
            
        # descending by usedate
        sorted_d = dict( sorted(dict_filename_usedate.items(), key=operator.itemgetter(1), reverse=True))
        # make list
        ii = 0
        indexes = []
        use_as_dir = True
        for tfile in sorted_d:
            self.combobox_outdir.insert(END, tfile)
            if not os.path.isdir(tfile):
                print("OUTDIR: " + tfile + " INDEX: " + str(ii))
                indexes.append(ii) # list of indizes to disable because dir does not exist
            else:
                if use_as_dir: 
                    self.label_outdir.config(text = tfile) # first entry is last used
                    use_as_dir = False
            ii += 1
        if ii > 0:
            self.combobox_outdir.select_set(0)
            self.button_outdir_from_list.config(state = NORMAL)
        else: 
            self.button_outdir_from_list.config(state = DISABLED)
        for ii in indexes:
            self.combobox_outdir.itemconfig(ii, fg="gray")
        
        # we need a frame for sort method radio buttons. we want to place them above the right upper corner of the canvas
        # x2, y2 shall be the coordinates of the upper right corner of canvas, which are the coordintes of low right corner of frame

        self.width  = 0
        self.height = 0
        self.text_font = Font(family="Helvetica", size=6)

        self.root.update()
        parent_height = self.root.winfo_height()
        parent_width  = self.root.winfo_width()
        x2 = self.canvas_gallery.winfo_x() + self.canvas_gallery.winfo_width()
        y2 = self.canvas_gallery.winfo_y()
        # to calc x1 we substract min of 80, x2 - dictance from right edge of exec-button
        x1 = x2 - min(int(parent_width / 4), x2 - (self.button_exec.winfo_x() + self.button_exec.winfo_width()))
        # to calc y1 we sutract the height of the exec button
        y1 = y2 - self.button_exec.winfo_height()
        print("x, y of upper left corner of frame above canvas is {:d}, {:d}, lower right corner is {:d}, {:d}".format(x1, y1, x2, y2)) if self.debug else True      
        # the frame
        relx1 = x1 / parent_width
        rely1 = y1 / parent_height
        relh = (y2 - y1) / parent_height
        relw  = (x2 - x1) / parent_width
        print("Frame relx, rely, relw, relh is {:f}, {:f} {:f}, {:f}".format(relx1, rely1, relw, relh)) if self.debug else True      
        self.Frame_sortbuttons = tk.Frame(self.root)
        self.Frame_sortbuttons.place(relx = relx1, rely = rely1, relheight = relh, relwidth = relw)
        self.Frame_sortbuttons.configure(relief='flat')
        self.Frame_sortbuttons.configure(background="#d9d9d9") if not self.debug else True # uncomment for same colour as window (default) or depend on debug
        self.Frame_sortbuttons.update()
        
        self.rbvalue = tk.StringVar()
        self.dict_sort_method = {} # here we keep type(JPEG...) -> sort method(1...4)
        dict_rbtext = {"1": "sort name asc", "2": "sort name desc", "3": "sort mod. asc.", "4": "sort mod. desc"}
        for i in dict_rbtext:
            rb = tk.Radiobutton(self.Frame_sortbuttons, text = dict_rbtext[i], value = i, variable = self.rbvalue, command = self.rb_sort, indicatoron = 0)
            rb.place(relx = (int(i) - 1) / 4, rely=0.0, relheight=1.0, relwidth = 0.25)
            rb.configure(font=self.text_font)
        self.rbvalue.set("1")

    def rb_sort(self, event = None):
        print("Radiobutton pressed, value = {:s}".format(self.rbvalue.get()))

    def donothing(self):
        print("Menuitem not yet implemented")
    
    def on_configure(self, event):
        x = str(event.widget)
        if x == ".": # . is toplevel window
            if (self.width != event.width):
                self.width = event.width
                #print(f"The width of Toplevel is {self.width}") if self.debug else True
            if (self.height != event.height):
                self.height = event.height
                self.Frame_sortbuttons.update()
                l_height = self.Frame_sortbuttons.winfo_height()
                fontsize_use = int(.8 * min(12.0, l_height * .75))
                print(f"The height of Toplevel is {self.height}, label height is {l_height} set fontsize to {fontsize_use}") if self.debug else True
                self.text_font.configure(size=fontsize_use)                

    def timer_end(self):
        print("Timer has elapsed")

    def lb_gen_double(self, event):
        self.Button_be_pressed(event)
    
    def lb_camera_double(self, event):
        self.B_camera_press(event)

    def combobox_indir_double(self, event = None):
        selected_indices = self.combobox_indir.curselection()
        indir = ",".join([self.combobox_indir.get(i) for i in selected_indices]) # because listbox has single selection
        self.label_indir.config(text = indir)

    def combobox_outdir_double(self, event = None):
        selected_indices = self.combobox_outdir.curselection()
        outdir = ",".join([self.combobox_outdir.get(i) for i in selected_indices]) # because listbox has single selection
        self.label_outdir.config(text = outdir)

    def combobox_indir_check_exist(self, event):
        index = self.combobox_indir.curselection()[0]
        indir = self.combobox_indir.get(index) # because listbox has single selection
        print("current selection is: " + indir + " INDEX: " + str(index))
        if not os.path.isdir(indir):
            self.combobox_indir.selection_clear(index) # dont select, MessageBox
            messagebox.showerror("showerror", "Indir: " + indir + " does not exist, choose another one")
    
    def combobox_outdir_check_exist(self, event):
        index = self.combobox_outdir.curselection()[0]
        outdir = self.combobox_outdir.get(index) # because listbox has single selection
        print("current selection is: " + outdir + " INDEX: " + str(index))
        if not os.path.isdir(outdir):
            self.combobox_outdir.selection_clear(index) # dont select, MessageBox
            messagebox.showerror("showerror", "outdir: " + outdir + " does not exist, choose another one")
        
    def open_config(self):
        # get config_files for indir / type
        
        endung = 'xml'
        self.config_file = fd.askopenfilename(initialdir = os.path.join(Globals.datadir, Globals.config_files_subdir), filetypes=[("config files", endung)])
        self.filemenu.entryconfig(4, state=NORMAL)
        self.root.title(self.title + ' ' + self.config_file)
        self.filemenu.entryconfig(2, state=NORMAL)

    def apply_config(self):
        tree = ET.parse(self.config_file)
        xmlroot = tree.getroot()
        time = xmlroot.attrib['time']
        print(time)    
        for thumbnail in xmlroot.findall('thumbnail'):
            #print (thumbnail.attrib['filename'])   
            image = thumbnail.find('image').text
            mystate = thumbnail.find('state').text
            #print(image)
            #print(mystate)
            # apply config
            if image in Globals.dict_thumbnails[Globals.imagetype]:
                if Globals.dict_thumbnails[Globals.imagetype][image] in Globals.thumbnails[Globals.imagetype]:
                    if mystate == "INCLUDE":
                        Globals.dict_thumbnails[Globals.imagetype][image].setState(INCLUDE, None, False)
                    else:
                        Globals.dict_thumbnails[Globals.imagetype][image].setState(EXCLUDE, None, False)
                else:
                    print("thumbnail for " + Globals.imagetype + " file " + image + " not found")
                    print(Globals.thumbnails)
            else:
                print("Imagefile: " + image + " not found in _dict thumdnails of type " + Globals.imagetype)
        self.historize_process()
        self.write_cmdfile(Globals.imagetype)


    def save_config(self): # Config-xml speichern
        print("Config File is: " + self.config_file)
        if self.config_file != "":
            self.write_config(self.config_file)
            # update config-file-entry in xml. will automatically create new entry if type or infile does not exist
            self.update_config_xml(self.config_file)
        else:
            self.saveas_config()

    def saveas_config(self): # Config-xml unter neuem Namen sichern
        endung = 'xml'
        self.config_file = fd.asksaveasfilename(initialdir = os.path.join(Globals.datadir, Globals.config_files_subdir), filetypes=[("config files", endung)])
        if (len(self.config_file) > 0):
            match = re.search(rf".*?{endung}$", self.config_file)
            if match:
                filename = self.config_file
            else:
                filename = self.config_file + '.' + endung
                self.config_file = filename
            self.write_config(filename)
            # update config-file-entry in xml. will automatically create new entry if type or infile does not exist
            self.update_config_xml(self.config_file)
            
            self.root.title(self.title + ' ' + self.config_file)
            self.filemenu.entryconfig(2, state=NORMAL) # Save
            self.filemenu.entryconfig(3, state=NORMAL) # Save As
            self.filemenu.entryconfig(4, state=NORMAL) # Apply config

    def update_config_xml(self, config_file): # Config-xml unter neuem Namen sichern und update
        # update config-file-entry in xml. will automatically create new entry if type or infile does not exist
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
        indir = self.label_indir.cget('text')
        # lower and slash instead of backslash
        indir = re.sub(r'\\', '/', indir).lower()
        my_config_file = re.sub(r'\\', '/', self.config_file).lower()
        #print("*** new config_file: " + my_config_file)

        result, sorted_d = self.get_dict_of_config_files(indir, Globals.imagetype)
        if my_config_file not in result: # this is a new file, so we have to clean up the xml entries in order to stay within max_configfiles
            # delete oldest files until max_configfiles - 1 is reached (because a new one will be created)
            #get dict descending by usedate and result with all attributes
            # in the first pass delete all Entries where file does not exist,afterwards delete entries for existing files if necessary
            # delete only if new config-file does not exist
            for loop in range(1, 3):
                result, sorted_d = self.get_dict_of_config_files(indir, Globals.imagetype) # we have to do this because list of config_files is changed between loops
                list_cfgfiles = []
                for t_cfg in sorted_d:
                    list_cfgfiles.append(t_cfg)
                num_to_delete = len(list_cfgfiles) - int(self.max_configfiles) + 1
                if num_to_delete > 0:
                    #print(str(list_cfgfiles))
                    ii = 0
                    for t in reversed(list_cfgfiles): # now the oldest are on top
                        if ii < num_to_delete:
                            if loop == 1: # in the first pass only delete entries for not existing files
                                if not os.path.isfile(t):
                                    DX.delete_cfgfile(Globals.config_files_xml, indir, Globals.imagetype, t)
                                    ii += 1
                            else: # delete also existing files if necessary
                                DX.delete_cfgfile(Globals.config_files_xml, indir, Globals.imagetype, t)
                                ii += 1
                        else:
                            break
        # now create new entry for my_config_file
        DX.new_cfgfile(Globals.config_files_xml, indir, Globals.imagetype, my_config_file, ts, self.num_images)
        # update usedate in Globals.config_files_xml
        DX.update_cfgfile(Globals.config_files_xml, indir, Globals.imagetype, my_config_file, ts, self.num_images)
        # finally update the recent files menu
        self.update_recent_menu(indir, Globals.imagetype)

    def update_recent_menu(self, indir, imagetype):
        # descending by usedate
        result, sorted_d = self.get_dict_of_config_files(indir, imagetype)
        #print("get_dict_of_config_files: " + str(sorted_d))
        
        self.recentmenu.delete(0, "end")
        ii = 0
        for item in sorted_d:
            usedate      = result[item]['usedate']
            mynum_images = result[item]['num_images']
            labeltext = item + ' (usedate: ' + usedate + ' ,images: ' + mynum_images + ')'
            self.recentmenu.add_command(label=labeltext, command = lambda item=item: self.recent_config(item))
            print("  config_file: " + labeltext)
            if not os.path.isfile(item):
                self.recentmenu.entryconfig(ii, state = DISABLED)
            ii += 1
        if ii == 0:
            self.filemenu.entryconfig(5, state=DISABLED)


    def write_config(self, filename): # Config-xml unter neuem Namen sichern
        file1 = open(filename, "w")
        
        s = '<?xml version="1.0" encoding="iso-8859-1"?>' + "\n"
        file1.write(s)
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())

        s = '<thumbnails time="' + ts + '">' + "\n"
        file1.write(s)
        for thumbnail in Globals.thumbnails[Globals.imagetype]:
            s = "    <thumbnail filename=\"" + thumbnail.getFile() + "\">\n"
            file1.write(s)
            s = "        <image>" + str(thumbnail.getFile()) + "</image>\n"
            file1.write(s)
            s = "        <state>" + str(thumbnail.getState()) + "</state>\n"
            file1.write(s)
            s = "    </thumbnail>\n"
            file1.write(s)
        s = '</thumbnails>' + "\n"
        file1.write(s)
        # Closing file
        file1.close()
        
    def get_dict_of_config_files(self, pindir, imagetype): # returns dict sorted by usedate asc
        # lower and slash instead of backslash
        indir = re.sub(r'\\', '/', pindir).lower()
        result = DX.get_cfgfiles(Globals.config_files_xml, indir, imagetype)
        dict_filename_usedate = {}
        for cfg_file in result:
            print("config_file: " + cfg_file)
            attribute = result[cfg_file]
            searchattr = 'usedate'
            for attribut in attribute:
                print("  " + attribut + " = " + attribute[attribut])
                if attribut == searchattr:
                    dict_filename_usedate[cfg_file] = attribute[searchattr]
            
        # descending by usedate
        sorted_d = dict( sorted(dict_filename_usedate.items(), key=operator.itemgetter(1), reverse=True))
        return result, sorted_d


    def recent_config(self, item):
        print("** Menuitem selected: " + item)
        self.config_file = item
        self.filemenu.entryconfig(4, state=NORMAL)
        self.root.title(self.title + ' ' + self.config_file)
        self.filemenu.entryconfig(2, state=NORMAL)
    

    def tooltip_imagefile(self, event):
        tsnow = datetime.now()
        tdiff = abs(tsnow - self.timestamp)
        milliseconds = tdiff.days * 86400 * 1000 + tdiff.seconds * 1000 + tdiff.microseconds / 1000
        if  milliseconds > 200:
            #print("Timer has finished, milliseconds is: ", milliseconds) if self.debug else True
            self.timestamp = tsnow
        else:
            return
        # Tooltip
        #x, y = self.canvas_gallery.winfo_pointerxy()
        text = "no image available"
        if len(Globals.thumbnails) > 0:
            canvas_x = self.canvas_gallery.canvasx(event.x)
            canvas_y = self.canvas_gallery.canvasy(event.y)
            thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
            if thumbnail is not None:
                text = thumbnail.getFile()
                #print("Image clicked: " + text)
            if text != self.tooltiptext:
                self.tt.update(text)
                self.tooltiptext = text
                self.stop_all_players()
                # if file is video, play video
                if thumbnail is not None:
                    player = thumbnail.getPlayer()
                    if player is not None: # this is a video
                        player.pstart()
                        fps   = player.getFPS()
                        player.setDelay(int(1000 / fps))
                        fc    = player.getFrameCount()
                        delay = player.getDelay()
                        frames_per_second = 1000 / delay
                        duration_in_seconds = fc / frames_per_second
                        #print ("FPS is: ", fps, " Total Num of Frames is: ", fc, " Delay is: ", delay, " calc duration is: " + str(duration_in_seconds))
                        self.context_menu.entryconfig(2, state="normal")
                    else:
                        self.context_menu.entryconfig(2, state="disabled")

    def focus_out(self, event):
        #print("***lost Focus")
        a = 0
        #self.stop_all_players()
        

    def on_window_resize(self, event): # das funktioniert nicht rihtig. Die übergebenen Zahlen sind falsch und der Handler wird unglaublich oft aufgerufen
        width = event.width
        height = event.height
        #print("Window resized to width: " + str(width) + " height: " + str(height))

    def Press_indir(self, *args):
        indir = fd.askdirectory() 
        print ("indir %s" % indir)
        #self.clear_textbox(self.combobox_indir)
        self.label_indir.config(text = indir)

    def Press_outdir(self, *args):
        #outdir = fd.askopenindir() 
        outdir = fd.askdirectory() 
        print ("outdir %s" % outdir)
        #self.clear_textbox(self.combobox_outdir)
        self.label_outdir.config(text = outdir)

    def B_camera_press(self, *args):
        # get selected indices
        selected_indices = self.lb_camera.curselection()
        thiscamera = ",".join([self.lb_camera.get(i) for i in selected_indices]) # because we have a single choice listbox
        print ("Kamera ist " + thiscamera)
        self.clear_textbox(self.o_camera)
        self.insert_text(self.o_camera, thiscamera)
        self.button_be.config(state = DISABLED) # browse / edit will throw error if not preceded by generate after chosing camera
        self.button_call.config(state = NORMAL)
        if thiscamera != self.oldcamera:
            self.button_undo.config(state = DISABLED)    
            self.button_redo.config(state = DISABLED)
            self.clear_text(self.t_text1)
            self.canvas_gallery.delete("all")
            self.filemenu.entryconfig(1, state=DISABLED)
            self.button_exclude.config(state = DISABLED)
            self.button_include.config(state = DISABLED)
            self.button_exec.config(state = DISABLED)
            Globals.button_duplicates.config(state = DISABLED)
            self.label_num.config(text = "0")
            self.clear_textbox(self.lb_gen)
            self.oldcamera = thiscamera
            self.clear_dict_2nd(Globals.thumbnails, Globals.imagetype)
            self.clear_dict_2nd(Globals.dict_thumbnails, Globals.imagetype)
        if Globals.list_result_diatisch:
            Globals.list_result_diatisch.clear()
            Globals.list_result_diatisch = None

    def Press_generate(self, *args):
        # cleanup
        self.close_child_windows()
        # reset all process-states
        self.UR.reset()
        self.button_undo.config(state = DISABLED)    
        self.button_redo.config(state = DISABLED)
        
        self.clear_text(self.t_text1)
        self.canvas_gallery.delete("all")

        # get indir, outdir, camera
        indir  = self.label_indir.cget('text')
        outdir = self.label_outdir.cget('text')
        thiscamera = self.o_camera.get();
        if not indir:
            messagebox.showerror("showerror", "kein Indir ausgewählt")
            self.b_button1.focus_set()
            return None
        if not outdir:
            messagebox.showerror("showerror", "kein outdir ausgewählt")
            self.b_button_outdir.focus_set()
            return None
        if not thiscamera:
            messagebox.showerror("showerror", "keine Kamera ausgewählt")
            self.b_button2.focus_set()
            return None
        if self.cb_recursive_var.get():
            recursive = "j"
        else:
            recursive = "n"
        if self.cb_prefix_var.get():
            self.use_camera_prefix = True
        else:
            self.use_camera_prefix = False
        if self.cb_addrelpath_var.get():
            addrelpath  = "j"
        else:
            addrelpath  = "n"
        print ("INDIR is  " + indir)
        
        # we try to open the templatefile. we do it here because one does not have to stop the program when file not found. 
        # Just correct it and run generate again
        self.get_templates() # read them into dict_templates (instance variable)
        
        self.clear_text(self.t_text1)
        self.clear_textbox(self.lb_gen)

        Globals.dict_duplicates = {}
        owndir = os.getcwd()
        self.dict_gen_files = {}
        self.dict_gen_files_delete = {}
        self.dict_source_target = {}
        dict_source_target_jpeg = {}
        self.dict_source_target_tooold = {}
        self.dict_relpath = {}
        self.dict_gen_files_delrelpath = {}
        self.dict_firstname_fullname = {}
        self.dict_outdirs = {}
        self.dict_sort_method = {}

        # now make an entry for this indir / outdir. For indir we use the already existing function for config_files without type / config_file
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())

        this_i = re.sub(r'\\', '/', indir).lower()
        # delete indir-entries from xml if number gt than max from ini, oldest first
        self.new_dir_in_xml('indir', self.max_indirs, this_i, ts)

        this_o = re.sub(r'\\', '/', outdir).lower()
        # delete outdir-entries from xml if number gt than max from ini, oldest first
        self.new_dir_in_xml('outdir', self.max_outdirs, this_o, ts)

        for dateityp in self.dict_cameras[thiscamera]:
            # cleanup
            self.clear_dict_2nd(Globals.thumbnails, dateityp)
            # in Python kann man offenbar nicht automatisch einen Eintrag anlegen, indem man ein Element an die Liste hängt
            Globals.thumbnails[dateityp] = []

            subdir = self.dict_subdirs[dateityp]
            thisoutdir = outdir + "/" + subdir
            self.dict_outdirs[dateityp] = thisoutdir
            endung= self.dict_cameras[thiscamera][dateityp]
            if self.use_camera_prefix:
                target_prefix = thiscamera + '_'
            else:
                target_prefix = ''
            self.dict_source_target[dateityp] = {}
            self.dict_relpath[dateityp] = {}
            # get sort method. if value exists in dict_sort_method use it. it has been set when images are displayed. Otherwise use value of the radio button
            if self.dict_sort_method.get(dateityp):
                sort_method = self.dict_sort_method.get(dateityp)
                print("generate sort method for {:s} is {:s}".format(dateityp, sort_method))
            else:
                sort_method = self.rbvalue.get()
                print("generate sort method is {:s}".format(sort_method))
            self.dict_source_target[dateityp], dict_source_target_jpeg[dateityp], self.dict_source_target_tooold[dateityp], self.dict_relpath[dateityp] = \
              DG.dateimeister(dateityp, endung, indir, thisoutdir, addrelpath, recursive, self.cb_newer_var.get(), target_prefix, Globals.list_result_diatisch, int(sort_method), self.debug)
            self.dict_relpath[dateityp] = dict(reversed(list(self.dict_relpath[dateityp].items())))
            for ii in self.dict_relpath[dateityp]:
                print(" > ", ii, " files: ", self.dict_relpath[dateityp][ii])
            num_files = 0
            for thisfile in self.dict_source_target[dateityp]:
                #print("IN: " + thisfile + " OUT: " + self.dict_source_target[dateityp][thisfile])
                num_files += 1
            print(dateityp + " F NUM: " + str(num_files))
            # save name for cmdfile
            cmd_file_name = "_copy_" + dateityp + '.cmd'
            cmd_file_full = os.path.join(Globals.datadir, Globals.cmd_files_subdir, cmd_file_name)
            # generierte Dateien in dict festhalten
            self.dict_gen_files[dateityp] = cmd_file_full
            #print("self.dict_gen_files[dateityp]: ", str(self.dict_gen_files[dateityp]), " datadir is: ", Globals.datadir)

            # save name for delete files
            # important: subdir MUST NOT start with a slash!
            cmd_file_name_delete = "_delete_" + dateityp + '.cmd'
            cmd_file_full_delete = os.path.join(Globals.datadir, Globals.cmd_files_subdir, cmd_file_name_delete)
            # generierte Dateien in dict festhalten
            self.dict_gen_files_delete[dateityp] = cmd_file_full_delete
            #print("dict_gen_files_delete[dateityp]: ", str(self.dict_gen_files_delete[dateityp]))

            # save name for delrelpath files
            cmd_file_name_delrelpath = "_delrelpath_" + dateityp + '.cmd'
            cmd_file_full_delrelpath = os.path.join(Globals.datadir, Globals.cmd_files_subdir, cmd_file_name_delrelpath)
            # generierte Dateien in dict festhalten
            self.dict_gen_files_delrelpath[dateityp] = cmd_file_full_delrelpath
            #print("self.dict_gen_files_delrelpath[dateityp]: ", str(self.dict_gen_files_delrelpath[dateityp]))

            Globals.dict_duplicates[dateityp] = {}
            print ("OUTDIR is " + thisoutdir + " ENDUNG is " + endung)
            #print ("OUTFILE is " + os.environ["OUTFILE"])
            # wenn die Endung wegen mehrerer Möglichkeiten (jpeg, jpg) mehr al 1 Eintrag hat, nehmen wir den letzten
            #print("'(.*?)\.({:s})' 'PIC_{:s}_$1.$2'".format(dateityp, thiscamera))
            self.clear_text(self.t_text1)
            # wir tragen die Dubletten ein       
            lineno = 0
            for this_sourcefile in self.dict_source_target[dateityp]:
                lineno += 1
                #print(this_sourcefile)
                dupl_target_file = self.dict_source_target[dateityp][this_sourcefile].upper() #for duplicate target  check ignore case
                if dupl_target_file not in Globals.dict_duplicates[dateityp]:
                    #self.clear_dict_2nd(Globals.dict_duplicates, dateityp)
                    Globals.dict_duplicates[dateityp][dupl_target_file] = []
                Globals.dict_duplicates[dateityp][dupl_target_file].append(this_sourcefile) # Duplicates  
            # remove singles from  dict_duplicates, we use a copy because we must not delete entries during iteration
            # create dict_duplicates_sourcefiles , key = imagetype, value = dict:sourcefile->targetfile
            self.clear_dict_2nd(self.dict_duplicates_sourcefiles, dateityp)
            self.dict_duplicates_sourcefiles[dateityp] = {}
            dict_h = {}
            dict_h = copy.deepcopy(Globals.dict_duplicates[dateityp])
            #print("dict_duplicates: " + str(Globals.dict_duplicates[dateityp])) 
            for mytarget in dict_h:
                #print("Duplcate Key: " + mytarget) 
                mylist = dict_h[mytarget]
                if len(mylist) == 1: # only 1 file
                    del Globals.dict_duplicates[dateityp][mytarget]
                    #print("nodupl: ", str(mylist))
                else:
                    for mysource in mylist:
                        self.dict_duplicates_sourcefiles[dateityp][mysource] = mytarget
            #print("dict_duplicates: " + str(Globals.dict_duplicates[dateityp])) 

            # alle Dateien aus der gerade verarbeiteten cmd-Datei tragen wir in dict_firstname_fullname ein, wenn type = JPEG
        regpattern = r'[\/\\]([^\/\\.]+)\.([^\/\\.]+)' # zwischen dem letzten / bzw. \ und dem letzten Punkt steht der Vorname, Nachname danach
        regpattern_source = r'"([^"]+)"' # Sourcefile
        target_file = ""
        source_file = ""
        #print("JPEGs: " + str(dict_source_target_jpeg["JPEG"]))
        for this_sourcefile in dict_source_target_jpeg["JPEG"]:
            lineno += 1
            b_match = False
            match = re.search(regpattern, this_sourcefile)
            if match:
                firstname = match.group(1)
                lastname  = match.group(2).upper()
                #print("GENERATE: firstname / lastname = " + firstname + " / " + lastname)
                b_match = True
            else: 
                #print("GENERATE unable to find firstname, lastname in: " + line)
                a = 1
            if (b_match == True):
                # Show error if no process_type available
                if lastname.upper() not in self.dict_process_image:
                    messagebox.showerror("GENERATE", "Section process_type, no entry in ini-file found for: " + lastname)
                    print("dict_process_image is: " + str(self.dict_process_image))
                    exit()
                process_type = self.dict_process_image[lastname].upper()
                if (process_type == "JPEG"):
                    if firstname.upper() not in self.dict_firstname_fullname:
                        self.dict_firstname_fullname[firstname.upper()] = []
                    self.dict_firstname_fullname[firstname.upper()].append(this_sourcefile) # es kann ja in den ganzen Verzeichnissen mehrere jpegs mit demselben Vornamen geben  

        self.l_label1.config(text = "Output from Dateimeister")
                
        # die generierten Dateien in die Listbox eintragen
        for key in self.dict_gen_files:
            self.lb_gen.insert(END, key)
        self.lb_gen.select_set(0)
        if self.lb_gen.size() > 0:
            self.button_be.config(state = NORMAL)
        self.filemenu.entryconfig(1, state=DISABLED)
        self.button_exclude.config(state = DISABLED)
        self.button_include.config(state = DISABLED)
        self.button_exec.config(state = DISABLED)
        Globals.button_duplicates.config(state = DISABLED)
        self.label_num.config(text = "0")
        os.chdir(owndir)
        self.write_cmdfiles()
    
    def Button_be_pressed(self, *args):
        # reset all process-states
        self.UR.reset()
        self.button_undo.config(state = DISABLED)    
        self.button_redo.config(state = DISABLED)
        self.config_file = ""   # after change of imagetype (possibly) has to be selected new by user
        self.root.title(self.title)
        
        self.clear_text(self.t_text1)
        self.canvas_gallery.delete("all")

        if not Globals.use_imagetype: # the "normal case": get imagetype from listbox, else after new sort re-use Globals.imagetype
            if not self.lb_gen.curselection() == ():
                selected_indices = self.lb_gen.curselection()
            else:
                messagebox.showerror("showerror", "no Imagetype selected")
                self.lb_gen.focus_set()
                return None
            Globals.imagetype = ",".join([self.lb_gen.get(i) for i in selected_indices]) # weil wir single für die Listbox gewählt haben
        imagetype = Globals.imagetype
        filename = self.dict_gen_files[imagetype]
        subdir = self.dict_subdirs[imagetype]
        Globals.outdir = self.dict_outdirs[imagetype] # for setting title of duplicate-window
        self.stop_all_players() # should not continue running 
        
        self.clear_dict_2nd(Globals.thumbnails, imagetype)
        # in Python kann man offenbar nicht automatisch einen Eintrag anlegen, indem man ein Element an die Liste hängt
        Globals.thumbnails[imagetype] = []
        # cleanup
        self.close_child_windows()
        
        self.l_label1.config(text = "Output from Dateimeister : " + filename)
        self.dict_image_lineno[imagetype] = {} # in Python muss das sein, sonst gehts in der nächsten Ebene nicht
        lineno = 0
        #print(str(self.dict_source_target))
        for this_sourcefile in self.dict_source_target[imagetype]:
            this_targetfile = self.dict_source_target[imagetype][this_sourcefile]
            lineno += 1
            source_without_dir = re.sub(re.escape(self.label_indir.cget('text')), '', this_sourcefile)
            source_without_dir = re.sub(r'^[\\\/]', '', source_without_dir)
            target_without_dir = re.sub(re.escape(self.label_outdir.cget('text')), '', this_targetfile)
            target_without_dir = re.sub(r'[\\\/]', '/', target_without_dir) # replace all backslashes by slash
            my_subdir = subdir
            my_subdir = re.sub(r'[\\\/]', '/', my_subdir) # replace all backslashes by slash
            target_without_dir = re.sub(re.escape(my_subdir), '', target_without_dir) # replace subdir
            target_without_dir = re.sub(r'^[\\\/]+', '', target_without_dir) # replace first slash
            text_w = 80
            #thisline = "{source:<{len1}s}{target:<{len1}s}\n".format(len1 = text_w, source = source_without_dir, target = target_without_dir)
            thisline = "{source:<{len1}s}{target:<{len1}s}\n".format(len1 = text_w, source = this_sourcefile, target = this_targetfile)
            self.insert_text(self.t_text1, thisline)
            self.dict_image_lineno[imagetype][this_sourcefile] = lineno
        
        # wir suchen in der cmd-Datei die Endung für jedes Imagefile. Damit suchen wir in dict_process_image nach einem Eintrag
        # wenn JPEG, dann verarbeiten wir die Zeile und verwenden das mutmaßliche JPEG_Bild in der Gallerie. Wenn use_jpeg gefunden wird
        # suchen wir nach einem passenden JPEG. Falls die Endung im dict nicht gefunden wird, verwenden wir ebenfalls use_jpeg. Später
        # können hier passende RAW-DLLs aufgerufen werden, z.b. mit Name der DLL in der Ini-Datei
        canvas_height = self.canvas_gallery.winfo_height()
        canvas_width  = self.canvas_gallery.winfo_width()
        self.canvas_gallery_width_visible = self.canvas_gallery.winfo_width() # Fensterbreite
        self.lastposition = 0
        Globals.dict_thumbnails[imagetype] = {}
        self.dict_thumbnails_lineno[imagetype] = {}
        self.num_images = 0
        for file in self.dict_source_target[imagetype]:
            self.num_images += 1
            this_targetfile = self.dict_source_target[imagetype][file]
            # wir brauchen die Endung der Datei und den Vornamen
            regpattern = r'[\/\\]([^\/\\."]+)\.([^\/\\."]+)' # zwischen dem letzten / bzw. \ und dem letzten Punkt steht der Vorname, Nachname danach
            match = re.search(regpattern, file)
            if match:
                firstname  = match.group(1)
                lastname   = match.group(2).upper()
                #print("firstname / lastname = " + firstname + " / " + lastname)
            else: 
                print("unable to find firstname, lastname for: " + file)
            # wir brauchen die Methode aus der ini-Datei, mit der wir das Bild verarbeiten sollen
            process_type = self.dict_process_image[lastname].upper()
            #print("Process Type is: " + process_type)
            player = None # only for video
            if (process_type == "JPEG"):
                showfile = file # Image-file to show in Canvas
            elif process_type == "USE_JPEG":
                if firstname.upper() in self.dict_firstname_fullname:
                    showfile = self.dict_firstname_fullname[firstname.upper()][-1]
                    #print ("*** JPEG found for " + file + " using " + showfile)
                else:
                    showfile = "none"
                    print ("*** No JPEG found for " + file + " using " + showfile)
                    process_type = "none" # rectangle instead
            elif process_type == 'VIDEO':
                print("try to create new videoplayer...")
                # create new videoplayer
                player   = DV.VideoPlayer(self.root, file, self.canvas_gallery, canvas_width, canvas_height, self.lastposition)
                image_width, image_height, pimg = player.get_pimg()
                showfile = file
            else: # hier später mal ein Aufruf, um RAW oder was auch immer nach JPEG zu konvrtieren, aber jetzt erstmal Default nciht gefunden anzeigen
                showfile = "none"
            if file in self.dict_duplicates_sourcefiles[imagetype]: # for storing in Thumbnail
                duplicate = 'j'
            else:
                duplicate = 'n'
            #print ("Process-type, file" , process_type, ' ', file)
            this_lineno = self.dict_image_lineno[imagetype][file]
            # distance from border for text-boxes
            dist_text  = 10
            # distance from border for image-frame
            dist_frame = 20
            if  process_type != "none": 
                if process_type != 'VIDEO': # we have to convert image to photoimage
                    img  = Image.open(showfile)
                    image_width_orig, image_height_orig = img.size
                    faktor = canvas_height / image_height_orig
                    newsize = (int(image_width_orig * faktor), int(image_height_orig * faktor))
                    r_img = img
                    r_img.thumbnail(newsize)
                    image_width, image_height = r_img.size
                    #print("try to print " + file + " width is " + str(image_width) + "(" + str(image_width_orig) + ")" + " height is " + str(image_height) + "(" + str(image_height_orig) + ")" \
                    #   + " factor is " + str(faktor))
                    pimg = ImageTk.PhotoImage(r_img)
                # an den Thumbnails führen wir einige Attribute, außerdem sorgt die Liste dafür, dass der Garbage-Kollektor das Bild nicht löscht.
                # indem wir es in eine Liste einfügen, bleibt der Referenz-Count > 0
                id = self.canvas_gallery.create_image(self.lastposition, 0, anchor='nw',image = pimg, tags = 'images')
                text_id = self.canvas_gallery.create_text(self.lastposition + dist_text, dist_text, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
                rect_id = self.canvas_gallery.create_rectangle(self.canvas_gallery.bbox(text_id), outline="blue", fill = "white", tag = 'rect')
                text_id_num = self.canvas_gallery.create_text(self.lastposition + dist_text, image_height - dist_text, text=str(self.num_images), fill="red", font=('Helvetica 10 bold'), anchor =  "sw", tag = "numbers")
                rect_id_num = self.canvas_gallery.create_rectangle(self.canvas_gallery.bbox(text_id_num), outline="blue", fill = "white", tag = "rect_numbers")
                # the frame for selected image, consisting of 4 lines because there is no opaque rectangle in tkinter
                north_west = (self.lastposition + dist_frame, dist_frame)
                north_east = (self.lastposition + image_width - dist_frame, dist_frame)
                south_west = (self.lastposition + dist_frame, image_height - dist_frame)
                south_east = (self.lastposition + image_width - dist_frame, image_height - dist_frame)
                line_north = self.canvas_gallery.create_line(north_west, north_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_east  = self.canvas_gallery.create_line(north_east, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_south = self.canvas_gallery.create_line(south_west, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_west  = self.canvas_gallery.create_line(north_west, south_west, dash=(1, 1), fill = "red", tags="imageframe")
                frameids = (line_north, line_east, line_south, line_west)
                
                if player is not None:
                    player.setId(id)
                mts = os.stat(file).st_mtime
                myimage = MyThumbnail(pimg, self, self.lastposition, self.lastposition + image_width, file, mts, showfile, id, \
                    text_id, rect_id, frameids, this_lineno, player, duplicate, self.canvas_gallery, self.dict_source_target[imagetype][file], self.t_text1)
                if file in self.dict_source_target_tooold[imagetype]: #start with EXCLUDE
                    myimage.setState(EXCLUDE, None, False)
                    myimage.set_tooold(True)
                    self.canvas_gallery.itemconfig(text_id, text="EXC OVW")
                Globals.thumbnails[imagetype].append(myimage)
                Globals.dict_thumbnails[imagetype][file] = myimage # damit können wir auf thumbnails mit den Sourcefilenamen zugreifen, z.B. für Duplicates
                self.dict_thumbnails_lineno[imagetype][str(this_lineno)] = myimage # damit können wir auf thumbnails mit der lineno in text widget zugreifen
                self.lastposition += image_width + Globals.gap 
                if myimage.getDuplicate() == 'j':
                    if imagetype.upper() == "JPEG":
                        print ("Duplicate: " + file)
                    text_id_dup = self.canvas_gallery.create_text(self.lastposition - Globals.gap - dist_text, dist_text, text="DUP", fill="green", font=('Helvetica 10 bold'), anchor =  tk.NE, tag = "dup_text")
                    rect_id_dup = self.canvas_gallery.create_rectangle(self.canvas_gallery.bbox(text_id_dup), outline="blue", fill = "white", tag = 'dup_rect')
                #print ("*** File " + file + " Type " + imagetype + " Lineno: " + str(self.dict_image_lineno[imagetype][file]))
                if process_type != 'VIDEO':
                    img.close()
            else: # wir haben kein Bild, ein Rechteck einfügen
                image_height = canvas_height
                image_width  = int(canvas_height * 4 / 3)
                id = self.canvas_gallery.create_rectangle(self.lastposition, 0, self.lastposition + image_width, canvas_height, fill="blue", tags = 'images')
                text_id = self.canvas_gallery.create_text(self.lastposition + dist_text, dist_text, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
                rect_id = self.canvas_gallery.create_rectangle(self.canvas_gallery.bbox(text_id), outline="blue", fill = "white")
                text_id_num = self.canvas_gallery.create_text(self.lastposition + dist_text, image_height - dist_text, text=str(self.num_images), fill="red", font=('Helvetica 10 bold'), anchor =  "sw", tag = "numbers")
                rect_id_num = self.canvas_gallery.create_rectangle(self.canvas_gallery.bbox(text_id_num), outline="blue", fill = "white", tag = "rect_numbers")
                # the frame for selected image, consisting of 4 lines because there is no opaque rectangle in tkinter
                north_west = (self.lastposition + dist_frame, dist_frame)
                north_east = (self.lastposition + image_width - dist_frame, dist_frame)
                south_west = (self.lastposition + dist_frame, image_height - dist_frame)
                south_east = (self.lastposition + image_width - dist_frame, image_height - dist_frame)
                line_north = self.canvas_gallery.create_line(north_west, north_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_east  = self.canvas_gallery.create_line(north_east, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_south = self.canvas_gallery.create_line(south_west, south_east, dash=(1, 1), fill = "red", tags="imageframe")
                line_west  = self.canvas_gallery.create_line(north_west, south_west, dash=(1, 1), fill = "red", tags="imageframe")
                frameids = (line_north, line_east, line_south, line_west)
                mts = os.stat(file).st_mtime
                myimage = MyThumbnail(0, self, self.lastposition, self.lastposition + image_width, file, mts, showfile, id, \
                    text_id, rect_id, frameids, this_lineno, player, duplicate, self.canvas_gallery, self.dict_source_target[imagetype][file], self.t_text1)
                if file in self.dict_source_target_tooold[imagetype]: #start with EXCLUDE
                    myimage.setState(EXCLUDE, None, False)
                    myimage.set_tooold(True)
                    self.canvas_gallery.itemconfig(text_id, text="EXC OVW")
                Globals.thumbnails[imagetype].append(myimage)
                Globals.dict_thumbnails[imagetype][file] = myimage
                self.dict_thumbnails_lineno[imagetype][str(this_lineno)] = myimage # damit können wir auf thumbnails mit der lineno in text widget zugreifen
                self.lastposition += image_width + Globals.gap 
                if myimage.getDuplicate() == 'j':
                    text_id_dup = self.canvas_gallery.create_text(self.lastposition - Globals.gap - dist_text, dist_text, text="DUP", fill="green", font=('Helvetica 10 bold'), anchor =  tk.NE, tag = "dup_text")
                    rect_id_dup =self.canvas_gallery.create_rectangle(self.canvas_gallery.bbox(text_id_dup), outline="blue", fill = "white", tag = 'dup_rect')
                #print ("*** File " + file + " Type " + imagetype + " Lineno: " + str(self.dict_image_lineno[imagetype][file]))
        self.canvas_gallery.tag_raise("dup_rect")
        self.canvas_gallery.tag_raise("dup_text")
        self.canvas_gallery.tag_raise("rect")
        self.canvas_gallery.tag_raise("text")
        self.canvas_gallery.tag_raise("line")
        self.canvas_gallery.tag_raise("rect_numbers")
        self.canvas_gallery.tag_raise("numbers")
        #self.canvas_gallery.tag_raise("imageframe")
        # the frame for selected image
        # Globals.gap haben wir einmal zuviel (fürs letzte) gezählt
        self.lastposition -= Globals.gap
        #print ("Canvas_gallery sichtbare Breite : " + str(self.canvas_gallery_width_visible))
        # damit wir am Ende auch bis zum letzten einzelnen Bild scrollen können, fügen wir ein Rechteck ein
        if len(Globals.thumbnails[imagetype]) > 0: 
            thumbnail = Globals.thumbnails[imagetype][-1]
            rect_len = self.canvas_gallery_width_visible - (thumbnail.getEnd() - thumbnail.getStart() + Globals.gap)
            self.canvas_gallery.create_rectangle(self.lastposition, 0, self.lastposition + rect_len, canvas_height, fill="yellow")
            self.canvas_gallery.config(scrollregion = self.canvas_gallery.bbox('all')) 
            self.canvas_gallery_width_images = self.canvas_gallery.bbox('images')[2]
            self.canvas_gallery_width_all    = self.canvas_gallery.bbox('all')[2]
            #print ("Canvas_gallery totale Breite(Images): " + str(self.canvas_gallery_width_images) + " totale Breite(All): " + str(self.canvas_gallery_width_all) \
            #    + " visible: " + str(self.canvas_gallery_width_visible) + " lastposition: " + str(self.lastposition))
        
        # Pfeiltasten für Scrollen einrichten
        self.canvas_gallery.focus_set()
        self.button_include.config(state = NORMAL)
        self.button_exclude.config(state = NORMAL)
        #print(Globals.dict_duplicates)
        self.historize_process()
        if len(Globals.thumbnails[imagetype]) > 0:
            self.filemenu.entryconfig(1, state=NORMAL)
            self.filemenu.entryconfig(3, state=NORMAL)
        
        else: # if no images available we dont need config files
            self.filemenu.entryconfig(1, state=DISABLED)
            self.filemenu.entryconfig(2, state=DISABLED)
            self.filemenu.entryconfig(3, state=DISABLED)
            self.filemenu.entryconfig(4, state=DISABLED)
        self.duplicates = False
        
        for mytarget in Globals.dict_duplicates[imagetype]:
            #print("Duplcate Key: " + mytarget) 
            mylist = Globals.dict_duplicates[imagetype][mytarget]
            if len(mylist) > 1: # es gibt 1...n Duplicates
                self.duplicates = True
                break
        
        if self.num_images > 0: # config makes no sense for zero images
            self.filemenu.entryconfig(5, state=NORMAL)
            # get the config-files for indir / type:
            indir = self.label_indir.cget('text')
                
            # finally update recent menu
            self.update_recent_menu(indir, imagetype)
        
        if self.duplicates:
            Globals.button_duplicates.config(state = NORMAL)
        else:
            Globals.button_duplicates.config(state = DISABLED)
        
        self.label_num.config(text = str(self.num_images))
        self.button_exec.config(state = NORMAL)
        self.write_cmdfile(imagetype)
        if self.win_messages is not None: # stop MyMessagesWindow-Objekt
            self.win_messages.close_handler()
            self.win_messages = None
        self.canvas_gallery.xview('moveto', 0)
        Globals.use_imagetype = False # only true if new sort from the radiobuttons required

    def state_gen_required(self):
        self.button_be.config(state = DISABLED) # browse / edit will throw error if not generate after chosing camera
        self.button_undo.config(state = DISABLED)    
        self.button_redo.config(state = DISABLED)
        self.clear_text(self.t_text1)
        self.canvas_gallery.delete("all")
        self.filemenu.entryconfig(1, state=DISABLED)
        self.button_exclude.config(state = DISABLED)
        self.button_include.config(state = DISABLED)
        self.button_exec.config(state = DISABLED)
        Globals.button_duplicates.config(state = DISABLED)
        #button_call.config(state = DISABLED)
        self.label_num.config(text = "0")
        self.clear_textbox(self.lb_gen)
        self.clear_dict_2nd(Globals.thumbnails, Globals.imagetype)
        self.clear_dict_2nd(Globals.dict_thumbnails, Globals.imagetype)

    def new_dir_in_xml(self, dirtype, max_dirs, dir_chosen, ts):
        do_del = True
        if dirtype == 'indir':
            d = DX.get_indirs(Globals.config_files_xml)
            if dir_chosen in d:
                do_del = False # existing dir, no cleanup
        elif dirtype == 'outdir':
            d = DX.get_outdirs(Globals.config_files_xml)
            if dir_chosen in d:
                do_del = False # existing dir, no cleanup
        # delete dir-entrie(s) from Globals.config_files_xml only if a new one has been selected
        print("do_del: " + str(do_del) + " dir_chosen: " + dir_chosen)
        if do_del: # 2 pass: in the first we delete entries with not existing dir, in the second existing dirs (if necessary)
            for loop in range(1,3): # 3 is excluded
                if dirtype == 'indir':
                    d = DX.get_indirs(Globals.config_files_xml)
                elif dirtype == 'outdir':
                    d = DX.get_outdirs(Globals.config_files_xml)
                # sort descending by usedate
                dict_dir_usedate = {}
                for ii in d:
                    dict_dir_usedate[ii] = d[ii]['usedate'] # dir -> usedate
                sorted_d = dict( sorted(dict_dir_usedate.items(), key=operator.itemgetter(1), reverse=True))
                list_dirs = []
                for tdir in sorted_d:
                    list_dirs.append(tdir)
                num_to_delete = len(list_dirs) - int(max_dirs) + 1 # +1 for we will make a new dir later. already deleted dirs are no more in DX.get_dirs 
                if loop == 1:
                    # delete only not existing dirs
                    if num_to_delete > 0:
                        ii = 0
                        for t in reversed(list_dirs): # now the oldest are on top
                            if not os.path.isdir(t):
                                if ii < num_to_delete:
                                    if dirtype == 'indir':
                                        DX.delete_indir(Globals.config_files_xml, t)
                                    elif dirtype == 'outdir':
                                        DX.delete_outdir(Globals.config_files_xml, t)
                                    ii += 1
                                else:
                                    break
                elif loop == 2:
                    # delete existing dirs if necessary
                    if num_to_delete > 0:
                        ii = 0
                        for t in reversed(list_dirs): # now the oldest are on top
                            if ii < num_to_delete:
                                if dirtype == 'indir':
                                    DX.delete_indir(Globals.config_files_xml, t)
                                elif dirtype == 'outdir':
                                    DX.delete_outdir(Globals.config_files_xml, t)
                                ii += 1
                            else:
                                break
        # will add xml node if not existing or update usedate if existing
        if dirtype == 'indir':
            DX.new_indir (Globals.config_files_xml, dir_chosen, "", "", ts, 0)
        if dirtype == 'outdir':
            DX.new_outdir(Globals.config_files_xml, dir_chosen, ts)

    def close_child_windows(self): #closes duplicates, fs-images and exec-windows    
        # cleanup
        self.stop_all_players() # should not continue running 
        if self.win_duplicates is not None: # stop MyDuplicates-Objekt
            self.win_duplicates.close_handler()
            self.win_duplicates = None
        # delete all fsimage by close-call
        for t in self.dict_file_image:
            u = self.dict_file_image[t]
            u.close_handler_external()
        self.dict_file_image = {}
        if self.win_messages is not None: # stop MyMessagesWindow-Objekt
            self.win_messages.close_handler()
            self.win_messages = None

    def get_templates(self):
        self.dict_templates = {}
        try:
            file = open(self.templatefile)
        except FileNotFoundError:
            print("File does not exist: " + self.templatefile)
        templates = file.read().replace('\n', '<<<NL>>>')
        #print(templates)
        regpattern = r'\[([^\]]+)\](.*?)\[/\1\]'
        list_t = re.findall(regpattern, templates)
        for ii in list_t:
            templatename = ii[0].upper()
            template     = ii[1]
            #print("templatename: " + templatename)
            #print(template)
            self.dict_templates[templatename] = template
        
        templates = re.sub(r'<<<NL>>>', '\n', templates)
        #print(templates)
            
    def button_exec_pressed(self):
        if self.win_messages is not None: # stop MyMessagesWindow-Objekt
            self.win_messages.close_handler()
            self.win_messages = None
        self.win_messages = DM.MyMessagesWindow(self, Globals.datadir, Globals.cmd_files_subdir, Globals.imagetype, self.dict_gen_files[Globals.imagetype], self.dict_gen_files_delete[Globals.imagetype], self.dict_gen_files_delrelpath[Globals.imagetype]) 

    def write_cmdfiles(self):
        for imagetype in self.dict_source_target:
            self.write_cmdfile(imagetype)

    def canvas_gallery_show(self, event):
        #print('bbox', self.canvas_gallery.bbox('images'))
        self.canvas_gallery.focus_set()

        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            item_id = thumbnail.getId()
            self.display_image(thumbnail)
            print("Text sroll to lineno: ", str(thumbnail.getLineno()))
            thumbnail.scrollTextToLineno()

    def canvas_image_show(self):
        print("Context menu show")
        self.canvas_gallery_show(self.event)

    def delay_decr(self, event): # speed +
        self.canvas_gallery.focus_set()
        delta = -5
        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                if delay + delta > 5:
                    player.setDelay(delay + delta)

    def delay_incr(self, event): # speed -
        self.canvas_gallery.focus_set()
        delta = 5
        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                if delay + delta < 200:
                    player.setDelay(delay + delta)

    def delay_deflt(self, event): # speed normal
        self.canvas_gallery.focus_set()
        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                player.setDelay(int(1000 / player.getFPS()))

    def xview(self, *args):
        #print (*args)
        s1 = 0.0
        s2 = 1.0
        scrolldelta = 0
        width_scrollbar = self.scroll_canvas_x.winfo_width()
        canvas_x = int(self.canvas_gallery.canvasx(0))
        canvas_y = int(self.canvas_gallery.canvasy(0))
        #print ("Scroll totale Breite(Images): " + str(self.canvas_gallery_width_images) + " totale Breite(All): " + str(self.canvas_gallery_width_all) \
        #    + " visible: " + str(self.canvas_gallery_width_visible)  + " canvas_x: " + str(canvas_x))
        slider_width = int((self.canvas_gallery_width_visible / self.canvas_gallery_width_all) * width_scrollbar)
        # aktuelle Scroll-Position des Canvas
        # aktuelle position der Scrollbar
        scrollposition = self.scroll_canvas_x.get()[0]
        
        # wenn wir die Pfeiltasten betätigen, wollen wir auf den Anfang des nächsten (vorherigen) Bildes scrollen.
        # wenn das aktuelle Bild nur teilweise zusehen ist, scrollen wir bei Linkstaste auf den Bildbeginn
        if len(args) == 3 and args[2] == "units":
            # den scrollbetrag auf die Größe des Bildes am linken Rand setzen
            thumbnail, index = self.get_thumbnail_by_position(canvas_x + 11, canvas_y)
            if thumbnail is not None:
                if int(args[1]) > 0:
                    scrolldelta = (thumbnail.getEnd() - canvas_x + Globals.gap)
                else:
                    if canvas_x - thumbnail.getStart() > 10: # Bild links abgeschnitten, an den Anfang scrollen
                        scrolldelta = (thumbnail.getStart() - canvas_x) # ist dann negativ, was wir ja wollen
                        #print("Bild links abgeschnitten, weil canvas_x = " + str(canvas_x) + " und Bildstart = " + str(thumbnail.getStart()))
                    else: #Bild ist vollständig zu sehen, also zurück zum nächsten
                        if index > 0: # es gibt einen Vorgänger
                            scrolldelta = (Globals.thumbnails[Globals.imagetype][index - 1].getStart()) - canvas_x
                            #print("Vorgänger ist: " + Globals.thumbnails[Globals.imagetype][index - 1].getFile() + " Start: " + str(Globals.thumbnails[Globals.imagetype][index - 1].getStart())\
                            #    + " canvas_x is: " + str(canvas_x) + " scrolldelta is: " + str(scrolldelta))
                
                new_canvas_x = canvas_x + scrolldelta
                # nach links scrollen machr keinen Sinn, wenn wir schon ganz links stehen, analog rechts
                if (int(args[1]) < 0 and canvas_x <= 0) or (int(args[1]) > 0 and new_canvas_x >= self.canvas_gallery_width_images):
                   return
                s2 = new_canvas_x / self.canvas_gallery_width_all
                s1 = (new_canvas_x - slider_width) / self.canvas_gallery_width_all
                #print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
            self.scroll_canvas_x.set(s1, s2)
            self.canvas_gallery.xview('moveto', s2)
        elif len(args) == 3 and args[2] == "page":
            #print("Args: ", str(args))
            # wenn wir eine Seite nach rechts scrollen sollen, soll das Bild, das jetzt ganz oder teilweise am rechten Bildrand zu sehen ist, am linken Bildrand erscheinen
            # wenn wir 1 Seite nach links scrollen sollen, soll der Vorgänger des Bildes vollständig am rechten Bildrand sichtbar sein. Wenn das dazu führt,
            # das das Bild am linken Bildrand abgeschnitten ist, scrollen wir auf dessen Anfang
            thumbnail_last = Globals.thumbnails[Globals.imagetype][-1]
            if int(args[1]) > 0: # scroll right
                # get thumbnail at left border
                posx = canvas_x
                dothumbnail = True
                while dothumbnail: #while because canvas_x could be on gap
                    thumbnail_current, index_current = self.get_thumbnail_by_position(posx, canvas_y)
                    if thumbnail_current is None:
                        posx += Globals.gap
                        #print("current retry...")
                    else: #found
                        dothumbnail = False
                # get thumbnail at right border
                posx = canvas_x + self.canvas_gallery_width_visible # start
                dothumbnail = True
                while dothumbnail:
                    thumbnail, index = self.get_thumbnail_by_position(posx, canvas_y)
                    if thumbnail is not None:
                        # we have to check, if whole canvas is filled by a very wide image (panorama), in which case we scroll by width of canvas
                        if thumbnail == thumbnail_current:
                            scrolldelta = self.canvas_gallery_width_visible
                        else:
                            tfile = thumbnail.getFile()
                            #print("Image at right: " + tfile + " last: " + thumbnail_last.getFile() + " last-end: " + str(thumbnail_last.getEnd()))
                            scrolldelta = min(thumbnail.getStart() - canvas_x, thumbnail_last.getStart() - canvas_x)
                            dothumbnail = False
                    else: # no thumbnail, we check if there are no more images at right
                        #print("scrolling right, end of last image: " + str(thumbnail_last.getFile()) + " " + str(thumbnail_last.getEnd()) + \
                        #  " End of canvas: " + str(canvas_x + self.canvas_gallery_width_visible))
                        if canvas_x + self.canvas_gallery_width_visible >= thumbnail_last.getEnd(): # no image at right position of canvas, do nothing
                            #print("*** reached the end of scrolling right, end of last image: " + str(thumbnail_last.getFile()) + " " + str(thumbnail_last.getEnd()) + " End of canvas: " + str(canvas_x + self.canvas_gallery_width_visible))
                            dothumbnail = False
                            return
                        else: #could be gap, so look at position - gap
                            posx -= Globals.gap
                #print("Scroll right 1 page, scrolldelta: " + str(scrolldelta))
                        
            else: # scroll left
                posx = canvas_x
                dothumbnail = True
                while dothumbnail: #while because canvas_x could be on gap
                    thumbnail_current, index_current = self.get_thumbnail_by_position(posx, canvas_y)
                    if thumbnail_current is None:
                        posx += Globals.gap
                        #print("current retry...")
                    else: #found
                        dothumbnail = False
                targetposition = max(thumbnail_current.getEnd() - self.canvas_gallery_width_visible, 0) # scroll to the target which is width_visible ahead of position of left
                posx = targetposition
                dothumbnail = True
                while dothumbnail: #while because targetposition could be on gap
                    thumbnail_target, index_target = self.get_thumbnail_by_position(posx, canvas_y)
                    if thumbnail_target is None:
                        posx += Globals.gap
                        #print("target retry...")
                    else: #found
                        dothumbnail = False
                tfile = thumbnail_target.getFile()
                cfile = thumbnail_current.getFile()
                #print("Target for scroll left: " + tfile + " position: " + str(targetposition) + " current at left border: " + cfile + " start: " + str(thumbnail_current.getStart()))
                # we have to check, if whole canvas is filled by a very wide image (panorama), in which case we scroll by width of canvas
                if thumbnail_target == thumbnail_current:
                    scrolldelta = -self.canvas_gallery_width_visible
                else:
                    # if leftmost visible would completely disappear by scroll left, target is nect thumbnail
                    a = targetposition - thumbnail_target.getStart() # actual scrollamount, we need the thumbnail acual at left side of cnvas
                    #b = canvas_x - thumbnail_current.getStart()
                    b = thumbnail_current.getEnd() - canvas_x # visible pixels
                    if b < a: # current would disappear by scrolling, so take the next image
                        if index_target + 1 < len(Globals.thumbnails[Globals.imagetype]):
                            thumbnail_target = Globals.thumbnails[Globals.imagetype][index_target + 1]
                            #print("*** thumbnail_current would disappear after scroll left")
                    scrolldelta = (thumbnail_target.getStart() - canvas_x)
                #print("Scroll left 1 page, scrolldelta: " + str(scrolldelta))

            new_canvas_x = canvas_x + scrolldelta
            # nach links scrollen machr keinen Sinn, wenn wir schon ganz links stehen, analog rechts
            if (int(args[1]) < 0 and canvas_x <= 0) or (int(args[1]) > 0 and new_canvas_x >= self.canvas_gallery_width_images):
               return
            s2 = new_canvas_x / self.canvas_gallery_width_all
            s1 = (new_canvas_x - slider_width) / self.canvas_gallery_width_all
            #print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
            self.scroll_canvas_x.set(s1, s2)
            self.canvas_gallery.xview('moveto', s2)
        else:
            #if (1 == 0):
                #return
            self.canvas_gallery.xview(*args)

    def text1_single(self, event): # synchronize text / gallery
        (row, col) = self.t_text1.index(tk.CURRENT).split(".")
        print(row, col)
        if Globals.imagetype != "" and row in self.dict_thumbnails_lineno[Globals.imagetype]:
            thumbnail = self.dict_thumbnails_lineno[Globals.imagetype][row]
            self.scrollToImage(thumbnail)
            thumbnail.scrollTextToLineno() # select this line

        # we dont need the following code anymore because we have a method to scroll canvas to the lineno associated with thumbnail
        # but here we have a usefull code to get the text line after mouse click
        lstart = "%d.0" % int(row)
        lend   = "%d.0 lineend" % int(row)
        # tindex = "%d.0, %d.0 lineend" % (lineno, lineno + 1)
        line    = self.t_text1.get(lstart, lend)
        regpattern = r'[\/\\]([^\/\\.]+)\.([^\/\\.]+)' 
        #print(self.t_text1.index(f"@{event.x},{event.y}"), self.t_text1.index("current"), line)
        
    def text1_double(self, event): # synchronize text / gallery and display FSImage 
        (row, col) = self.t_text1.index(tk.CURRENT).split(".")
        print(row, col)
        if Globals.imagetype != "" and row in self.dict_thumbnails_lineno[Globals.imagetype]:
            thumbnail = self.dict_thumbnails_lineno[Globals.imagetype][row]
            if thumbnail is not None:
                self.scrollToImage(thumbnail)
                thumbnail.scrollTextToLineno() # select this line
                self.display_image(thumbnail)
        return("break")  # should stop event processing but doesn't  

    def text1_key(self, event): # called for every keyboard input
        (row, col) = self.t_text1.index(tk.INSERT).split(".")
        #print("Event x: ", event.x, " Event y: ",event.y)
        #print("Event is " + str(event))
        print("Key pressed: ")
        print(event.char, event.keysym, event.keycode)
        print(row, col)
        if event.keysym == 'Up' or event.keysym == 'Down':
            if Globals.imagetype != "" and row in self.dict_thumbnails_lineno[Globals.imagetype]:
                thumbnail = self.dict_thumbnails_lineno[Globals.imagetype][row]
                self.scrollToImage(thumbnail)
                thumbnail.scrollTextToLineno() # select this line
        self.t_text1.mark_set(tk.INSERT, "%d.%d" % (int(row), 0))


    def scrollToImage(self, thumbnail): # scroll to start-position of thumbnail identified by filename
        s1 = 0.0
        s2 = 1.0
        width_scrollbar = self.scroll_canvas_x.winfo_width()
        slider_width = int((self.canvas_gallery_width_visible / self.canvas_gallery_width_all) * width_scrollbar)
        # aktuelle Scroll-Position des Canvas
        canvas_x = self.canvas_gallery.canvasx(0)
        canvas_y = self.canvas_gallery.canvasy(0)
        # aktuelle position der Scrollbar
        scrollposition = self.scroll_canvas_x.get()[0]
        
        # den scrollbetrag auf die Größe des Bildes am linken Rand setzen
        if thumbnail is not None:
            scrolldelta = (thumbnail.getEnd() - canvas_x + Globals.gap)
            new_canvas_x = thumbnail.getStart()
            s2 = new_canvas_x / self.canvas_gallery_width_all
            s1 = (new_canvas_x - slider_width) / self.canvas_gallery_width_all
            #print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
        self.scroll_canvas_x.set(s1, s2)
        self.canvas_gallery.xview('moveto', s2)

    def display_image(self, thumbnail):
        file = thumbnail.getShowfile()
        # wenn das Bild schon in einem Fenster angezeigt wird, dann verwenden wir dieses
        if file in self.dict_file_image:
            print ("FSImage exists for file: " + file)
            fs_image = self.dict_file_image[file]
            player = fs_image.getPlayer()
            if player is not None: # this is a video
                print ("FSImage restart file: " + file)
                player.restart()
                fs_image.setPlaystatus('play') # Status, Buttontext
        else: # ein neues Objekt anlegen und in dict_file_image eintragen
            if file != 'none':
                print ("FSImage does not exist for file: " + file)
                fs_image = FS.MyFSImage(file, thumbnail, self.dict_file_image, self, "", "Include", "Exclude", "Included", "Excluded", self.debug)
                self.dict_file_image[file] = fs_image

    def show_context_menu(self, event):
        # das Event müssen wir speichern, da die eigenlichen Funktionen die x und y benötigen
        self.event = event
        # falls wir keine anzeigbare Datei haben, müssen wir show-Item disablen
        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            if thumbnail.getImage() == 0:
                print(" No Image availabl for " + thumbnail.getFile())
                self.context_menu.entryconfig(1, state="disabled")
            else:
                self.context_menu.entryconfig(1, state="normal")
            if thumbnail.getState() == INCLUDE:
                self.context_menu.entryconfig(0, label = "Exclude " + thumbnail.getFile())
            else:
                self.context_menu.entryconfig(0, label = "Include " + thumbnail.getFile())
        self.context_menu.entryconfig(1, label = "Show " + thumbnail.getFile())
        self.context_menu.post(event.x_root, event.y_root)

    def canvas_button_1(self, event):  # we need an event to set focus to canvas in order for the arrow keys to work and we scroll text box
        self.canvas_gallery.focus_set()
        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            item_id = thumbnail.getId()
            print("Text sroll to lineno: ", str(thumbnail.getLineno()))
            thumbnail.scrollTextToLineno()

    def canvas_gallery_exclude(self, event):
        #print('bbox', self.canvas_gallery.bbox('images'))
        self.canvas_gallery.focus_set()

        canvas_x = self.canvas_gallery.canvasx(event.x)
        canvas_y = self.canvas_gallery.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            linenew = ""
            #print("State is: " + str(thumbnail.getState()))
            if thumbnail.getState() == INCLUDE:
                thumbnail.setState(EXCLUDE)
            else: # toggle to not exclude, delete Item
                thumbnail.setState(INCLUDE)
        self.historize_process()
        
    def Button_exclude_all(self, *args):
        for thumbnail in Globals.thumbnails[Globals.imagetype]:
            if thumbnail.getState() == INCLUDE:
                thumbnail.setState(EXCLUDE, None, False)
        self.historize_process()
        self.write_cmdfile(Globals.imagetype)
                
    def Button_include_all(self, *args):
        for thumbnail in Globals.thumbnails[Globals.imagetype]:
            if thumbnail.getState() == EXCLUDE:
                thumbnail.setState(INCLUDE, None, False)
        self.historize_process()
        self.write_cmdfile(Globals.imagetype)
     
    def canvas_image_exclude(self): # used for exclude and include
        print("Context menu exlude")
        self.canvas_gallery_exclude(self.event)

    def canvas_video_restart(self):
        print("Context menu restart")
        self.canvas_gallery.focus_set()

        canvas_x = self.canvas_gallery.canvasx(self.event.x)
        canvas_y = self.canvas_gallery.canvasy(self.event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # this is a video
                player.restart()
                

    # Undo /Redo Funktionen
    def process_undo(self, event):
        print("ctrl_z pressed.")
        rc, p_now, p_before = self.UR.process_undo()
        if not rc: # undo was not possible
            messagebox.showinfo("UNDO", "no further processes which can be undone", parent = self.root)
        else:
            self.apply_process_id(p_now, p_before)
            self.endis_buttons()

    def process_redo(self, event):
        print("ctrl_y pressed.")
        rc, p_now, p_before = self.UR.process_redo()
        if not rc:
            messagebox.showinfo("REDO", "no further processes which can be redone", parent = self.root)
        else:
            self.apply_process_id(p_now, p_before)
            self.endis_buttons()

    def button_undo_h(self, event = None):
        print("Button Undo pressed")
        self.process_undo(event)
        
    def button_redo_h(self, event = None):
        print("Button Redo pressed")
        self.process_redo(event)

    def button_undo_pressed(self):
        self.process_undo((0, 0))
        
    def button_redo_pressed(self):
        self.process_redo((0, 0))
    def endis_buttons(self): # disable / enable buttons depending on processids
        rc_undo, rc_redo = self.UR.endis_buttons()
        if rc_undo:
            self.button_undo.config(state = NORMAL)
        else:
            self.button_undo.config(state = DISABLED)
        if rc_redo:
            self.button_redo.config(state = NORMAL)
        else:
            self.button_redo.config(state = DISABLED)

    def apply_process_id(self, process_id, processid_predecessor):
        # set thumbnail-states according actual processid
        i = 0
        for thumbnail in Globals.thumbnails[Globals.imagetype]:
            thumbnail.setState(self.dict_status_image[process_id][i], None, False)
            i += 1
        self.update_button_state()
        self.write_cmdfile(Globals.imagetype)
        
    def historize_process(self):
        self.UR.historize_process()
        processid_akt = self.UR.get_processid_akt()
        # wir bilden jetzt zu der aktuellen processid eine Liste der states der thumbnails
        self.clear_dict_2nd(self.dict_status_image, processid_akt)
        self.dict_status_image[processid_akt] = []
        for thumbnail in Globals.thumbnails[Globals.imagetype]:
            self.dict_status_image[processid_akt].append(thumbnail.getState())
        self.update_button_state() # refer to function comment
        
        # UNDO / REDO disabeln, wenn Aktion nicht möglich, weil es keine frühere / spätere Bearbeitung gibt
        self.endis_buttons()

    def update_button_state(self): # enabled / disabled include / Exclude buttons

        #wir ermitteln, ob alle include oder exlude haben. In diesem Falls
        # disabeln wir exclude / Include All, was ja keinen Sinn hat und ggf.
        # die Historie unötig aufbläht
        count_states = 0
        count_exclude = 0
        count_include = 0
        for thumbnail in Globals.thumbnails[Globals.imagetype]:
            if thumbnail.getState() == EXCLUDE:
                count_exclude += 1
            if thumbnail.getState() == INCLUDE:
                count_include += 1
            count_states += 1
        if count_exclude == count_states:
            self.button_exclude.config(state = DISABLED)
        else:
            self.button_exclude.config(state = NORMAL)
        if count_include == count_states:
            self.button_include.config(state = DISABLED)
        else:
            self.button_include.config(state = NORMAL)
    # Ende undo / redo-Funktionen

    def button_duplicates(self):
        for mytarget in Globals.dict_duplicates[Globals.imagetype]:
            #print("Duplcate Key: " + mytarget) 
            mylist = Globals.dict_duplicates[Globals.imagetype][mytarget]
            if len(mylist) > 1: # es gibt 1...n Duplicates
                print("Duplcate Key: " + mytarget)
                for mysource in mylist:
                    print("   " + mysource)
        self.win_duplicates = MyDuplicates(self) 
       
    def menu_cameras_edit(self):
        self.win_camera = MyCameraTreeview(self) 

    def menu_diatisch(self):
        # if jpeg build list of not excluded imagefiles and call diatisch
        if not self.win_diatisch: # run only once
            if Globals.imagetype == "JPEG":
                list_diatisch = []
                for i in Globals.dict_thumbnails[Globals.imagetype]:
                    t = Globals.dict_thumbnails[Globals.imagetype][i]
                    if t.getState() == INCLUDE:
                        list_diatisch.append(i)
                if list_diatisch:
                    Globals.list_result_diatisch = []
                    self.win_diatisch = DIAT.Diatisch(self.debug, None, list_diatisch, Globals.list_result_diatisch, self.diatisch_callback) # Y is for debug yes
                else:
                    messagebox.showinfo("Diatisch", "no images available for Diatisch")
            else:
                messagebox.showinfo("Diatisch", "only jpeg supported by Diatisch")

    def diatisch_callback(self): #calback-Funktion called from diatisch on closing
        print("callback from diatisch")
        for i in Globals.list_result_diatisch:
            print(i)
        # select Diatisch_camera
        self.lb_camera.selection_clear(0, END)
        idx_diatisch = int(self.dict_lb_camera_index[self.diatisch_camera_name])
        self.lb_camera.selection_set(idx_diatisch)
        self.clear_textbox(self.o_camera)
        self.insert_text(self.o_camera, self.diatisch_camera_name)
        self.Press_generate()
        self.win_diatisch = None

    def on_window_destroy(self, a):
        a = 1
        #print ("Destroy called.")
        #self.root.instance.destroy()
        #self.root.withdraw()

    def on_cb_num_toggle(self):
        if self.cb_num_var.get():
            self.canvas_gallery.itemconfigure("rect_numbers", state="normal")
            self.canvas_gallery.itemconfigure("numbers", state="normal")
        else:
            self.canvas_gallery.itemconfigure("rect_numbers", state="hidden")
            self.canvas_gallery.itemconfigure("numbers", state="hidden")


    def clear_textbox(self, o):
        o.delete(0, 'end')
        
    def clear_dict_2nd(self, d, key):
        # clears dict or list on 2nd level
        if key in d:
            d[key].clear()
        
    def clear_text(self, o):
        o.delete(1.0, 'end')

    def insert_text(self, o, str):
        o.insert('end', str)

    def get_thumbnail_by_position(self, canvas_x, canvas_y):
        index = -1
        found = False
        if Globals.imagetype != "":
            for thumbnail in Globals.thumbnails[Globals.imagetype]:
                start = thumbnail.getStart()
                end   = thumbnail.getEnd()
                if (canvas_x >= start and canvas_x <= end):
                    index = Globals.thumbnails[Globals.imagetype].index(thumbnail)
                    #print("retrieved " + thumbnail.getFile() + " Index: " + str(index))
                    found = True
                    break
            if not found:
                thumbnail = None
                index = None
        else:
            thumbnail = None
            index = None
        return (thumbnail, index)

    def get_camera_xml(self): # returns dict with all cameras, types and suffixes
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
        cameraname = self.diatisch_camera_name
        ctype      = "JPEG"
        suffix     = "JPG"
        rc = DX.new_camera_type_suffix(Globals.config_files_xml, cameraname, ctype, suffix, ts) 
        suffix     = "JPEG"
        rc = DX.new_camera_type_suffix(Globals.config_files_xml, cameraname, ctype, suffix, ts) 
        #ctype      = "VIDEO"
        #suffix     = "MOV"
        #rc = DX.new_camera_type_suffix(Globals.config_files_xml, cameraname, ctype, suffix, ts) 
        # dateimeister_config_xml.py returns suffixes as list we need them as a comma separated string
        dict_cameras = {}
        dict_cameras = DX.get_cameras_types_suffixes(Globals.config_files_xml)
        #print("Cameras: " + str(dict_cameras))
        dict_t = {}
        for camera in dict_cameras:
            dict_t[camera] = {}
            type_num = 0
            for type in dict_cameras[camera]:
                type_num += 1
                suffixes = ", ".join(dict_cameras[camera][type])
                dict_t[camera][type] = suffixes
                print("Camera: " + camera + " Type: " + type + " Suffixes: " + suffixes)
                if len(suffixes) == 0:
                    messagebox.showerror("INIT", "Camera " + camera + " type " + type + " no suffix defined")
                    exit()
            if type_num == 0:
                messagebox.showerror("INIT", "Camera " + camera + " no type defined")
                exit()

        dict_s = {}
        dict_s = DX.get_subdirs(Globals.config_files_xml)
        for imagetype in dict_s:
            print("Subdir {:s}, {:s}".format(imagetype, dict_s[imagetype]))
        
        dict_pi = {}
        dict_pi = DX.get_process_image(Globals.config_files_xml)
        for t in dict_pi:
            print("Process Image  {:s}, {:s}".format(t, dict_pi[t]))
        
        self.lb_camera.delete(0, END)
        index = 0
        for key in dict_t:
            self.lb_camera.insert(END, key)
            self.dict_lb_camera_index[key] = index
            index += 1
        self.lb_camera.selection_set(END)

        return dict_t, dict_s, dict_pi

    def stop_all_players(self):
        # stop all video players
        if Globals.imagetype is not None and Globals.imagetype != "":
            for imagetype in self.dict_subdirs:
                if imagetype in Globals.thumbnails:
                    for t in Globals.thumbnails[Globals.imagetype]: # stop all running players
                        thisplayer = t.getPlayer()
                        if thisplayer is not None:
                            if thisplayer.getRun(): # running
                                thisplayer.pstop()
                                #print ("Stop player for: " + t.getFile() + " playertype: " + imagetype)
     
    def write_cmdfile(self, imagetype):
        ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
        template_copy       = self.dict_templates["COPY"]
        template_delete     = self.dict_templates["DELETE"]
        template_delrelpath = self.dict_templates["DELRELPATH"]
        template_empty      = self.dict_templates["EMPTY"]
        header = Globals.uncomment + ' generated by dateimeister ' + ts + '\n'
        # copy files
        cmd_file_full = self.dict_gen_files[imagetype] # filename was already built by generate()
        thiscmdfile = open(cmd_file_full, 'w')
        thiscmdfile.write(header) 
        dict_files = self.dict_source_target[imagetype]
        for sourcefile in dict_files:
            comment = ""
            do_include = False
            #print(imagetype + ', ' + sourcefile)
            if imagetype in Globals.dict_thumbnails and sourcefile in Globals.dict_thumbnails[imagetype]:
                thumbnail = Globals.dict_thumbnails[imagetype][sourcefile]
                if thumbnail.getState() == EXCLUDE:
                    comment = Globals.uncomment
                else: # we have to incluse this file even if it is too old
                    do_include = True
            # we also have to check if file is too old but only if include us not requqested by thumbnail (manually included)
            if do_include == False:
                if imagetype in self.dict_source_target_tooold and sourcefile in self.dict_source_target_tooold[imagetype]:
                    comment = Globals.uncomment 
            targetfile = dict_files[sourcefile]
            if self.platform == "WINDOWS":
                targetfile = re.sub(r'/', '\\\\', targetfile) # replace / by \
            elif self.platform == "UNIX":
                targetfile = re.sub(r'\\', '/', targetfile) # replace \ by /
            str_ret = template_copy
            str_ret = str_ret.replace('<source>', sourcefile)
            str_ret = str_ret.replace('<target>', targetfile)
            str_ret = re.sub(r'<<<NL>>>', '\n', str_ret) # reconstruct newline in template
            thiscmdfile.write(comment + str_ret + '\n')
        thiscmdfile.close()

        # delete files
        cmd_file_full = self.dict_gen_files_delete[imagetype] # filename was already built by generate()
        thiscmdfile = open(cmd_file_full, 'w')
        thiscmdfile.write(header) 
        dict_files = self.dict_source_target[imagetype]
        for sourcefile in dict_files:
            comment = ""
            do_include = False
            #print(imagetype + ', ' + sourcefile)
            if imagetype in Globals.dict_thumbnails and sourcefile in Globals.dict_thumbnails[imagetype]:
                thumbnail = Globals.dict_thumbnails[imagetype][sourcefile]
                if thumbnail.getState() == EXCLUDE:
                    comment = Globals.uncomment
                else: # we have to incluse this file even if it is too old
                    do_include = True
            # we also have to check if file is too old but only if include us not requqested by thumbnail (manually included)
            if do_include == False:
                if imagetype in self.dict_source_target_tooold and sourcefile in self.dict_source_target_tooold[imagetype]:
                    comment = Globals.uncomment 
            targetfile = dict_files[sourcefile]
            if self.platform == "WINDOWS":
                targetfile = re.sub(r'/', '\\\\', targetfile) # replace / by \
            elif self.platform == "UNIX":
                targetfile = re.sub(r'\\', '/', targetfile) # replace \ by /
            str_ret = template_delete
            str_ret = str_ret.replace('<source>', sourcefile)
            str_ret = str_ret.replace('<target>', targetfile)
            str_ret = re.sub(r'<<<NL>>>', '\n', str_ret) # reconstruct newline in template
            thiscmdfile.write(comment + str_ret + '\n')
        thiscmdfile.close()
        
        # delrelpath files : remove addrelpath-generated files, but only if empty
        cmd_file_full = self.dict_gen_files_delrelpath[imagetype] # filename was already built by generate()
        thiscmdfile = open(cmd_file_full, 'w')
        thiscmdfile.write(header)
        outdir = self.dict_outdirs[imagetype]
        # for cmd we need backslash, for Unix slash
        if self.platform == "WINDOWS":
            outdir = re.sub(r'/', '\\\\', outdir) # replace / by \
        elif self.platform == "UNIX":
            outdir = re.sub(r'\\', '/', outdir) # replace \ by /
        stroutfile = "@set OUTDIR=" + outdir + '\n'
        thiscmdfile.write(stroutfile) 
        for relpath in self.dict_relpath[imagetype]:
            comment = ""
            str_ret = template_delrelpath
            if self.platform == "WINDOWS":
                str_ret = str_ret.replace('<trenner>', '\\')
                relpath = re.sub(r'/', '\\\\', relpath) # replace / by \
            elif self.platform == "UNIX":
                str_ret = str_ret.replace('<trenner>', '/')
                relpath = re.sub(r'\\', '/', relpath) # replace \ by /
            str_ret = str_ret.replace('<relpath>', relpath)
            str_ret = re.sub(r'<<<NL>>>', '\n', str_ret) # reconstruct newline in template
            thiscmdfile.write(comment + str_ret + '\n')
        # add the script
        str_ret = template_empty
        str_ret = re.sub(r'<<<NL>>>', '\n', str_ret) # reconstruct newline in template
        l = str_ret.split('\n')
        for ii in l:
           thiscmdfile.write(ii + '\n') 
        thiscmdfile.close()

# #############################################################
if __name__ == '__main__':
    '''Main entry point for the application.'''
    argParser = argparse.ArgumentParser()
    argParser.add_argument("-d", "--debug", help="Debug Mode")
    args = argParser.parse_args()
    print("args=%s" % args)
    print("args.debug=%s" % args.debug)
    debug = 'N'
    if args.debug:
        debug = args.debug.upper()
    root = tk.Tk()
    app = Dateimeister_support(root, debug)

 





