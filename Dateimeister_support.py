#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    Oct 14, 2023 03:20:47 PM CEST  platform: Windows NT

import sys
import os
import configparser 
import re
import locale
import ctypes
import time
import operator
import threading
import copy
import subprocess

import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
from tkinter import filedialog as fd
from tkinter import messagebox
from tkinter import Scrollbar
from tkinter import ttk
from tkinter import Frame
from tkinter import Label
from tkinter import Canvas
from tkinter import Menu
from time import gmtime, strftime

import xml.etree.ElementTree as ET
    
from PIL import Image, ImageTk
from datetime import datetime, timezone

import Dateimeister
import dateimeister_config_xml as DX
import dateimeister_video as DV
#from Dateimeister import ToolTip

_debug = True # False to eliminate debug printing from callback functions.
_index_of_leftmost = -1
_canvas_gallery_width_visible = 0
_canvas_gallery_width_images = 0
_canvas_gallery_width_all = 0
_screen_width = 0
_screen_height = 0
_image = 0
_dict_process_image = {}
_dict_firstname_fullname = {}
_imagetype = ""
_list_processids = []
_processid_akt = 0
_processid_high = 0
_processid_low = 999999
_tooltiptext = ""
_use_camera_prefix = True
_dict_thumbnails = {}
_dict_thumbnails_lineno = {}
_dict_thumbnails_duplicates = {}
_dict_duplicates = {}
_dict_duplicates_sourcefiles = {}
_duplicates = False
_dict_file_image = {} # key: Imagefilename, value MyFSImage-Objekt, mit fullscale Image, canvas id, window...
_win_duplicates = None
_win_messages = None

from enum import Enum
class state(Enum):
    INCLUDE = 1
    EXCLUDE = 2

class MyThumbnail:
    #image = "" # hier stehen Klassenvariablen, im Gegensatz zu den Instanzvariablen

    # The class "constructor" - It's actually an initializer 
    def __init__(self, image, start, end, file, showfile, id, text_id, rect_id, lineno, player, duplicate, canvas, targetfile, \
      text = None, parent = None, tooold = False):
        self.image = image
        self.start = start
        self.end   = end
        self.file = file
        self.showfile = showfile
        self.image_id = id
        self.state_id_text = text_id
        self.state_id_rect = rect_id
        self.lineno = lineno
        self.player = player 
        self.targetfile = targetfile
        self.fsimage = None
        self.dupl = None
        self.state = state.INCLUDE
        self.canvas = canvas
        self.text = text
        self.parent = parent
        self.duplicate = duplicate
        self.tooold = tooold
        self.setState(self.state)
        
    def getImage(self):
        #print("*** retrieve Image ")
        return self.image    

    def getStart(self):
        return self.start    

    def getEnd(self):
        return self.end    

    def getFile(self):
        return self.file    
    def getShowfile(self):
        return self.showfile    

    def setId(self, id):
        self.image_id = id    
    def getId(self):
        return self.image_id    

    def set_tooold(self, tooold):
        self.tooold = tooold    
    def get_tooold(self):
        return self.tooold    

    def getDuplicate(self):
        return self.duplicate    

    def setState(self, state, caller = None):
        if state != self.state:
            state_changed = True
        else:
            state_changed = False
        self.state = state # neuer Status
        if self.text is not None:
            # change line in text
            # die Textzeile beschaffen
            lstart = "%d.0" % (self.lineno)
            lend   = "%d.0 lineend" % (self.lineno)
            # tindex = "%d.0, %d.0 lineend" % (lineno, lineno + 1)
            line    = self.text.get(lstart, lend)
            #print ("Retrieved Textline: " + line)
        if self.state == state.INCLUDE:
            self.canvas.itemconfigure(self.state_id_text, state='hidden')
            self.canvas.itemconfigure(self.state_id_rect, state='hidden')
            if self.text is not None:
                linenew = line
                linenew = re.sub(rf"{_uncomment}", '', linenew)
                self.text.delete(lstart, lend) # without delete / insert highlighttag does not work. Bug in Python?
                self.text.insert(lstart, line)
                self.text.tag_add("include", lstart, lend) # normal foreground
                self.scrollTextToLineno()
        if self.state == state.EXCLUDE and state_changed:
            self.canvas.itemconfigure(self.state_id_text, state='normal')
            self.canvas.itemconfigure(self.state_id_rect, state='normal')
            if self.text is not None:
                linenew = line
                linenew = re.sub(r"^", f"{_uncomment}", linenew)
                self.text.delete(lstart, lend) # without delete / insert highlighttag does not work. Bug in Python?
                self.text.insert(lstart, line)
                self.text.tag_add("exclude", lstart, lend) # exclude foreground(grey)
                self.scrollTextToLineno()
        if self.parent is not None:
            self.parent.setState(state, caller)
        if self.fsimage is not None:
            self.fsimage.exclude_call(state) # synchronisiert das FSImge, falls vorhanden
            print("FSImage Exclude-Call")
        if self.dupl is not None:
            #print("dupl is: " + str(self.dupl) + "caller is: " + str(caller))
            if caller != self.dupl: # to avoid loop
                self.dupl.exclude_call(self, state) # synchronisiert das Duplicate, falls vorhanden
                #print("Duplicate Exclude-Call")
    def getState(self):
        return self.state   

    def getLineno(self):
        return self.lineno    

    def setLineno(self, lineno):
        self.lineno = lineno 
        
    def scrollTextToLineno(self): # reset all lines to "unselect", keep exclude / include Info
        for t in thumbnails[_imagetype]:
            lineno = t.getLineno()
            lstart = "%d.0" % (lineno)
            lend   = "%d.0 lineend" % (lineno)
            line    = self.text.get(lstart, lend) # text widget is the same for all thumbnails
            # without delete / insert tag_add will not work. Bug in tkinter?
            self.text.delete(lstart, lend) # without delete / insert highlighttag does not work. Bug in Python?
            self.text.insert(lstart, line)
            #print("try to select line " + line)
            if t.getState() == state.INCLUDE:
                self.text.tag_add("normal_include", lstart, lend)
            else:
                self.text.tag_add("normal_exclude", lstart, lend)
        # now set tag for this thumbnail
        lstart = "%d.0" % (self.lineno)
        lend   = "%d.0 lineend" % (self.lineno)
        line    = self.text.get(lstart, lend)
        # without delete / insert tag_add will not work. Bug in tkinter?
        self.text.delete(lstart, lend) # without delete / insert highlighttag does not work. Bug in Python?
        self.text.insert(lstart, line)
        #print("try to select line " + line)
        if self.getState() == state.INCLUDE:
            self.text.tag_add("select_include", lstart, lend)
        else:
            self.text.tag_add("select_exclude", lstart, lend)
        self.text.see(lstart)
        lineinfo = self.text.dlineinfo(lstart)
        self.text.yview_scroll(lineinfo[1], 'pixels' )

    def register_FSimage(self, fsimage):
        self.fsimage = fsimage

    def register_Dupl(self, dupl):
        self.dupl = dupl

    def getPlayer(self):
        return self.player   

    def getTargetfile(self):
        return self.targetfile   

    def __del__(self):
        if self.player is not None:
            self.player.pstop()
            del self.player
        width = self.end -self.start 
        print("*** Deleting MyThumbnail-Objekt. " + self.file + " lineno in cmdfile " + str(self.lineno))

# hier speichern wir die full-size-Bilder
class MyFSImage:

    # The class "constructor" - It's actually an initializer 
    def __init__(self, file, thumbnail, dict_caller): # close_handler has to delete self from the dict main or duplicate
        self.thumbnail = thumbnail
        self.player = None
        if thumbnail.getPlayer() is None: # still image
            self.image  = Image.open(file)
        self.file = file
        self.dict_caller = dict_caller
        # register at thumbnail, so it can call us for reacting to state
        self.thumbnail.register_FSimage(self)
        # Create secondary (or popup) window.
        self.root2 = tk.Toplevel()
        self.w2 = Dateimeister.Toplevel2(self.root2)
        self.f = self.w2.Canvas_image
        if self.thumbnail.getState() == state.INCLUDE:
            self.w2.Button_exclude.config(text = "Exclude")
            self.w2.Label_status.config(text = "Included")
        else: # toggle to not exclude
            self.w2.Button_exclude.config(text = "Include")
            self.w2.Label_status.config(text = "Excluded")
        # zur Behandlung von Events brauchen wir den Imagefile-Namen. Darüber kommen wir an das Window und
        # das Image selbst. Das ist erforderlich, weil wir ja mehrere Fenster haben können
        # kurz gesagt: mit dieser Methode kann man Parameter an den Handler übergeben
        self.w2.Button_fit.config(command = self.fit_handler)
        self.w2.Button_fscale.config(command = self.fscale_handler)
        self.w2.Button_exclude.config(command = self.exclude_handler)
        self.w2.Button_pp.config(command = self.pp_handler)
        self.w2.Button_restart.config(command = self.restart_handler)
        self.w2.Scale_fps.config(command = self.setFps)
        self.f.bind("<MouseWheel>", self.mousewheel_handler)
        self.root2.protocol("WM_DELETE_WINDOW", self.close_handler)

        self.root2.title(file)
        width,height=_screen_width,_screen_height
        v_dim=str(width)+'x'+str(height)
        self.root2.geometry(v_dim)
        self.root2.resizable(False, False)

        # Scrollbars
        self.V_I = Scrollbar(self.f)
        self.V_I.config(command=self.f.yview)
        self.f.config(yscrollcommand=self.V_I.set)  
        self.H_I = Scrollbar(self.f, orient = HORIZONTAL)
        self.H_I.config(command=self.f.xview)
        self.f.config(xscrollcommand=self.H_I.set)
        if thumbnail.getPlayer() is None:
            self.image.close
        self.zoomfaktor = 1.0
        self.V_I.pack(side=RIGHT, fill=Y)
        self.H_I.pack(side=BOTTOM, fill=BOTH)
        # Bind keys to canvas for scrolling
        self.f.bind("<Left>",  lambda event: self.scrollx(-1, "unit"))
        self.f.bind("<Right>", lambda event: self.scrollx( 1, "unit"))
        self.f.bind("<Up>",    lambda event: self.scrolly(-1, "unit"))
        self.f.bind("<Down>",  lambda event: self.scrolly( 1, "unit"))

        self.zoomfaktor = 1.0 # wir fangen immer mit dem Bild in voller Auflösung an.
        self.f.focus_set()
        if thumbnail.getPlayer() is None: # still image
            self.image_zoom(self.zoomfaktor)
            self.player = None
            self.w2.Button_pp.place_forget()
            self.w2.Button_restart.place_forget()
            self.w2.Scale_fps.place_forget()
            self.w2.Label_fps.place_forget()
        else: #video, we need a new one the existing is for playing in thumbnal
            self.w2.Button_fit.place_forget()
            self.w2.Button_fscale.place_forget()
            self.H_I.pack_forget()
            self.V_I.pack_forget()
            self.f.update()
            self.player   = DV.VideoPlayer(self.root2, self.file, self.f, self.f.winfo_width(), self.f.winfo_height(), 0)
            self.image_width, self.image_height, self.pimg = self.player.get_pimg()  
            print(file, " height / width: ",  self.image_width, self.image_height)
            self.id = self.f.create_image(0, 0, anchor='nw',image = self.pimg, tags = 'images')
            self.f.tag_raise("text")
            self.f.tag_raise("line")
            self.player.setId(self.id)
            self.player.pstart()
            self.player.setDelay(delay_default)
            self.w2.Scale_fps.set(1000 / delay_default)
            self.playerstatus = 'play'
            self.w2.Button_pp.config(text = 'pause')
    def getPlayer(self):
        return self.player
    
    def scrollx(self, amount, unit):
        #print("scroll command: " + str(amount) + ' ' + unit)
        self.f.xview_scroll(amount, unit)
        return "break"
    def scrolly(self, amount, unit):
        #print("scroll command: " + str(amount) + ' ' + unit)
        self.f.yview_scroll(amount, unit)
        return "break"
     
    def fit_handler(self):
        self.button_fit()

    def pp_handler(self):
        if self.playerstatus == 'play': 
            self.player.pstop()
            self.playerstatus = 'pause'
            self.w2.Button_pp.config(text = 'play')
        else:
            self.player.pstart()
            self.playerstatus = 'play'
            self.w2.Button_pp.config(text = 'pause')

    def setPlaystatus(self, newstatus):
        if newstatus == 'play': 
            self.playerstatus = 'play'
            self.w2.Button_pp.config(text = 'pause')
        else:
            self.playerstatus = 'pause'
            self.w2.Button_pp.config(text = 'play')

    def restart_handler(self):
        self.player.restart()
        self.setPlaystatus('play')

    def fscale_handler(self):
        self.image_zoom(1) # damit bringt image_zoom das Foto in höchster Auflösung zur Anzeige
        
    def setFps(self, value):
        self.player.setDelay(int(1000 / int(value)))

    def exclude_handler(self): # react to own Button, thumbnail can be from main or duplicates
        if self.thumbnail.getState() == state.INCLUDE:
            self.thumbnail.setState(state.EXCLUDE)
            self.w2.Button_exclude.config(text = "Include")
            self.w2.Label_status.config(text = "Excluded")
        else: # toggle to not exclude, delete Item
            self.thumbnail.setState(state.INCLUDE)
            self.w2.Button_exclude.config(text = "Exclude")
            self.w2.Label_status.config(text = "Included")
        historize_process()

    def exclude_call(self, state): # react to request from outside
        print("MyFSImage.Exclude called, State = " + str(state))
        if state == state.INCLUDE:
            self.w2.Button_exclude.config(text = "Exclude")
            self.w2.Label_status.config(text = "Included")
        else: # toggle to not exclude, delete Item
            self.w2.Button_exclude.config(text = "Include")
            self.w2.Label_status.config(text = "Excluded")
    
    def close_handler(self): #calles when window is closing: delete player and fsimage, remove from _dict_file_image
        t = self.dict_caller[self.file]
        self.thumbnail.register_FSimage(None)
        self.dict_caller.pop(self.file)
        if self.player is not None:
            self.player.pstop()
            del self.player
        self.root2.destroy()
        del t
        
    def close_handler_external(self): # called from external. Do the same things as close_handler, except remove from _dict_file_image
        # can be called from main window or Duplicates-Window which use different dicts
        t = self.dict_caller[self.file]
        self.thumbnail.register_FSimage(None)
        #_dict_file_image.pop(self.file) # the dict is dont do this when calles from external, because probably dict is in use
        if self.player is not None:
            self.player.pstop()
            del self.player
        self.root2.destroy()
        del t
        
    def mousewheel_handler(self, event):
        zoomincrement = (event.delta / 120) / 100 # Windows-spezifisch, macOS: keine Division durch 120
        if (zoomincrement > 0):
            if self.zoomfaktor + zoomincrement <= 1:
                newzoomfaktor = self.zoomfaktor + zoomincrement
            else:
                newzoomfaktor = 1.0
        else: # lt 0
            if self.zoomfaktor + zoomincrement >= .1:
                newzoomfaktor = self.zoomfaktor + zoomincrement
            else:
                newzoomfaktor = 0.1
        #print ("Mousewheel Delta is " + str(event.delta) + " Zoomfaktor old / new is: " + str(self.zoomfaktor) + ' / ' + str(newzoomfaktor))
        self.zoomfaktor = newzoomfaktor
        self.image_zoom(self.zoomfaktor)

    def button_fit(self):
        self.image_zoom(0) # damit bringt image_zoom das Foto vollständig und canvas-füllend zur Anzeige

    def image_zoom(self, zoomfaktor):
        # zoomfaktor 0 heißt: selbst errechnen, so dass Bild formatfüllend ist.
        image_width_orig, image_height_orig = self.image.size
        self.f.update()
        canvas_width  = self.f.winfo_width()
        canvas_height = self.f.winfo_height()
        if  zoomfaktor == 0: # wir brauchen die Scrollbars nicht und errechnen den formatfüllenden Zoomfaktor
            #self.V_I.pack_forget()
            #self.H_I.pack_forget()
            faktor = min(canvas_height / image_height_orig, canvas_width / image_width_orig)
            self.zoomfaktor = faktor
            print("... calculate faktor for Image to fit in Canvas")
        else:
            #self.V_I.pack(side=RIGHT, fill=Y)
            #self.H_I.pack(side=BOTTOM, fill=BOTH)
            faktor = zoomfaktor
            self.zoomfaktor = faktor
            
        newsize = (int(image_width_orig * faktor), int(image_height_orig * faktor))
        #print("*** faktor is: " + str(faktor) + " canvas_height: " + str(canvas_height) + " origsize: " + str(self.image.size) + " newsize: " +str(newsize))
        r_img = self.image.resize(newsize, Image.Resampling.NEAREST)
        self.pimg = ImageTk.PhotoImage(r_img)
        self.f.delete('images')
        #f.itemconfig(canvas_id, image = pimg)
        self.id = self.f.create_image(0, 0, anchor='nw',image = self.pimg, tags = 'images')
        self.f.tag_raise("rect")
        self.f.tag_raise("text")
        self.f.update()
        
        if newsize[0] <= canvas_width:
            self.H_I.pack_forget()
        else:
            self.H_I.pack(side=BOTTOM, fill=BOTH)
        if newsize[1] <= canvas_height:
            self.V_I.pack_forget()
        else:
            self.V_I.pack(side=RIGHT, fill=Y)
            
        self.f.config(scrollregion = self.f.bbox("all")) 

    def __del__(self):
        self.a = 1
        #print("*** Deleting FSImage-Objekt. File is " + str(self.file))

# display and process duplicates
class MyDuplicates:

    # The class "constructor" - It's actually an initializer 
    def __init__(self):
        self.player = None
        # register at thumbnail, so it can call us for reacting to state
        # Create secondary (or popup) window.
        self.root3 = tk.Toplevel()
        self.w3 = Dateimeister.Toplevel_dupl(self.root3)
        self.f = self.w3.Canvas_dupl
        self.w3.Button_dupl.config(command = self.dupl_handler)
        self.root3.protocol("WM_DELETE_WINDOW", self.close_handler)

        width,height=_screen_width,_screen_height
        v_dim=str(width)+'x'+str(height)
        self.root3.geometry(v_dim)
        self.root3.resizable(False, False)
        title = self.root3.title()
        self.root3.title(title + " for " + _outdir)

        # horizontal scrollbar for cancas
        self.H_I = Scrollbar(self.f, orient = HORIZONTAL, command = self.xview)
        #self.H_I.config(command=self.f.xview)
        self.f.config(xscrollcommand=self.H_I.set)
        self.H_I.pack(side=BOTTOM, fill=BOTH)
        # Bind keys to canvas for scrolling
        self.f.bind("<Left>",  lambda event: self.xview("scroll", -1, "units"))
        self.f.bind("<Right>", lambda event: self.xview("scroll",  1, "units"))
        self.f.bind("<Double-Button-1>", self.canvas_show)
        self.f.focus_set()
        
        # Listbox
        # vertical scrollbar for lisrbox
        self.V_L = Scrollbar(self.w3.Listbox_dupl, orient = VERTICAL)
        self.V_L.config(command = self.w3.Listbox_dupl.yview)                    
        self.V_L.pack(side=RIGHT, fill=BOTH)
        self.w3.Listbox_dupl.config(yscrollcommand = self.V_L.set) 
        self.w3.Listbox_dupl.bind('<Double-1>', self.lb_double)
        for key in _dict_duplicates[_imagetype]:
            self.w3.Listbox_dupl.insert(END, key)
        self.w3.Listbox_dupl.select_set(0)

        # Create the context menu
        self.context_menu = tk.Menu(self.f, tearoff=0)
        self.context_menu.add_command(label="Exclude", command=self.canvas_image_exclude)    
        self.context_menu.add_command(label="Show"   , command=self.canvas_image_show)    
        self.context_menu.add_command(label="Restart", command=self.canvas_video_restart)    

        self.f.bind("<Button-3>", self.show_context_menu)    
        self.f.bind('<Motion>', self.tooltip_imagefile)    
        self.f.bind('+', lambda event: self.delay_decr(event))
        self.f.bind('-', lambda event: self.delay_incr(event))
        self.f.bind('0', lambda event: self.delay_deflt(event))
        
        self.dict_child_parent = {}
        self.timestamp = datetime.now()
        self.tooltiptext = ""
        self.tt = Dateimeister.ToolTip(self.f, "no images available", delay=0, follow = True)
        self.delay_default = 20 #ToDo: Ini
        
        self.dict_file_image = {}
        _button_duplicates.config(state = DISABLED) # Duplicates Window must not exist more than once

    def exclude_call(self, parent, state): # react to request from outside, outside is root - thumbnail
        print("MyDuplicate.Exclude called, State = " + str(state))
        # we have to find child for parent ( this is the thumbnail in main window)
        for child in self.dict_child_parent:
            myparent = self.dict_child_parent[child]
            if myparent == parent:
                break
        child.setState(state, self)
    
    def canvas_image_exclude(self): # calls canvas_exclude with self.event
        print("Context menu exlude")
        self.canvas_exclude(self.event)

    def canvas_exclude(self, event):
        self.f.focus_set()

        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            if thumbnail.getState() == state.INCLUDE:
                thumbnail.setState(state.EXCLUDE, self)
            else: # toggle to not exclude, delete Item
                thumbnail.setState(state.INCLUDE, self)
            historize_process()

    def canvas_image_show(self):
        print("Context menu show")
        self.canvas_show(self.event)

    def canvas_show(self, event):
        self.f.focus_set()

        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            item_id = thumbnail.getId()
            self.display_image(thumbnail)

    def display_image(self, thumbnail):
        file = thumbnail.getShowfile()
        # wenn das Bild schon in einem Fenster angezeigt wird, dann verwenden wir dieses
        if file in self.dict_file_image:
            print ("FSImage exists for file: " + file)
            fs_image = self.dict_file_image[file]
            player = fs_image.getPlayer()
            if player is not None: # this is a video
                print ("FSImage restart file: " + file)
                player.restart()
                fs_image.setPlaystatus('play') # Status, Buttontext
        else: # ein neues Objekt anlegen und in _dict_file_image eintragen
            print ("FSImage does not exist for file: " + file)
            fs_image = MyFSImage(file, thumbnail, self.dict_file_image)
            self.dict_file_image[file] = fs_image

    def canvas_video_restart(self):
        print("Context menu restart")
        self.f.focus_set()

        canvas_x = self.f.canvasx(self.event.x)
        canvas_y = self.f.canvasy(self.event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # this is a video
                player.restart()

    def show_context_menu(self, event):
        # das Event müssen wir speichern, da die eigenlichen Funktionen die x und y benötigen
        self.event = event
        # falls wir keine anzeigbare Datei haben, müssen wir show-Item disablen
        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            if thumbnail.getImage() == 0:
                print(" No Image availabl for " + thumbnail.getFile())
                self.context_menu.entryconfig(1, state="disabled")
            else:
                self.context_menu.entryconfig(1, state="normal")
            if thumbnail.getState() == state.INCLUDE:
                self.context_menu.entryconfig(0, label = "Exclude " + thumbnail.getFile())
            else:
                self.context_menu.entryconfig(0, label = "Include " + thumbnail.getFile())
        self.context_menu.entryconfig(1, label = "Show " + thumbnail.getFile())
        self.context_menu.post(event.x_root, event.y_root)
    
    def tooltip_imagefile(self, event):
        tsnow = datetime.now()
        tdiff = abs(tsnow - self.timestamp)
        if  tdiff.microseconds > 100000:
            #print("Timer has finished, microsecons is: ", tdiff.microseconds)
            self.timestamp = tsnow
        else:
            return
        # Tooltip
        #x, y = canvas.winfo_pointerxy()
        text = "no image available"
        # canvas is drawn before the thumbnails are created, so check existence and length
        if _imagetype in thumbnails_duplicates and len(thumbnails_duplicates[_imagetype]) > 0:
            canvas_x = self.f.canvasx(event.x)
            canvas_y = self.f.canvasy(event.y)
            thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
            if thumbnail is not None:
                text = thumbnail.getFile()
                #print("Image clicked: " + text)
            if text != self.tooltiptext:
                self.tt.update(text)
                self.tooltiptext = text
                self.stop_all_players()
                # if file is video, play video
                if thumbnail is not None:
                    player = thumbnail.getPlayer()
                    if player is not None: # this is a video
                        player.pstart()
                        player.setDelay(delay_default)
                        fps   = player.getFPS()
                        fc    = player.getFrameCount()
                        delay = player.getDelay()
                        frames_per_second = 1000 / delay
                        duration_in_seconds = fc / frames_per_second
                        #print ("FPS is: ", fps, " Total Num of Frames is: ", fc, " Delay is: ", delay, " calc duration is: " + str(duration_in_seconds))
                        self.context_menu.entryconfig(2, state="normal")
                    else:
                        self.context_menu.entryconfig(2, state="disabled")
                        
    def delay_decr(self, event): # speed +
        self.f.focus_set()
        delta = -5
        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                if delay + delta > 5:
                    player.setDelay(delay + delta)

    def delay_incr(self, event): # speed -
        self.f.focus_set()
        delta = 5
        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                if delay + delta < 200:
                    player.setDelay(delay + delta)

    def delay_deflt(self, event): # speed normal
        self.f.focus_set()
        canvas_x = self.f.canvasx(event.x)
        canvas_y = self.f.canvasy(event.y)
        thumbnail, index = self.get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            player = thumbnail.getPlayer()
            if player is not None: # a video
                delay = player.getDelay()
                player.setDelay(self.delay_default)
                
    def lb_double(self, event):
        cs = self.w3.Listbox_dupl.curselection()
        self.thisduplicate = self.w3.Listbox_dupl.get(cs)
        #print("Duplicate selected: " + self.thisduplicate)
        self.display_duplicate(self.thisduplicate)
    
    def scrollx(self, amount, unit):
        #print("scroll command: " + str(amount) + ' ' + unit)
        self.f.xview_scroll(amount, unit)
        return "break"
     
    def dupl_handler(self):
        cs = self.w3.Listbox_dupl.curselection()
        self.thisduplicate = self.w3.Listbox_dupl.get(cs)
        #print("Duplicate selected: " + self.thisduplicate)
        self.display_duplicate(self.thisduplicate)

    def close_handler(self): #calles when window is closing
        print("ToDo, cleanup when window is closed")
        self.stop_all_players() # unregister to avoid calls after duplicate has been destroyed
        for child in self.dict_child_parent:
            parent = self.dict_child_parent[child]
            parent.register_Dupl(None)
        self.root3.destroy()
        for t in self.dict_file_image: # destroy all FSImages
            u = self.dict_file_image[t]
            u.close_handler_external()
        _button_duplicates.config(state = NORMAL)
        
    def stop_all_players(self):
        # stop all video players
        _button_duplicates.config(state = DISABLED)
        if _imagetype in thumbnails_duplicates:
            for t in thumbnails_duplicates[_imagetype]: # stop all running players
                thisplayer = t.getPlayer()
                if thisplayer is not None:
                    if thisplayer.getRun(): # running
                        thisplayer.pstop()
                        #print ("Stop player for: " + t.getFile())
    
    def display_duplicate(self, target_file):
        stop_all_players() # should not continue running 
        self.f.delete('all')
        thumbnails_duplicates[_imagetype] = []
        dict_thumbnails_duplicates[_imagetype] = {}
        list_duplicate_sourcefiles = _dict_duplicates[_imagetype][target_file]
        self.lastposition = 0
        self.num_images = 0
        for source_file in list_duplicate_sourcefiles:
            thumbnail = _dict_thumbnails[_imagetype][source_file]
            showfile = thumbnail.getShowfile()
            state = thumbnail.getState() # we want to use the current state and copy it to the duplicate-thumbnail
            if showfile != 'none':
                canvas_height = self.f.winfo_height() - self.H_I.winfo_height()
                canvas_width  = self.f.winfo_width()
                self.canvas_width_visible = self.f.winfo_width() # Fensterbreite
                player = None
                if thumbnail.getPlayer() is not None: # Video
                    print("try to create new videoplayer...")
                    # create new videoplayer
                    player   = DV.VideoPlayer(self.root3, showfile, self.f, canvas_width, canvas_height, self.lastposition)
                    image_width, image_height, pimg = player.get_pimg()
                else: # still image
                    img  = Image.open(showfile)
                    image_width_orig, image_height_orig = img.size
                    faktor = canvas_height / image_height_orig
                    newsize = (int(image_width_orig * faktor), int(image_height_orig * faktor))
                    r_img = img.resize(newsize, Image.Resampling.NEAREST)
                    image_width, image_height = r_img.size
                    print("try to print " + showfile + " width is " + str(image_width) + "(" + str(image_width_orig) + ")" + " height is " + str(image_height) + "(" + str(image_height_orig) + ")" \
                       + " factor is " + str(faktor))
                    pimg = ImageTk.PhotoImage(r_img)
                id = self.f.create_image(self.lastposition, 0, anchor='nw',image = pimg, tags = 'images')
                text_id = self.f.create_text(self.lastposition, 0, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
                rect_id = self.f.create_rectangle(self.f.bbox(text_id), outline="blue", fill = "white", tag = 'rect')
                self.f.tag_raise("rect")
                self.f.tag_raise("text")
                self.f.tag_raise("line")
                if player is not None:
                    player.setId(id)
                # we must also create a thumbnail_list for duplicate images, or the garbage collector will delete images
                myimage = MyThumbnail(pimg, self.lastposition, self.lastposition + image_width, showfile, showfile, id, \
                    text_id, rect_id, _dict_image_lineno[_imagetype][showfile], player, 'j', self.f, None, None, thumbnail)
                thumbnails_duplicates[_imagetype].append(myimage)
                myimage.setState(state)
                dict_thumbnails_duplicates[_imagetype][showfile] = myimage # damit können wir auf thumbnails mit den Sourcefilenamen zugreifen, z.B. für Duplicates
                self.lastposition += image_width + gap 
            else: # wir haben kein Bild, ein Rechteck einfügen
                image_height = canvas_height
                image_width  = int(canvas_height * 4 / 3)
                id = self.f.create_rectangle(self.lastposition, 0, self.lastposition + image_width, canvas_height, fill="blue", tags = 'images')
                text_id = self.f.create_text(self.lastposition, 0, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
                rect_id = self.f.create_rectangle(self.f.bbox(text_id), outline="blue", fill = "white")
                self.f.tag_raise("text")
                myimage = MyThumbnail(0, self.lastposition, self.lastposition + image_width, showfile, showfile, id, \
                    text_id, rect_id, _dict_image_lineno[_imagetype][file], player, 'j', self.f, None, None, thumbnail)
                thumbnails_duplicates[_imagetype].append(myimage)
                dict_thumbnails_duplicates[_imagetype][showfile] = myimage
                self.lastposition += image_width + gap 
            self.num_images += 1
            # register at parent-thumbnail, so it can call us for reacting to state
            # we need a dict with child-parent-thumbnails in order to unregister on close
            self.dict_child_parent[myimage] = thumbnail # child -> parent
            thumbnail.register_Dupl(self)
        # gap haben wir einmal zuviel (fürs letzte) gezählt
        self.lastposition -= gap
        # damit wir am Ende auch bis zum letzten einzelnen Bild scrollen können, fügen wir ein Rechteck ein
        if len(thumbnails_duplicates[_imagetype]) > 0: 
            thumbnail = thumbnails_duplicates[_imagetype][-1]
            rect_len = self.canvas_width_visible - (thumbnail.getEnd() - thumbnail.getStart() + gap)
            self.f.create_rectangle(self.lastposition, 0, self.lastposition + rect_len, canvas_height, fill="yellow")
            self.f.config(scrollregion = self.f.bbox('all')) 
            self.canvas_width_images = self.f.bbox('images')[2]
            self.canvas_width_all    = self.f.bbox('all')[2]
            #print ("Canvas totale Breite(Images): " + str(self.canvas_width_images) + " totale Breite(All): " + str(self.canvas_width_all) \
            #    + " visible: " + str(self.canvas_width_visible) + " lastposition: " + str(self.lastposition))
        
        for child in self.dict_child_parent:
            parent = self.dict_child_parent[child]
            print("Child file / parent file is: " + child.getFile() + ' / ' + parent.getFile())
        #print("thumbnails_duplicates is: " + str(thumbnails_duplicates))
        self.f.focus_set()

    def xview(self, *args):
        print (*args)
        s1 = 0.0
        s2 = 1.0
        scrolldelta = 0
        width_scrollbar = self.H_I.winfo_width()
        #print ("Scroll Canvas totale Breite(Images): " + str(self.canvas_width_images) + " totale Breite(All): " + str(self.canvas_width_all) \
        #    + " visible: " + str(self.canvas_width_visible) + " Scrollbarwidth: " + str(width_scrollbar) + " BBOX: " + str(self.f.bbox('all')))
        slider_width = int((self.canvas_width_visible / self.canvas_width_all) * width_scrollbar)
        # aktuelle Scroll-Position des Canvas
        canvas_x = self.f.canvasx(0)
        canvas_y = self.f.canvasy(0)
        # aktuelle position der Scrollbar
        scrollposition = self.H_I.get()[0]
        
        print("scroll_position_H_I: " + str(canvas_x) + " scroll_position Scrollbar: " + str(scrollposition))
        # wenn wir die Pfeiltasten betätigen, wollen wir auf den Anfang des nächsten (vorherigen) Bildes scrollen.
        # wenn das aktuelle Bild nur teilweise zusehen ist, scrollen wir bei Linkstaste auf den Bildbeginn
        if len(args) == 3 and args[2] == "units":
            # den scrollbetrag auf die Größe des Bildes am linken Rand setzen
            thumbnail, index = self.get_thumbnail_by_position(canvas_x + 11, canvas_y)
            if thumbnail is not None:
                if int(args[1]) > 0:
                    scrolldelta = (thumbnail.getEnd() - canvas_x + gap)
                else:
                    if canvas_x - thumbnail.getStart() > 10: # Bild links abgeschnitten, an den Anfang scrollen
                        scrolldelta = (thumbnail.getStart() - canvas_x) # ist dann negativ, was wir ja wollen
                        #print("Bild links abgeschnitten, weil canvas_x = " + str(canvas_x) + " und Bildstart = " + str(thumbnail.getStart()))
                    else: #Bild ist vollständig zu sehen, also zurück zum nächsten
                        if index > 0: # es gibt einen Vorgänger
                            scrolldelta = (thumbnails_duplicates[_imagetype][index - 1].getStart()) - canvas_x
                            #print("Vorgänger ist: " + thumbnails[_imagetype][index - 1].getFile() + " Start: " + str(thumbnails[_imagetype][index - 1].getStart())\
                            #    + " canvas_x is: " + str(canvas_x) + " scrolldelta is: " + str(scrolldelta))
                
                new_canvas_x = canvas_x + scrolldelta
                # nach links scrollen machr keinen Sinn, wenn wir schon ganz links stehen, analog rechts
                if (int(args[1]) < 0 and canvas_x <= 0) or (int(args[1]) > 0 and new_canvas_x >= self.canvas_width_images):
                   return
                s2 = new_canvas_x / self.canvas_width_all
                s1 = (new_canvas_x - slider_width) / self.canvas_width_all
                print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
            self.H_I.set(s1, s2)
            self.f.xview('moveto', s2)
        else:
            #if (1 == 0):
                #return
            self.f.xview(*args)

    def get_thumbnail_by_position(self, canvas_x, canvas_y):
        index = -1
        found = False
        for thumbnail in thumbnails_duplicates[_imagetype]:
            start = thumbnail.getStart()
            end   = thumbnail.getEnd()
            if (canvas_x >= start and canvas_x <= end):
                index = thumbnails_duplicates[_imagetype].index(thumbnail)
                #print("retrieved " + thumbnail.getFile() + " Index: " + str(index))
                found = True
                break
        if not found:
            thumbnail = None
            index = None
        return (thumbnail, index)

    def __del__(self):
        self.a = 1
        print("*** Deleting MyDuplicates-Objekt. Outdir is " + str(_outdir))

# Message Output from generated scripts
class MyMessagesWindow:

    # The class "constructor" - It's actually an initializer 
    def __init__(self, imagetype, copyscript = None, deletescript = None, delrelpathscript = None):
        self.root = tk.Toplevel()
        self.w = Dateimeister.Toplevel_messages(self.root)
        self.root.protocol("WM_DELETE_WINDOW", self.close_handler)

        self.copyscript = copyscript
        self.deletescript = deletescript
        self.delrelpathscript = delrelpathscript
        self.root.title(imagetype)
        width,height=_screen_width,_screen_height
        v_dim=str(width)+'x'+str(height)
        self.root.geometry(v_dim)
        self.root.resizable(True, True)

        self.w.cb_delrelpath = self.w.Checkbutton_delrelpath
        self.w.cb_delrelpath_var.set(0)

        self.w.Button_execute.config(command = self.exec_handler)
        # Scrollbars
        # Script
        parent_width  = self.w.Frame_script.winfo_width()
        parent_height = self.w.Frame_script.winfo_height()
        self.VS = Scrollbar(self.w.Frame_script)
        self.VS.config(command=self.w.Text_script.yview)
        self.w.Text_script.config(yscrollcommand=self.VS.set) 
        self.HS = Scrollbar(self.w.Frame_script, orient = HORIZONTAL)
        self.HS.config(command=self.w.Text_script.xview)
        self.w.Text_script.config(xscrollcommand=self.HS.set)
        self.VS.place(relx = 1, rely = 0,     relheight = 0.98, relwidth = 0.04, anchor = tk.NE)
        self.HS.place(relx = 0, rely = 1, relheight = 0.02, relwidth = 0.96, anchor = tk.SW)

        #Messages
        parent_width  = self.w.Frame_messages.winfo_width()
        parent_height = self.w.Frame_messages.winfo_height()
        self.VM = Scrollbar(self.w.Frame_messages)
        self.VM.config(command=self.w.Text_messages.yview)
        self.w.Text_messages.config(yscrollcommand=self.VM.set)  
        self.HM = Scrollbar(self.w.Frame_messages, orient = HORIZONTAL)
        self.HM.config(command=self.w.Text_messages.xview)
        self.w.Text_messages.config(xscrollcommand=self.HM.set)
        self.VM.place(relx = 1, rely = 0,     relheight = 0.98, relwidth = 0.02, anchor = tk.NE)
        self.HM.place(relx = 0, rely = 1, relheight = 0.02, relwidth = 0.98, anchor = tk.SW)
        
        # Errors
        parent_width  = self.w.Frame_errors.winfo_width()
        parent_height = self.w.Frame_errors.winfo_height()
        self.VE = Scrollbar(self.w.Frame_errors)
        self.VE.config(command=self.w.Text_errors.yview)
        self.w.Text_errors.config(yscrollcommand=self.VE.set) 
        self.HE = Scrollbar(self.w.Frame_errors, orient = HORIZONTAL)
        self.HE.config(command=self.w.Text_errors.xview)
        self.w.Text_errors.config(xscrollcommand=self.HE.set)
        self.VE.place(relx = 1, rely = 0,     relheight = 0.98, relwidth = 0.04, anchor = tk.NE)
        self.HE.place(relx = 0, rely = 1, relheight = 0.02, relwidth = 0.96, anchor = tk.SW)
        
        # Radio Buttons for selection of script
        # control variable
        self.rb_value = tk.StringVar()
        # Radiobutton
        self.w.Radiobutton_copyscript.config(value = "copy", variable = self.rb_value, command = self.script_select)
        self.w.Radiobutton_deletescript.config(value = "delete", variable = self.rb_value, command = self.script_select)
        self.w.Radiobutton_delrelpathscript.config(value = "delrelpath", variable = self.rb_value, command = self.script_select)
        self.w.Radiobutton_copyscript.select()    
        self.show_script(copyscript)        
        self.action = "copy"
        self.w.Label_script.config(text = copyscript)
    def script_select(self):
        print("Script selected is: " + self.rb_value.get())
        if self.rb_value.get() == "copy":
            self.show_script(self.copyscript)
            self.action = "copy"
            self.w.Button_execute.config(state = NORMAL)
            self.w.Label_script.config(text = self.copyscript)
        elif self.rb_value.get() == "delete":
            self.show_script(self.deletescript)
            self.action = "delete"
            self.w.Button_execute.config(state = NORMAL)
            self.w.Label_script.config(text = self.deletescript)
        elif self.rb_value.get() == "delrelpath":
            self.show_script(self.delrelpathscript)
            self.action = "delrelpath"
            self.w.Button_execute.config(state = DISABLED)
            self.w.Label_script.config(text = self.delrelpathscript)
        self.w.Button_execute.config(text = self.action)

    def show_script(self, script):        
        try:
            file = open(script)
        except FileNotFoundError:
            print("File does not exist: " + script)
        text = file.read()
        self.w.Text_script.delete(1.0, 'end')
        self.w.Text_script.insert('end', text)
        self.w.Text_script.insert('end', "\r\n")

    def show_messages(self, text, b_clear):
        if b_clear:
            self.w.Text_messages.delete(1.0, 'end')
        self.w.Text_messages.insert('end', text)
        self.w.Text_messages.insert('end', "\r\n")

    def show_errors(self, text, b_clear):
        if b_clear:
            self.w.Text_errors.delete(1.0, 'end')
        self.w.Text_errors.insert('end', text)
        self.w.Text_errors.insert('end', "\r\n")
        
    def exec_handler(self):
        if self.action == "copy":
            cmdfile = self.copyscript
        elif self.action == "delete" or self.action == "delrelpath":
            cmdfile = self.deletescript
        self.w.Label_script.config(text = cmdfile)
        my_cmd = "call " + cmdfile 
        owndir = os.getcwd()
        os.chdir(os.path.join(datadir, cmd_files_subdir))    
        my_cmd_output = subprocess.Popen(my_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (output, error) = my_cmd_output.communicate()
        self.show_messages(output, True)
        self.show_errors(error, True)
        if self.action == "delete" and self.delrelpathscript is not None and self.w.cb_delrelpath_var.get():
            cmdfile_delrelpath = self.delrelpathscript
            my_cmd = "call " + cmdfile_delrelpath 
            my_cmd_output = subprocess.Popen(my_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
            (output, error) = my_cmd_output.communicate()
            self.show_messages(output, False)
            self.show_errors(error, False)
            self.w.Label_script.config(text = cmdfile + ' + ' + cmdfile_delrelpath)
        os.chdir(owndir)

    def close_handler(self): #calles when window is closing:
        self.root.destroy()

    def __del__(self):
        self.a = 1
        #print("*** Deleting Camera-Objekt.")


# Camera Dialog
class MyCameraWindow:

    # The class "constructor" - It's actually an initializer 
    def __init__(self, cameraname = None):
        self.cameraname = cameraname
        self.root = tk.Toplevel()
        self.w = Dateimeister.Toplevel_camera(self.root)
        self.root.protocol("WM_DELETE_WINDOW", self.close_handler)

        self.root.title(cameraname)
        width,height=_screen_width,_screen_height
        v_dim=str(width)+'x'+str(height)
        self.root.geometry(v_dim)
        self.root.resizable(True, True)

        # Scrollbars
        self.V_C = Scrollbar(self.w.Frame_camera_name)
        self.V_C.config(command=self.w.Listbox_camera_name.yview)
        self.w.Listbox_camera_name.config(yscrollcommand=self.V_C.set)  
        self.H_C = Scrollbar(self.w.Frame_camera_name, orient = HORIZONTAL)
        self.H_C.config(command=self.w.Listbox_camera_name.xview)
        self.w.Listbox_camera_name.config(xscrollcommand=self.H_C.set)
        self.V_C.place(relx = 1, rely = 0,     relheight = 0.975, relwidth = 0.025, anchor = tk.NE)
        self.H_C.place(relx = 0, rely = 0.975, relheight = 0.025, relwidth = 0.975, anchor = tk.NW)
    
        self.V_T = Scrollbar(self.w.Frame_camera_type)
        self.V_T.config(command=self.w.Listbox_camera_type.yview)
        self.w.Listbox_camera_type.config(yscrollcommand=self.V_T.set)  
        self.H_T = Scrollbar(self.w.Frame_camera_type, orient = HORIZONTAL)
        self.H_T.config(command=self.w.Listbox_camera_type.xview)
        self.w.Listbox_camera_type.config(xscrollcommand=self.H_T.set)
        self.V_T.place(relx = 1, rely = 0,     relheight = 0.975, relwidth = 0.025, anchor = tk.NE)
        self.H_T.place(relx = 0, rely = 0.975, relheight = 0.025, relwidth = 0.975, anchor = tk.NW)

        self.V_S = Scrollbar(self.w.Frame_camera_suffix)
        self.V_S.config(command=self.w.Listbox_camera_suffix.yview)
        self.w.Listbox_camera_suffix.config(yscrollcommand=self.V_S.set)  
        self.H_S = Scrollbar(self.w.Frame_camera_suffix, orient = HORIZONTAL)
        self.H_S.config(command=self.w.Listbox_camera_suffix.xview)
        self.w.Listbox_camera_suffix.config(xscrollcommand=self.H_S.set)
        self.V_S.place(relx = 1, rely = 0,     relheight = 0.975, relwidth = 0.025, anchor = tk.NE)
        self.H_S.place(relx = 0, rely = 0.975, relheight = 0.025, relwidth = 0.975, anchor = tk.NW)

    def close_handler(self): #calles when window is closing:
        self.root.destroy()

    def __del__(self):
        self.a = 1
        #print("*** Deleting Camera-Objekt.")


def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = Dateimeister.Toplevel1(_top1)
    init(root, _w1)
    root.mainloop()

def init(tk_root,gui):
    global w, root, _screen_width, _screen_height, _imagetype, _dict_process_image, _codepage, _language, \
       _button_undo, _button_redo, _uncomment, _tooltiptext, _tt, _dict_cameras, _dict_subdirs, \
        colors, color_noreport, color_lookahead, levels, o_e, o_s, o_camera,\
        lb_camera, b_button1, b_button2, b_button_outdir, t_text1, l_label1, dict_gen_files, lb_gen, \
        canvas_gallery, cb_recursive, cb_recursive_var, cb_prefix, cb_prefix_var, cb_addrelpath, cb_addrelpath_var, \
        thumbnails, images, scroll_canvas_x, gap, context_menu, \
        _dict_image_lineno, _button_exclude, _button_include, _use_camera_prefix, _button_duplicates, _button_be, filemenu, \
        cb_newer, cb_newer_var, config_files_xml, recentmenu, config_file, title, label_num, num_images, config_files_subdir, \
        cmd_files_subdir, _timestamp, delay_default, thumbnails_duplicates, dict_thumbnails_duplicates, \
        button_save, button_exec, dict_gen_files_delete, cb_num, cb_num_var, dict_templates, templatefile, \
        combobox_indir, combobox_indir_var, combobox_outdir, combobox_outdir_var, max_configfiles, max_indirs, max_outdirs, label_indir, label_outdir, \
        button_indir_from_list, button_outdir_from_list, platform, datadir, oldcamera, button_call
#    print("Init called\n")
    windll = ctypes.windll.kernel32
    _codepage = windll.GetUserDefaultUILanguage()
    _language = locale.windows_locale[ windll.GetUserDefaultUILanguage() ]
    os.environ["LANGUAGE"]    = _language
    
    print("Codepage is: " + str(_codepage) + " language is: " + _language)
    w = gui
    root = tk_root
    
    inifile = "Dateimeister.ini" 
    config = configparser.ConfigParser() 
    config.read(inifile)
    default_indir  = config["dirs"]["indir"]
    default_outdir = config["dirs"]["outdir"]
    datadir = config["dirs"]["datadir"]
    config_files_subdir = config["dirs"]["config_files_subdir"]
    cmd_files_subdir    = config["dirs"]["cmd_files_subdir"]
    config_files_xml = config["misc"]["config_files_xml"]
    delay_default = 20 #ToDo: Ini

    dict_templates = {}
    _dict_cameras = get_camera_xml()

    _dict_subdirs = {}
    _dict_subdirs = DX.get_subdirs(config_files_xml)
    for imagetype in _dict_subdirs:
        print("Subdir {:s}, {:s}".format(imagetype, _dict_subdirs[imagetype]))
    
    _dict_process_image = {}
    _dict_process_image = DX.get_process_image(config_files_xml)
    for t in _dict_process_image:
        print("Process Image  {:s}, {:s}".format(t, _dict_process_image[t]))
    
    _uncomment = config["misc"]["uncomment"] + " "        
    templatefile = config["misc"]["templatefile"]
    #max number of config_file-, indir-, outdir-entries in xml
    max_configfiles = config["misc"]["max_configfiles"]
    max_indirs      = config["misc"]["max_indirs"]
    max_outdirs     = config["misc"]["max_outdirs"]
    platform = config["misc"]["platform"].upper()
    if platform != "UNIX" and platform != "WINDOWS":
        messagebox.showerror("INIT", "Platform must be Windows or Unix, not " + platform)
        exit()
    
    o_camera  = w.Entry_camera
    lb_camera = w.Listbox1
    lb_camera.configure(exportselection=False)
    b_button1 = w.Button1
    b_button2 = w.Button2
    b_button_outdir = w.Button_outdir
    button_call = w.Button_call
    button_call.config(command = Press_generate)
    button_save = w.Button_save
    button_save.config(command = button_save_pressed)
    button_exec = w.Button_exec
    button_exec.config(command = button_exec_pressed)
    
    t_text1 = w.Text1
    # set font
    font_tuple = ("Lucida Console", 10, "normal")
    t_text1.config(font = font_tuple)
    t_text1.tag_configure("normal_include", foreground="black", background = "white")
    t_text1.tag_configure("select_include", foreground="red", background = "white")
    t_text1.tag_configure("normal_exclude", foreground="lightgrey", background = "darkgrey")
    t_text1.tag_configure("select_exclude", foreground="red", background = "darkgrey")
    
    l_label1 = w.Label1
    label_num = w.Label_num
    lb_gen   = w.Listbox_gen
    _button_include = w.Button_include
    _button_exclude = w.Button_exclude
    _button_include.config(state = DISABLED)
    _button_exclude.config(state = DISABLED)
    _button_undo = w.Button_undo
    _button_redo = w.Button_redo
    _button_undo.config(state = DISABLED)
    _button_redo.config(state = DISABLED)
    _button_duplicates = w.Button_duplicates
    _button_duplicates.config(state = DISABLED)
    _button_be = w.Button_be
    _button_be.config(state = DISABLED)
    button_save.config(state = DISABLED)
    button_exec.config(state = DISABLED)
    button_call.config(state = DISABLED) # generate-Button
    
    label_indir  = w.Label_indir
    label_outdir = w.Label_outdir
    button_indir_from_list = w.Button_indir_from_list
    button_outdir_from_list = w.Button_outdir_from_list
    
    # Scrollbars
    V = Scrollbar(t_text1)
    V.pack(side=RIGHT, fill=Y)
    V.config(command=t_text1.yview)
    t_text1.config(yscrollcommand=V.set)  
    H = Scrollbar(t_text1, orient = HORIZONTAL)
    H.pack(side=BOTTOM, fill=BOTH)
    H.config(command=t_text1.xview)
    t_text1.config(xscrollcommand=H.set)  
    t_text1.configure(wrap="none")
    
    cb_recursive = w.Checkbutton1
    cb_recursive.config(command = state_gen_required)
    cb_recursive_var = w.cb1_val
    cb_recursive_var.set(1)
    
    cb_prefix = w.Checkbutton_use_camera_name
    cb_prefix.config(command = state_gen_required)
    cb_prefix_var = w.cb_prefix_var
    cb_prefix_var.set(1)

    cb_addrelpath = w.Checkbutton_addrelpath
    cb_addrelpath.config(command = state_gen_required)
    cb_addrelpath_var = w.cb_addrelpath_var
    cb_addrelpath_var.set(0)

    cb_newer = w.Checkbutton_newer
    cb_newer.config(command = state_gen_required)
    cb_newer_var = w.cb_newer_var
    cb_newer_var.set(0)

    cb_num = w.Checkbutton_num
    cb_num_var = w.cbnum_var
    cb_num_var.set(1)

    combobox_indir = w.TCombobox_indir
    combobox_indir_var = w.combobox_indir
    combobox_indir.configure(exportselection=False)
    combobox_outdir = w.TCombobox_outdir
    combobox_outdir_var = w.combobox_outdir
    combobox_outdir.configure(exportselection=False)
    
    # Scrollbars
    VI = Scrollbar(combobox_indir, orient= VERTICAL)
    VI.place(relx = 1, rely = 0, relheight = 1, relwidth = .015, anchor = tk.NE)
    VI.config(command = combobox_indir.yview)
    combobox_indir.config(yscrollcommand = VI.set)
    VO = Scrollbar(combobox_outdir, orient= VERTICAL)
    VO.place(relx = 1, rely = 0, relheight = 1, relwidth = .015, anchor = tk.NE)
    VO.config(command = combobox_outdir.yview)
    combobox_outdir.config(yscrollcommand = VO.set)
    
    canvas_gallery = w.Canvas1
    # Scrollbars
    scroll_canvas_x = tk.Scrollbar(root, orient="horizontal", command=xview)
    #scroll_canvas_x.pack(side=BOTTOM, fill=BOTH)
    scroll_canvas_x.place(relx = .015, rely = .96, relheight = 0.015, relwidth = .97, anchor = tk.NW)
    canvas_gallery.config(xscrollcommand = scroll_canvas_x.set, scrollregion=canvas_gallery.bbox("all"))

    # Create the context menu
    context_menu = tk.Menu(canvas_gallery, tearoff=0)
    context_menu.add_command(label="Exclude", command=canvas_image_exclude)    
    context_menu.add_command(label="Show"   , command=canvas_image_show)    
    context_menu.add_command(label="Restart", command=canvas_video_restart)    
  
    # Events
    # Button 1 single haben wir deaktiviert, weil double immer auch zuerst single auslöst
    # deshalb exlude und show über Kontext-Menü (rechte Maustaste), Show zusätzlich auch mit Doppelclick
    #canvas_gallery.bind("<Button-1>", canvas_gallery_exclude)
    canvas_gallery.bind("<Double-Button-1>", canvas_gallery_show)
    # Pfeitasten fürs scrollen
    canvas_gallery.bind("<Left>",  lambda event: xview("scroll", -1, "units"))
    canvas_gallery.bind("<Right>", lambda event: xview("scroll",  1, "units"))
    canvas_gallery.bind("<Prior>", lambda event: xview("scroll", -1, "page")) # Bind to PageUp
    canvas_gallery.bind("<Next>",  lambda event: xview("scroll",  1, "page"))  # Bind to PageDown    
    # Bind the context menu to the canvas widget
    canvas_gallery.bind("<Button-3>", show_context_menu)    
    canvas_gallery.bind('<Motion>', tooltip_imagefile)    
    canvas_gallery.bind('<Button-1>', canvas_button_1)    
    root.bind("<Configure>", on_window_resize)
    root.bind("<Destroy>",   on_window_destroy)
    # strg-z, y
    canvas_gallery.bind('<Control-z>', lambda event: process_undo(event))
    canvas_gallery.bind('<Control-y>', lambda event: process_redo(event))
    canvas_gallery.bind('+', lambda event: delay_decr(event))
    canvas_gallery.bind('-', lambda event: delay_incr(event))
    canvas_gallery.bind('0', lambda event: delay_deflt(event))
    canvas_gallery.bind('<FocusOut>', focus_out)
    lb_gen.bind('<Double-1>', lb_gen_double)
    lb_camera.bind('<Double-1>', lb_camera_double)
    t_text1.bind('<Double-1>', text1_double)
    cb_num.config(command = on_cb_num_toggle)
    combobox_indir.bind('<Double-1>', combobox_indir_double)
    combobox_outdir.bind('<Double-1>', combobox_outdir_double)
    combobox_indir.bind("<<ListboxSelect>>", lambda event: combobox_indir_check_exist(event))
    combobox_outdir.bind("<<ListboxSelect>>", lambda event: combobox_outdir_check_exist(event))
    button_indir_from_list.config(command = combobox_indir_double)  
    button_outdir_from_list.config(command = combobox_outdir_double)  
    
    for key in _dict_cameras:
        lb_camera.insert(END, key)
    lb_camera.selection_set(END)
    label_indir.config(text = default_indir)
    label_outdir.config(text = default_outdir)
    l_label1.config(text = "Messages")
    label_num.config(text = "0")
    dict_gen_files = {}
    dict_gen_files_delete = {}
    thumbnails = {}
    thumbnails_duplicates = {}
    dict_thumbnails_duplicates = {}
    images = []
    _dict_image_lineno = {}
    gap = 10
    config_file = ""
    title = root.title()
    oldcamera = ""

    
    # Fenstergröße
    _screen_width  = int(root.winfo_screenwidth() * 0.9)
    _screen_height = int(root.winfo_screenheight() * 0.8)
    print("Bildschirm ist " + str(_screen_width) + " x " + str(_screen_height))
    width,height=_screen_width,_screen_height
    v_dim=str(width)+'x'+str(height)
    root.geometry(v_dim)
    #my_w.maxsize(300,220)  # (maximum ) width , ( maximum) height
    #my_w.minsize(250,220)  # (minimum ) width , ( minimum) height
    root.resizable(False, False)
    _tt = Dateimeister.ToolTip(canvas_gallery, "no images available", delay=0, follow = True)
    
    # Menubar
    menubar = Menu(root)
    filemenu = Menu(menubar, tearoff=0)
    filemenu.add_command(label="New", command=donothing)
    filemenu.add_command(label="Open config", command=open_config)
    filemenu.add_command(label="Save config", command=save_config)
    filemenu.add_command(label="Save config as...", command=saveas_config)
    filemenu.add_command(label="Apply config", command=apply_config)
    menubar.add_cascade(label="File", menu=filemenu)
    recentmenu = Menu(menubar, tearoff=0)
    filemenu.add_cascade(label="Open Recent", menu=recentmenu)
    filemenu.add_separator()
    filemenu.add_command(label="Exit", command=root.quit)
    filemenu.entryconfig(0, state=DISABLED)
    filemenu.entryconfig(1, state=DISABLED) # open after Browse / Edit, we need indir and type
    filemenu.entryconfig(2, state=DISABLED)
    filemenu.entryconfig(3, state=DISABLED)
    filemenu.entryconfig(4, state=DISABLED)
    filemenu.entryconfig(5, state=DISABLED)
    
    # camera menu
    cameramenu = Menu(menubar, tearoff=0)
    cameramenu.add_command(label="New", command = menu_camera_new)
    cameramenu.add_command(label="Open camera", command = menu_camera_new)
    menubar.add_cascade(label="Camera", menu=cameramenu)

    helpmenu = Menu(menubar, tearoff=0)
    helpmenu.add_command(label="Help Index", command=donothing)
    helpmenu.add_command(label="About...", command=donothing)
    menubar.add_cascade(label="Help", menu=helpmenu)

    root.config(menu=menubar)
    
    _timestamp = datetime.now()
    
    # fill in combobox
    result = DX.get_indirs(config_files_xml)
    dict_filename_usedate = {}
    for tfile in result:
        #print("infile: " + tfile)
        attribute = result[tfile]
        searchattr = 'usedate'
        for attribut in attribute:
            #print("  " + attribut + " = " + attribute[attribut])
            if attribut == searchattr:
                dict_filename_usedate[tfile] = attribute[searchattr]
        
    # descending by usedate
    sorted_d = dict( sorted(dict_filename_usedate.items(), key=operator.itemgetter(1), reverse=True))
    # make list
    ii = 0
    indexes = []
    for tfile in sorted_d:
        combobox_indir.insert(END, tfile)
        if not os.path.isdir(tfile):
            #print("INDIR: " + tfile + " INDEX: " + str(ii))
            indexes.append(ii) # list of indizes to grey out because dir does not exist
        ii += 1
    if ii > 0:
        combobox_indir.select_set(0)
        button_indir_from_list.config(state = NORMAL)
    else: 
        button_indir_from_list.config(state = DISABLED)
    for ii in indexes:
        combobox_indir.itemconfig(ii, fg="gray")

    # fill out combobox
    result = DX.get_outdirs(config_files_xml)
    dict_filename_usedate = {}
    for tfile in result:
        #print("infile: " + tfile)
        attribute = result[tfile]
        searchattr = 'usedate'
        for attribut in attribute:
            #print("  " + attribut + " = " + attribute[attribut])
            if attribut == searchattr:
                dict_filename_usedate[tfile] = attribute[searchattr]
        
    # descending by usedate
    sorted_d = dict( sorted(dict_filename_usedate.items(), key=operator.itemgetter(1), reverse=True))
    # make list
    ii = 0
    indexes = []
    for tfile in sorted_d:
        combobox_outdir.insert(END, tfile)
        if not os.path.isdir(tfile):
            print("OUTDIR: " + tfile + " INDEX: " + str(ii))
            indexes.append(ii) # list of indizes to disable because dir does not exist
        ii += 1
    if ii > 0:
        combobox_outdir.select_set(0)
        button_outdir_from_list.config(state = NORMAL)
    else: 
        button_outdir_from_list.config(state = DISABLED)
    for ii in indexes:
        combobox_outdir.itemconfig(ii, fg="gray")
        
def get_camera_xml(): # returns dict with all cameras, types and suffixes
    ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
    cameraname = "Retina Reflex"
    ctype      = "JPEG"
    suffix     = "JPG"
    rc = DX.new_camera_type_suffix(config_files_xml, cameraname, ctype, suffix, ts) 
    suffix     = "JPEG"
    rc = DX.new_camera_type_suffix(config_files_xml, cameraname, ctype, suffix, ts) 
    ctype      = "VIDEO"
    suffix     = "MOV"
    rc = DX.new_camera_type_suffix(config_files_xml, cameraname, ctype, suffix, ts) 
    # dateimeister_config_xml.py returns suffixes as list we need them as a comma separated string
    dict_cameras = {}
    dict_cameras = DX.get_cameras_types_suffixes(config_files_xml)
    #print("Cameras: " + str(dict_cameras))
    dict_t = {}
    for camera in dict_cameras:
        dict_t[camera] = {}
        type_num = 0
        for type in dict_cameras[camera]:
            type_num += 1
            suffixes = ", ".join(dict_cameras[camera][type])
            dict_t[camera][type] = suffixes
            print("Camera: " + camera + " Type: " + type + " Suffixes: " + suffixes)
            if len(suffixes) == 0:
                messagebox.showerror("INIT", "Camera " + camera + " type " + type + " no suffix defined")
                exit()
        if type_num == 0:
            messagebox.showerror("INIT", "Camera " + camera + " no type defined")
            exit()
    return dict_t

def timer_end():
    print("Timer has elapsed")

def donothing():
    print("Menuitem not yet implemented")
    
def lb_gen_double(event):
    Button_be_pressed(event)
    
def lb_camera_double(event):
    B_camera_press(event)

def combobox_indir_double(event = None):
    selected_indices = combobox_indir.curselection()
    indir = ",".join([combobox_indir.get(i) for i in selected_indices]) # because listbox has single selection
    label_indir.config(text = indir)

def combobox_outdir_double(event = None):
    selected_indices = combobox_outdir.curselection()
    outdir = ",".join([combobox_outdir.get(i) for i in selected_indices]) # because listbox has single selection
    label_outdir.config(text = outdir)

def combobox_indir_check_exist(event):
    index = combobox_indir.curselection()[0]
    indir = combobox_indir.get(index) # because listbox has single selection
    print("current selection is: " + indir + " INDEX: " + str(index))
    if not os.path.isdir(indir):
        combobox_indir.selection_clear(index) # dont select, MessageBox
        messagebox.showerror("showerror", "Indir: " + indir + " does not exist, choose another one")
    
def combobox_outdir_check_exist(event):
    index = combobox_outdir.curselection()[0]
    outdir = combobox_outdir.get(index) # because listbox has single selection
    print("current selection is: " + outdir + " INDEX: " + str(index))
    if not os.path.isdir(outdir):
        combobox_outdir.selection_clear(index) # dont select, MessageBox
        messagebox.showerror("showerror", "outdir: " + outdir + " does not exist, choose another one")
    
def open_config():
    global config_file
    # get config_files for indir / type
    
    endung = 'xml'
    config_file = fd.askopenfilename(initialdir = os.path.join(datadir, config_files_subdir), filetypes=[("config files", endung)])
    filemenu.entryconfig(4, state=NORMAL)
    root.title(title + ' ' + config_file)
    filemenu.entryconfig(2, state=NORMAL)

def apply_config():
    tree = ET.parse(config_file)
    root = tree.getroot()
    time = root.attrib['time']
    print(time)    
    for thumbnail in root.findall('thumbnail'):
        #print (thumbnail.attrib['filename'])   
        image = thumbnail.find('image').text
        mystate = thumbnail.find('state').text
        #print(image)
        #print(mystate)
        # apply config
        if image in _dict_thumbnails[_imagetype]:
            if _dict_thumbnails[_imagetype][image] in thumbnails[_imagetype]:
                if mystate == "state.INCLUDE":
                    _dict_thumbnails[_imagetype][image].setState(state.INCLUDE)
                else:
                    _dict_thumbnails[_imagetype][image].setState(state.EXCLUDE)
            else:
                print("thumbnail for " + _imagetype + " file " + image + " not found")
                print(thumbnails)
        else:
            print("Imagefile: " + image + " not found in _dict thumdnails of type " + _imagetype)
    historize_process()


def save_config(): # Config-xml speichern
    print("Config File is: " + config_file)
    if config_file != "":
        write_config(config_file)
        # update config-file-entry in xml. will automatically create new entry if type or infile does not exist
        update_config_xml(config_file)
    else:
        saveas_config()

def saveas_config(): # Config-xml unter neuem Namen sichern
    global config_file
    endung = 'xml'
    config_file = fd.asksaveasfilename(initialdir = os.path.join(datadir, config_files_subdir), filetypes=[("config files", endung)])
    if (len(config_file) > 0):
        match = re.search(rf".*?{endung}$", config_file)
        if match:
            filename = config_file
        else:
            filename = config_file + '.' + endung
            config_file = filename
        write_config(filename)
        # update config-file-entry in xml. will automatically create new entry if type or infile does not exist
        update_config_xml(config_file)
        
        root.title(title + ' ' + config_file)
        filemenu.entryconfig(2, state=NORMAL) # Save
        filemenu.entryconfig(3, state=NORMAL) # Save As
        filemenu.entryconfig(4, state=NORMAL) # Apply config

def update_config_xml(config_file): # Config-xml unter neuem Namen sichern und update
    # update config-file-entry in xml. will automatically create new entry if type or infile does not exist
    ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
    indir = label_indir.cget('text')
    # lower and slash instead of backslash
    indir = re.sub(r'\\', '/', indir).lower()
    my_config_file = re.sub(r'\\', '/', config_file).lower()
    #print("*** new config_file: " + my_config_file)

    result, sorted_d = get_dict_of_config_files(indir, _imagetype)
    if my_config_file not in result: # this is a new file, so we have to clean up the xml entries in order to stay within max_configfiles
        # delete oldest files until max_configfiles - 1 is reached (because a new one will be created)
        #get dict descending by usedate and result with all attributes
        # in the first pass delete all Entries where file does not exist,afterwards delete entries for existing files if necessary
        # delete only if new config-file does not exist
        for loop in range(1, 3):
            result, sorted_d = get_dict_of_config_files(indir, _imagetype) # we have to do this because list of config_files is changed between loops
            list_cfgfiles = []
            for t_cfg in sorted_d:
                list_cfgfiles.append(t_cfg)
            num_to_delete = len(list_cfgfiles) - int(max_configfiles) + 1
            if num_to_delete > 0:
                #print(str(list_cfgfiles))
                ii = 0
                for t in reversed(list_cfgfiles): # now the oldest are on top
                    if ii < num_to_delete:
                        if loop == 1: # in the first pass only delete entries for not existing files
                            if not os.path.isfile(t):
                                DX.delete_cfgfile(config_files_xml, indir, _imagetype, t)
                                ii += 1
                        else: # delete also existing files if necessary
                            DX.delete_cfgfile(config_files_xml, indir, _imagetype, t)
                            ii += 1
                    else:
                        break
    # now create new entry for my_config_file
    DX.new_cfgfile(config_files_xml, indir, _imagetype, my_config_file, ts, num_images)
    # update usedate in config_files_xml
    DX.update_cfgfile(config_files_xml, indir, _imagetype, my_config_file, ts, num_images)
    # finally update the recent files menu
    update_recent_menu(indir, _imagetype)

def update_recent_menu(indir, imagetype):
    # descending by usedate
    result, sorted_d = get_dict_of_config_files(indir, imagetype)
    
    recentmenu.delete(0, "end")
    ii = 0
    for item in sorted_d:
        usedate      = result[item]['usedate']
        mynum_images = result[item]['num_images']
        labeltext = item + ' (usedate: ' + usedate + ' ,images: ' + mynum_images + ')'
        recentmenu.add_command(label=labeltext, command = lambda item=item: recent_config(item))
        print("  config_file: " + labeltext)
        if not os.path.isfile(item):
            recentmenu.entryconfig(ii, state = DISABLED)
        ii += 1
    if ii == 0:
        filemenu.entryconfig(5, state=DISABLED)


def write_config(filename): # Config-xml unter neuem Namen sichern
    file1 = open(filename, "w")
    
    s = '<?xml version="1.0" encoding="iso-8859-1"?>' + "\n"
    file1.write(s)
    ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())

    s = '<thumbnails time="' + ts + '">' + "\n"
    file1.write(s)
    for thumbnail in thumbnails[_imagetype]:
        s = "    <thumbnail filename=\"" + thumbnail.getFile() + "\">\n"
        file1.write(s)
        s = "        <image>" + str(thumbnail.getFile()) + "</image>\n"
        file1.write(s)
        s = "        <state>" + str(thumbnail.getState()) + "</state>\n"
        file1.write(s)
        s = "    </thumbnail>\n"
        file1.write(s)
    s = '</thumbnails>' + "\n"
    file1.write(s)
    # Closing file
    file1.close()
    
def get_dict_of_config_files(pindir, imagetype): # returns dict sorted by usedate asc
    # lower and slash instead of backslash
    indir = re.sub(r'\\', '/', pindir).lower()
    result = DX.get_cfgfiles(config_files_xml, indir, imagetype)
    dict_filename_usedate = {}
    for cfg_file in result:
        print("config_file: " + cfg_file)
        attribute = result[cfg_file]
        searchattr = 'usedate'
        for attribut in attribute:
            print("  " + attribut + " = " + attribute[attribut])
            if attribut == searchattr:
                dict_filename_usedate[cfg_file] = attribute[searchattr]
        
    # descending by usedate
    sorted_d = dict( sorted(dict_filename_usedate.items(), key=operator.itemgetter(1), reverse=True))
    return result, sorted_d


def recent_config(item):
    global config_file
    print("** Menuitem selected: " + item)
    config_file = item
    filemenu.entryconfig(4, state=NORMAL)
    root.title(title + ' ' + config_file)
    filemenu.entryconfig(2, state=NORMAL)
    

def tooltip_imagefile(event):
    global _tt, _tooltiptext, _timestamp
    tsnow = datetime.now()
    tdiff = abs(tsnow - _timestamp)
    #print("*** Timer has finished, microsecons is: ", tdiff.microseconds)
    if  tdiff.microseconds > 100000:
        #print("Timer has finished, microsecons is: ", tdiff.microseconds)
        _timestamp = tsnow
    else:
        return
    # Tooltip
    #x, y = canvas_gallery.winfo_pointerxy()
    text = "no image available"
    if len(thumbnails) > 0:
        canvas_x = canvas_gallery.canvasx(event.x)
        canvas_y = canvas_gallery.canvasy(event.y)
        thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
        if thumbnail is not None:
            text = thumbnail.getFile()
            #print("Image clicked: " + text)
        if text != _tooltiptext:
            _tt.update(text)
            _tooltiptext = text
            stop_all_players()
            # if file is video, play video
            if thumbnail is not None:
                player = thumbnail.getPlayer()
                if player is not None: # this is a video
                    player.pstart()
                    player.setDelay(delay_default)
                    fps   = player.getFPS()
                    fc    = player.getFrameCount()
                    delay = player.getDelay()
                    frames_per_second = 1000 / delay
                    duration_in_seconds = fc / frames_per_second
                    #print ("FPS is: ", fps, " Total Num of Frames is: ", fc, " Delay is: ", delay, " calc duration is: " + str(duration_in_seconds))
                    context_menu.entryconfig(2, state="normal")
                else:
                    context_menu.entryconfig(2, state="disabled")

def focus_out(event):
    #print("***lost Focus")
    a = 0
    #stop_all_players()
    

def on_window_resize(event): # das funktioniert nicht rihtig. Die übergebenen Zahlen sind falsch und der Handler wird unglaublich oft aufgerufen
    width = event.width
    height = event.height
    #print("Window resized to width: " + str(width) + " height: " + str(height))

def Press_indir(*args):
    if _debug:
        print('Dateimeister_support.Press_indir')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    indir = fd.askdirectory() 
    print ("indir %s" % indir)
    #clear_textbox(combobox_indir)
    label_indir.config(text = indir)

def Press_outdir(*args):
    if _debug:
        print('Dateimeister_support.Press_outdir')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    #outdir = fd.askopenindir() 
    outdir = fd.askdirectory() 
    print ("outdir %s" % outdir)
    #clear_textbox(combobox_outdir)
    label_outdir.config(text = outdir)

def B_camera_press(*args):
    global oldcamera
    if _debug:
        print('Dateimeister_support.B_camera_press')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    # get selected indices
    selected_indices = lb_camera.curselection()
    thiscamera = ",".join([lb_camera.get(i) for i in selected_indices]) # weil wir single für die Listbox gewählt haben
    print ("Kamera ist " + thiscamera)
    clear_textbox(o_camera)
    insert_text(o_camera, thiscamera)
    _button_be.config(state = DISABLED) # browse / edit will throw error if not generate after chosing camera
    button_call.config(state = NORMAL)
    if thiscamera != oldcamera:
        _button_undo.config(state = DISABLED)    
        _button_redo.config(state = DISABLED)
        clear_text(t_text1)
        canvas_gallery.delete("all")
        filemenu.entryconfig(1, state=DISABLED)
        _button_exclude.config(state = DISABLED)
        _button_include.config(state = DISABLED)
        button_save.config(state = DISABLED)
        button_exec.config(state = DISABLED)
        _button_duplicates.config(state = DISABLED)
        label_num.config(text = "0")
        clear_textbox(lb_gen)
        oldcamera = thiscamera
        if _imagetype in thumbnails:
            print("try to delete thumbnails...")
            thumbnails[_imagetype].clear()
        if _imagetype in _dict_thumbnails:
            print("try to delete dict_thumbnails...")
            _dict_thumbnails[_imagetype] = {}

def state_gen_required():
    _button_be.config(state = DISABLED) # browse / edit will throw error if not generate after chosing camera
    _button_undo.config(state = DISABLED)    
    _button_redo.config(state = DISABLED)
    clear_text(t_text1)
    canvas_gallery.delete("all")
    filemenu.entryconfig(1, state=DISABLED)
    _button_exclude.config(state = DISABLED)
    _button_include.config(state = DISABLED)
    button_save.config(state = DISABLED)
    button_exec.config(state = DISABLED)
    _button_duplicates.config(state = DISABLED)
    #button_call.config(state = DISABLED)
    label_num.config(text = "0")
    clear_textbox(lb_gen)
    if _imagetype in thumbnails:
        print("try to delete thumbnails...")
        thumbnails[_imagetype].clear()
    if _imagetype in _dict_thumbnails:
        print("try to delete dict_thumbnails...")
        _dict_thumbnails[_imagetype] = {}

def new_dir_in_xml(dirtype, max_dirs, dir_chosen, ts):
    do_del = True
    if dirtype == 'indir':
        d = DX.get_indirs(config_files_xml)
        if dir_chosen in d:
            do_del = False # existing dir, no cleanup
    elif dirtype == 'outdir':
        d = DX.get_outdirs(config_files_xml)
        if dir_chosen in d:
            do_del = False # existing dir, no cleanup
    # delete dir-entrie(s) from config_files_xml only if a new one has been selected
    print("do_del: " + str(do_del) + " dir_chosen: " + dir_chosen)
    if do_del: # 2 pass: in the first we delete entries with not existing dir, in the second existing dirs (if necessary)
        for loop in range(1,3): # 3 is excluded
            if dirtype == 'indir':
                d = DX.get_indirs(config_files_xml)
            elif dirtype == 'outdir':
                d = DX.get_outdirs(config_files_xml)
            # sort descending by usedate
            dict_dir_usedate = {}
            for ii in d:
                dict_dir_usedate[ii] = d[ii]['usedate'] # dir -> usedate
            sorted_d = dict( sorted(dict_dir_usedate.items(), key=operator.itemgetter(1), reverse=True))
            list_dirs = []
            for tdir in sorted_d:
                list_dirs.append(tdir)
            num_to_delete = len(list_dirs) - int(max_dirs) + 1 # +1 for we will make a new dir later. already deleted dirs are no more in DX.get_dirs 
            if loop == 1:
                # delete only not existing dirs
                if num_to_delete > 0:
                    ii = 0
                    for t in reversed(list_dirs): # now the oldest are on top
                        if not os.path.isdir(t):
                            if ii < num_to_delete:
                                if dirtype == 'indir':
                                    DX.delete_indir(config_files_xml, t)
                                elif dirtype == 'outdir':
                                    DX.delete_outdir(config_files_xml, t)
                                ii += 1
                            else:
                                break
            elif loop == 2:
                # delete existing dirs if necessary
                if num_to_delete > 0:
                    ii = 0
                    for t in reversed(list_dirs): # now the oldest are on top
                        if ii < num_to_delete:
                            if dirtype == 'indir':
                                DX.delete_indir(config_files_xml, t)
                            elif dirtype == 'outdir':
                                DX.delete_outdir(config_files_xml, t)
                            ii += 1
                        else:
                            break
    # will add xml node if not existing or update usedate if existing
    if dirtype == 'indir':
        DX.new_indir (config_files_xml, dir_chosen, "", "", ts, 0)
    if dirtype == 'outdir':
        DX.new_outdir(config_files_xml, dir_chosen, ts)

    
def Press_generate(*args):
    global _dict_firstname_fullname, _dict_duplicates, dict_gen_files, dict_gen_files_delete, _dict_duplicates_sourcefiles, \
        _outdir, _win_duplicates, dict_source_target, dict_relpath, dict_gen_files_delrelpath, dict_source_target_tooold, dict_outdirs
    if _debug:
        print('Dateimeister_support.B_camera_press')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    
    # cleanup
    stop_all_players() # should not continue running 
    if _win_duplicates is not None: # stop MyDuplicates-Objekt
        _win_duplicates.close_handler()
        _win_duplicates = None
    # reset all process-states
    _list_processids = []
    _processid_akt  = 0
    _processid_high = 0
    _processid_low  = 999999
    _button_undo.config(state = DISABLED)    
    _button_redo.config(state = DISABLED)
    
    clear_text(t_text1)
    canvas_gallery.delete("all")

    # get indir, outdir, camera
    indir  = label_indir.cget('text')
    outdir = label_outdir.cget('text')
    thiscamera = o_camera.get();
    if not indir:
        messagebox.showerror("showerror", "kein Indir ausgewählt")
        b_button1.focus_set()
        return None
    if not outdir:
        messagebox.showerror("showerror", "kein outdir ausgewählt")
        b_button_outdir.focus_set()
        return None
    if not thiscamera:
        messagebox.showerror("showerror", "keine Kamera ausgewählt")
        b_button2.focus_set()
        return None
    if cb_recursive_var.get():
        recursive = "j"
    else:
        recursive = "n"
    if cb_prefix_var.get():
        _use_camera_prefix = True
    else:
        _use_camera_prefix = False
    if cb_addrelpath_var.get():
        addrelpath  = "j"
    else:
        addrelpath  = "n"
    print ("INDIR is  " + indir)
    
    # we try to open the templatefile. we do it here because one does not have to stop the program when file not found. 
    # Just correct it and run generate again
    get_templates() # read them into dict_templates (global)
    
    clear_text(t_text1)
    clear_textbox(lb_gen)

    _dict_duplicates = {}
    owndir = os.getcwd()
    dict_gen_files = {}
    dict_gen_files_delete = {}
    dict_source_target = {}
    dict_source_target_jpeg = {}
    dict_source_target_tooold = {}
    dict_relpath = {}
    dict_gen_files_delrelpath = {}
    _dict_firstname_fullname = {}
    dict_outdirs = {}

    # now make an entry for this indir / outdir. For indir we use the already existing function for config_files without type / config_file
    ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())

    this_i = re.sub(r'\\', '/', indir).lower()
    # delete indir-entries from xml if number gt than max from ini, oldest first
    new_dir_in_xml('indir', max_indirs, this_i, ts)

    this_o = re.sub(r'\\', '/', outdir).lower()
    # delete outdir-entries from xml if number gt than max from ini, oldest first
    new_dir_in_xml('outdir', max_outdirs, this_o, ts)

    for dateityp in _dict_cameras[thiscamera]:
        # cleanup
        # in Python kann man offenbar nicht automatisch einen Eintrag anlegen, indem man ein Element an die Liste hängt
        if dateityp in thumbnails:
            thumbnails[dateityp].clear() # damit werden implizit jetzt alle Bilder gelöscht
        else:
            thumbnails[dateityp] = []

        subdir = _dict_subdirs[dateityp]
        thisoutdir = outdir + "/" + subdir
        _outdir = thisoutdir # for setting title of duplicate-window
        dict_outdirs[dateityp] = thisoutdir
        endung= _dict_cameras[thiscamera][dateityp]
        if _use_camera_prefix:
            target_prefix = thiscamera + '_'
        else:
            target_prefix = ''
        dict_source_target[dateityp] = {}
        dict_relpath[dateityp] = {}
        dict_source_target[dateityp], dict_source_target_jpeg[dateityp], dict_source_target_tooold[dateityp] = \
          dateimeister(dateityp, endung, indir, thisoutdir, addrelpath, recursive, target_prefix, dict_relpath[dateityp])
        dict_relpath[dateityp] = dict(reversed(list(dict_relpath[dateityp].items())))
        for ii in dict_relpath[dateityp]:
            print(" > ", ii, " files: ", dict_relpath[dateityp][ii])
        num_files = 0
        for thisfile in dict_source_target[dateityp]:
            #print("IN: " + thisfile + " OUT: " + dict_source_target[dateityp][thisfile])
            num_files += 1
        print(dateityp + " F NUM: " + str(num_files))
        # save name for cmdfile
        cmd_file_name = "_copy_" + dateityp + '.cmd'
        cmd_file_full = os.path.join(datadir, cmd_files_subdir, cmd_file_name)
        # generierte Dateien in dict festhalten
        dict_gen_files[dateityp] = cmd_file_full
        #print("dict_gen_files[dateityp]: ", str(dict_gen_files[dateityp]), " datadir is: ", datadir)

        # save name for delete files
        # important: subdir MUST NOT start with a slash!
        cmd_file_name_delete = "_delete_" + dateityp + '.cmd'
        cmd_file_full_delete = os.path.join(datadir, cmd_files_subdir, cmd_file_name_delete)
        # generierte Dateien in dict festhalten
        dict_gen_files_delete[dateityp] = cmd_file_full_delete
        #print("dict_gen_files_delete[dateityp]: ", str(dict_gen_files_delete[dateityp]))

        # save name for delrelpath files
        cmd_file_name_delrelpath = "_delrelpath_" + dateityp + '.cmd'
        cmd_file_full_delrelpath = os.path.join(datadir, cmd_files_subdir, cmd_file_name_delrelpath)
        # generierte Dateien in dict festhalten
        dict_gen_files_delrelpath[dateityp] = cmd_file_full_delrelpath
        #print("dict_gen_files_delrelpath[dateityp]: ", str(dict_gen_files_delrelpath[dateityp]))

        _dict_duplicates[dateityp] = {}
        print ("OUTDIR is " + thisoutdir + " ENDUNG is " + endung)
        #print ("OUTFILE is " + os.environ["OUTFILE"])
        # wenn die Endung wegen mehrerer Möglichkeiten (jpeg, jpg) mehr al 1 Eintrag hat, nehmen wir den letzten
        #print("'(.*?)\.({:s})' 'PIC_{:s}_$1.$2'".format(dateityp, thiscamera))
        clear_text(t_text1)
        # wir tragen die Dubletten ein       
        lineno = 0
        for this_sourcefile in dict_source_target[dateityp]:
            lineno += 1
            #print(line)
            dupl_target_file = dict_source_target[dateityp][this_sourcefile].upper() #for duplicate target  check ignore case
            if dupl_target_file not in _dict_duplicates[dateityp]:
                _dict_duplicates[dateityp][dupl_target_file] = []
            _dict_duplicates[dateityp][dupl_target_file].append(this_sourcefile) # Duplicates  
        # remove singles from  _dict_duplicates, we use a copy because we must not delete entries during iteration
        # create _dict_duplicates_sourcefiles , key = sourcefile, value = targetfile
        _dict_duplicates_sourcefiles[dateityp] = {}
        dict_h = {}
        dict_h = copy.deepcopy(_dict_duplicates[dateityp])
        for mytarget in dict_h:
            #print("Duplcate Key: " + mytarget) 
            mylist = dict_h[mytarget]
            if len(mylist) == 1: # only 1 file
                del _dict_duplicates[dateityp][mytarget]
                #print("nodupl: ", str(mylist))
            else:
                for mysource in mylist:
                    _dict_duplicates_sourcefiles[mysource] = mytarget
        #print("_dict_duplicates: " + str(_dict_duplicates[dateityp])) 

        # alle Dateien aus der gerade verarbeiteten cmd-Datei tragen wir in _dict_firstname_fullname ein, wenn type = JPEG
    regpattern = r'[\/\\]([^\/\\.]+)\.([^\/\\.]+)' # zwischen dem letzten / bzw. \ und dem letzten Punkt steht der Vorname, Nachname danach
    regpattern_source = r'"([^"]+)"' # Sourcefile
    target_file = ""
    source_file = ""
    #print("JPEGs: " + str(dict_source_target_jpeg["JPEG"]))
    for this_sourcefile in dict_source_target_jpeg["JPEG"]:
        lineno += 1
        b_match = False
        match = re.search(regpattern, this_sourcefile)
        if match:
            firstname = match.group(1)
            lastname  = match.group(2).upper()
            #print("GENERATE: firstname / lastname = " + firstname + " / " + lastname)
            b_match = True
        else: 
            #print("GENERATE unable to find firstname, lastname in: " + line)
            a = 1
        if (b_match == True):
            # Show error if no process_type available
            if lastname.upper() not in _dict_process_image:
                messagebox.showerror("GENERATE", "Section process_type, no entry in ini-file found for: " + lastname)
                exit()
            process_type = _dict_process_image[lastname].upper()
            if (process_type == "JPEG"):
                if firstname.upper() not in _dict_firstname_fullname:
                    _dict_firstname_fullname[firstname.upper()] = []
                _dict_firstname_fullname[firstname.upper()].append(this_sourcefile) # es kann ja in den ganzen Verzeichnissen mehrere jpegs mit demselben Vornamen geben  

    l_label1.config(text = "Output from Dateimeister")
            
    # die generierten Dateien in die Listbox eintragen
    for key in dict_gen_files:
        lb_gen.insert(END, key)
    lb_gen.select_set(0)
    if lb_gen.size() > 0:
        _button_be.config(state = NORMAL)
    filemenu.entryconfig(1, state=DISABLED)
    _button_exclude.config(state = DISABLED)
    _button_include.config(state = DISABLED)
    button_save.config(state = DISABLED)
    button_exec.config(state = DISABLED)
    _button_duplicates.config(state = DISABLED)
    label_num.config(text = "0")
    os.chdir(owndir)
    write_cmdfiles()
    
def get_templates():
    global dict_templates
    dict_templates = {}
    try:
        file = open(templatefile)
    except FileNotFoundError:
        print("File does not exist: " + templatefile)
    templates = file.read().replace('\n', '<<<NL>>>')
    #print(templates)
    regpattern = r'\[([^\]]+)\](.*?)\[/\1\]'
    list_t = re.findall(regpattern, templates)
    for ii in list_t:
        templatename = ii[0].upper()
        template     = ii[1]
        #print("templatename: " + templatename)
        #print(template)
        dict_templates[templatename] = template
    
    templates = re.sub(r'<<<NL>>>', '\n', templates)
    #print(templates)
        
def button_exec_pressed():
    global _win_messages
    if _win_messages is not None: # stop MyMessagesWindow-Objekt
        _win_messages.close_handler()
        _win_messages = None
    _win_messages = MyMessagesWindow(_imagetype, dict_gen_files[_imagetype], dict_gen_files_delete[_imagetype], dict_gen_files_delrelpath[_imagetype]) 

def button_save_pressed(): # overrite the cmd-file for imagetype from textbox, also the corresponding delete-file
    write_cmdfile(_imagetype)
    
def write_cmdfiles():
    for imagetype in dict_source_target:
        write_cmdfile(imagetype)

def write_cmdfile(imagetype):
    ts = strftime("%Y%m%d-%H:%M:%S", time.localtime())
    template_copy       = dict_templates["COPY"]
    template_delete     = dict_templates["DELETE"]
    template_delrelpath = dict_templates["DELRELPATH"]
    template_empty      = dict_templates["EMPTY"]
    header = _uncomment + ' generated by dateimeister ' + ts + '\n'
    # copy files
    cmd_file_full = dict_gen_files[imagetype] # filename was already built by generate()
    thiscmdfile = open(cmd_file_full, 'w')
    thiscmdfile.write(header) 
    dict_files = dict_source_target[imagetype]
    for sourcefile in dict_files:
        comment = ""
        do_include = False
        #print(imagetype + ', ' + sourcefile)
        if imagetype in _dict_thumbnails and sourcefile in _dict_thumbnails[imagetype]:
            thumbnail = _dict_thumbnails[imagetype][sourcefile]
            if thumbnail.getState() == state.EXCLUDE:
                comment = _uncomment
            else: # we have to incluse this file even if it is too old
                do_include = True
        # we also have to check if file is too old but only if include us not requqested by thumbnail (manually included)
        if do_include == False:
            if imagetype in dict_source_target_tooold and sourcefile in dict_source_target_tooold[imagetype]:
                comment = _uncomment 
        targetfile = dict_files[sourcefile]
        if platform == "WINDOWS":
            targetfile = re.sub(r'/', '\\\\', targetfile) # replace / by \
        elif platform == "UNIX":
            targetfile = re.sub(r'\\', '/', targetfile) # replace \ by /
        str_ret = template_copy
        str_ret = str_ret.replace('<source>', sourcefile)
        str_ret = str_ret.replace('<target>', targetfile)
        str_ret = re.sub(r'<<<NL>>>', '\n', str_ret) # reconstruct newline in template
        thiscmdfile.write(comment + str_ret + '\n')
    thiscmdfile.close()

    # delete files
    cmd_file_full = dict_gen_files_delete[imagetype] # filename was already built by generate()
    thiscmdfile = open(cmd_file_full, 'w')
    thiscmdfile.write(header) 
    dict_files = dict_source_target[imagetype]
    for sourcefile in dict_files:
        comment = ""
        do_include = False
        #print(imagetype + ', ' + sourcefile)
        if imagetype in _dict_thumbnails and sourcefile in _dict_thumbnails[imagetype]:
            thumbnail = _dict_thumbnails[imagetype][sourcefile]
            if thumbnail.getState() == state.EXCLUDE:
                comment = _uncomment
            else: # we have to incluse this file even if it is too old
                do_include = True
        # we also have to check if file is too old but only if include us not requqested by thumbnail (manually included)
        if do_include == False:
            if imagetype in dict_source_target_tooold and sourcefile in dict_source_target_tooold[imagetype]:
                comment = _uncomment 
        targetfile = dict_files[sourcefile]
        if platform == "WINDOWS":
            targetfile = re.sub(r'/', '\\\\', targetfile) # replace / by \
        elif platform == "UNIX":
            targetfile = re.sub(r'\\', '/', targetfile) # replace \ by /
        str_ret = template_delete
        str_ret = str_ret.replace('<source>', sourcefile)
        str_ret = str_ret.replace('<target>', targetfile)
        str_ret = re.sub(r'<<<NL>>>', '\n', str_ret) # reconstruct newline in template
        thiscmdfile.write(comment + str_ret + '\n')
    thiscmdfile.close()
    
    # delrelpath files : remove addrelpath-generated files, but only if empty
    cmd_file_full = dict_gen_files_delrelpath[imagetype] # filename was already built by generate()
    thiscmdfile = open(cmd_file_full, 'w')
    thiscmdfile.write(header)
    outdir = dict_outdirs[imagetype]
    # for cmd we need backslash, for Unix slash
    if platform == "WINDOWS":
        outdir = re.sub(r'/', '\\\\', outdir) # replace / by \
    elif platform == "UNIX":
        outdir = re.sub(r'\\', '/', outdir) # replace \ by /
    stroutfile = "@set OUTDIR=" + outdir + '\n'
    thiscmdfile.write(stroutfile) 
    for relpath in dict_relpath[imagetype]:
        comment = ""
        str_ret = template_delrelpath
        if platform == "WINDOWS":
            str_ret = str_ret.replace('<trenner>', '\\')
            relpath = re.sub(r'/', '\\\\', relpath) # replace / by \
        elif platform == "UNIX":
            str_ret = str_ret.replace('<trenner>', '/')
            relpath = re.sub(r'\\', '/', relpath) # replace \ by /
        str_ret = str_ret.replace('<relpath>', relpath)
        str_ret = re.sub(r'<<<NL>>>', '\n', str_ret) # reconstruct newline in template
        thiscmdfile.write(comment + str_ret + '\n')
    # add the script
    str_ret = template_empty
    str_ret = re.sub(r'<<<NL>>>', '\n', str_ret) # reconstruct newline in template
    l = str_ret.split('\n')
    for ii in l:
       thiscmdfile.write(ii + '\n') 
    thiscmdfile.close()

def Button_be_pressed(*args):
    global _canvas_gallery_width_visible
    global _canvas_gallery_width_images
    global _canvas_gallery_width_all
    global _lastposition, _dict_file_image
    global _imagetype, _list_processids, _processid_high, _processid_akt, _processid_low, _dict_duplicates, \
        _duplicates, num_images, config_file, _dict_duplicates_sourcefiles, _win_duplicates, dict_source_target

    if _debug:
        print('Dateimeister_support.Press_be_out')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

    if _win_duplicates is not None: # stop MyDuplicates-Objekt
        _win_duplicates.close_handler()
        _win_duplicates = None
    # reset all process-states
    _list_processids = []
    _processid_akt  = 0
    _processid_high = 0
    _processid_low  = 999999
    _button_undo.config(state = DISABLED)    
    _button_redo.config(state = DISABLED)
    config_file = ""   # after change of imagetype (possibly) has to be selected new by user
    root.title(title)
    
    clear_text(t_text1)
    canvas_gallery.delete("all")

    if not lb_gen.curselection() == ():
        selected_indices = lb_gen.curselection()
    else:
        messagebox.showerror("showerror", "no Imagetype selected")
        lb_gen.focus_set()
        return None
    thistype = ",".join([lb_gen.get(i) for i in selected_indices]) # weil wir single für die Listbox gewählt haben
    #print("dict_gen_files: ", str(dict_gen_files))
    filename = dict_gen_files[thistype]
    imagetype = thistype
    _imagetype = imagetype # auch in globaler Variable festhalten, da wir das an vielen Stellen brauchen
    subdir = _dict_subdirs[imagetype]
    stop_all_players() # should not continue running 
    # in Python kann man offenbar nicht automatisch einen Eintrag anlegen, indem man ein Element an die Liste hängt
    if imagetype in thumbnails:
        thumbnails[imagetype].clear() # damit werden implizit jetzt alle Bilder gelöscht
    else:
        thumbnails[imagetype] = []
    # delete all fsimage by close-call
    for t in _dict_file_image:
        u = _dict_file_image[t]
        u.close_handler_external()
    _dict_file_image = {}
    l_label1.config(text = "Output from Dateimeister : " + filename)
    _dict_image_lineno[imagetype] = {} # in Python muss das sein, sonst gehts in der nächsten Ebene nicht
    lineno = 0
    #print(str(dict_source_target))
    for this_sourcefile in dict_source_target[imagetype]:
        this_targetfile = dict_source_target[imagetype][this_sourcefile]
        lineno += 1
        source_without_dir = re.sub(re.escape(label_indir.cget('text')), '', this_sourcefile)
        source_without_dir = re.sub(r'^[\\\/]', '', source_without_dir)
        target_without_dir = re.sub(re.escape(label_outdir.cget('text')), '', this_targetfile)
        target_without_dir = re.sub(r'[\\\/]', '/', target_without_dir) # replace all backslashes by slash
        my_subdir = subdir
        my_subdir = re.sub(r'[\\\/]', '/', my_subdir) # replace all backslashes by slash
        target_without_dir = re.sub(re.escape(my_subdir), '', target_without_dir) # replace subdir
        target_without_dir = re.sub(r'^[\\\/]+', '', target_without_dir) # replace first slash
        text_w = 80
        #thisline = "{source:<{len1}s}{target:<{len1}s}\n".format(len1 = text_w, source = source_without_dir, target = target_without_dir)
        thisline = "{source:<{len1}s}{target:<{len1}s}\n".format(len1 = text_w, source = this_sourcefile, target = this_targetfile)
        insert_text(t_text1, thisline)
        _dict_image_lineno[imagetype][this_sourcefile] = lineno
    
    # wir suchen in der cmd-Datei die Endung für jedes Imagefile. Damit suchen wir in _dict_process_image nach einem Eintrag
    # wenn JPEG, dann verarbeiten wir die Zeile und verwenden das mutmaßliche JPEG_Bild in der Gallerie. Wenn use_jpeg gefunden wird
    # suchen wir nach einem passenden JPEG. Falls die Endung im dict nicht gefunden wird, verwenden wir ebenfalls use_jpeg. Später
    # können hier passende RAW-DLLs aufgerufen werden, z.b. mit Name der DLL in der Ini-Datei
    canvas_height = canvas_gallery.winfo_height()
    canvas_width  = canvas_gallery.winfo_width()
    _canvas_gallery_width_visible = canvas_gallery.winfo_width() # Fensterbreite
    _lastposition = 0
    _dict_thumbnails[imagetype] = {}
    _dict_thumbnails_lineno[imagetype] = {}
    num_images = 0
    for file in dict_source_target[imagetype]:
        num_images += 1
        this_targetfile = dict_source_target[imagetype][file]
        # wir brauchen die Endung der Datei und den Vornamen
        regpattern = r'[\/\\]([^\/\\."]+)\.([^\/\\."]+)' # zwischen dem letzten / bzw. \ und dem letzten Punkt steht der Vorname, Nachname danach
        match = re.search(regpattern, file)
        if match:
            firstname  = match.group(1)
            lastname   = match.group(2).upper()
            #print("firstname / lastname = " + firstname + " / " + lastname)
        else: 
            print("unable to find firstname, lastname for: " + file)
        # wir brauchen die Methode aus der ini-Datei, mit der wir das Bild verarbeiten sollen
        process_type = _dict_process_image[lastname].upper()
        #print("Process Type is: " + process_type)
        player = None # only for video
        if (process_type == "JPEG"):
            showfile = file # Image-file to show in Canvas
        elif process_type == "USE_JPEG":
            if firstname.upper() in _dict_firstname_fullname:
                showfile = _dict_firstname_fullname[firstname.upper()][-1]
                #print ("*** JPEG found for " + file + " using " + showfile)
            else:
                showfile = "none"
                print ("*** No JPEG found for " + file + " using " + showfile)
                process_type = "none" # rectangle instead
        elif process_type == 'VIDEO':
            print("try to create new videoplayer...")
            # create new videoplayer
            player   = DV.VideoPlayer(root, file, canvas_gallery, canvas_width, canvas_height, _lastposition)
            image_width, image_height, pimg = player.get_pimg()
            showfile = file
        else: # hier später mal ein Aufruf, um RAW oder was auch immer nach JPEG zu konvrtieren, aber jetzt erstmal Default nciht gefunden anzeigen
            showfile = "none"
        if file in _dict_duplicates_sourcefiles: # for storing in Thumbnail
            duplicate = 'j'
        else:
            duplicate = 'n'
        #print ("Process-type, file" , process_type, ' ', file)
        this_lineno = _dict_image_lineno[imagetype][file]
        if  process_type != "none": 
            if process_type != 'VIDEO': # we have to convert image to photoimage
                img  = Image.open(showfile)
                image_width_orig, image_height_orig = img.size
                faktor = canvas_height / image_height_orig
                newsize = (int(image_width_orig * faktor), int(image_height_orig * faktor))
                r_img = img.resize(newsize, Image.Resampling.NEAREST)
                image_width, image_height = r_img.size
                #print("try to print " + file + " width is " + str(image_width) + "(" + str(image_width_orig) + ")" + " height is " + str(image_height) + "(" + str(image_height_orig) + ")" \
                #   + " factor is " + str(faktor))
                pimg = ImageTk.PhotoImage(r_img)
            # an den Thumbnails führen wir einige Attribute, außerdem sorgt die Liste dafür, dass der Garbage-Kollektor das Bild nicht löscht.
            # indem wir es in eine Liste einfügen, bleibt der Referenz-Count > 0
            id = canvas_gallery.create_image(_lastposition, 0, anchor='nw',image = pimg, tags = 'images')
            text_id = canvas_gallery.create_text(_lastposition, 0, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
            rect_id = canvas_gallery.create_rectangle(canvas_gallery.bbox(text_id), outline="blue", fill = "white", tag = 'rect')
            text_id_num = canvas_gallery.create_text(_lastposition, image_height - 10, text=str(num_images), fill="red", font=('Helvetica 10 bold'), anchor =  "sw", tag = "numbers")
            rect_id_num = canvas_gallery.create_rectangle(canvas_gallery.bbox(text_id_num), outline="blue", fill = "white", tag = "rect_numbers")
            
            if player is not None:
                player.setId(id)
            myimage = MyThumbnail(pimg, _lastposition, _lastposition + image_width, file, showfile, id, \
                text_id, rect_id, this_lineno, player, duplicate, canvas_gallery, dict_source_target[imagetype][file], t_text1)
            if file in dict_source_target_tooold[imagetype]: #start with state.exclude
                myimage.setState(state.EXCLUDE)
                myimage.set_tooold(True)
                canvas_gallery.itemconfig(text_id, text="EXC OVW")
            thumbnails[imagetype].append(myimage)
            _dict_thumbnails[imagetype][file] = myimage # damit können wir auf thumbnails mit den Sourcefilenamen zugreifen, z.B. für Duplicates
            _dict_thumbnails_lineno[imagetype][str(this_lineno)] = myimage # damit können wir auf thumbnails mit der lineno in text widget zugreifen
            _lastposition += image_width + gap 
            if myimage.getDuplicate() == 'j':
                text_id_dup = canvas_gallery.create_text(_lastposition - gap, 0, text="DUP", fill="green", font=('Helvetica 10 bold'), anchor =  tk.NE, tag = "dup_text")
                rect_id_dup =canvas_gallery.create_rectangle(canvas_gallery.bbox(text_id_dup), outline="blue", fill = "white", tag = 'dup_rect')
            #print ("*** File " + file + " Type " + imagetype + " Lineno: " + str(_dict_image_lineno[imagetype][file]))
            if process_type != 'VIDEO':
                img.close()
        else: # wir haben kein Bild, ein Rechteck einfügen
            image_height = canvas_height
            image_width  = int(canvas_height * 4 / 3)
            id = canvas_gallery.create_rectangle(_lastposition, 0, _lastposition + image_width, canvas_height, fill="blue", tags = 'images')
            text_id = canvas_gallery.create_text(_lastposition, 0, text="EXCLUDE", fill="red", font=('Helvetica 10 bold'), anchor =  tk.NW, tag = "text")
            rect_id = canvas_gallery.create_rectangle(canvas_gallery.bbox(text_id), outline="blue", fill = "white")
            text_id_num = canvas_gallery.create_text(_lastposition, image_height - 10, text=str(num_images), fill="red", font=('Helvetica 10 bold'), anchor =  "sw", tag = "numbers")
            rect_id_num = canvas_gallery.create_rectangle(canvas_gallery.bbox(text_id_num), outline="blue", fill = "white", tag = "rect_numbers")
            myimage = MyThumbnail(0, _lastposition, _lastposition + image_width, file, showfile, id, \
                text_id, rect_id, this_lineno, player, duplicate, canvas_gallery, dict_source_target[imagetype][file], t_text1)
            if file in dict_source_target_tooold[imagetype]: #start with state.exclude
                myimage.setState(state.EXCLUDE)
                myimage.set_tooold(True)
                canvas_gallery.itemconfig(text_id, text="EXC OVW")
            thumbnails[imagetype].append(myimage)
            _dict_thumbnails[imagetype][file] = myimage
            _lastposition += image_width + gap 
    canvas_gallery.tag_raise("dup_rect")
    canvas_gallery.tag_raise("dup_text")
    canvas_gallery.tag_raise("rect")
    canvas_gallery.tag_raise("text")
    canvas_gallery.tag_raise("line")
    canvas_gallery.tag_raise("rect_numbers")
    canvas_gallery.tag_raise("numbers")
    # gap haben wir einmal zuviel (fürs letzte) gezählt
    _lastposition -= gap
    #print ("Canvas_gallery sichtbare Breite : " + str(_canvas_gallery_width_visible))
    # damit wir am Ende auch bis zum letzten einzelnen Bild scrollen können, fügen wir ein Rechteck ein
    if len(thumbnails[imagetype]) > 0: 
        thumbnail = thumbnails[imagetype][-1]
        rect_len = _canvas_gallery_width_visible - (thumbnail.getEnd() - thumbnail.getStart() + gap)
        canvas_gallery.create_rectangle(_lastposition, 0, _lastposition + rect_len, canvas_height, fill="yellow")
        canvas_gallery.config(scrollregion = canvas_gallery.bbox('all')) 
        _canvas_gallery_width_images = canvas_gallery.bbox('images')[2]
        _canvas_gallery_width_all    = canvas_gallery.bbox('all')[2]
        #print ("Canvas_gallery totale Breite(Images): " + str(_canvas_gallery_width_images) + " totale Breite(All): " + str(_canvas_gallery_width_all) \
        #    + " visible: " + str(_canvas_gallery_width_visible) + " lastposition: " + str(_lastposition))
    
    # Pfeiltasten für Scrollen einrichten
    canvas_gallery.focus_set()
    _button_include.config(state = NORMAL)
    _button_exclude.config(state = NORMAL)
    #print(_dict_duplicates)
    historize_process()
    if len(thumbnails[imagetype]) > 0:
        filemenu.entryconfig(1, state=NORMAL)
        filemenu.entryconfig(3, state=NORMAL)
    
    else: # if no images available we dont need config files
        filemenu.entryconfig(1, state=DISABLED)
        filemenu.entryconfig(2, state=DISABLED)
        filemenu.entryconfig(3, state=DISABLED)
        filemenu.entryconfig(4, state=DISABLED)
    _duplicates = False
    
    for mytarget in _dict_duplicates[imagetype]:
        #print("Duplcate Key: " + mytarget) 
        mylist = _dict_duplicates[imagetype][mytarget]
        if len(mylist) > 1: # es gibt 1...n Duplicates
            _duplicates = True
            break
    
    if num_images > 0: # config makes no sense for zero images
        filemenu.entryconfig(5, state=NORMAL)
        # get the config-files for indir / type:
        indir = label_indir.cget('text')
            
        # finally update recent menu
        update_recent_menu(indir, imagetype)
    
    if _duplicates:
        _button_duplicates.config(state = NORMAL)
    else:
        _button_duplicates.config(state = DISABLED)
    
    label_num.config(text = str(num_images))
    button_save.config(state = NORMAL)
    button_exec.config(state = NORMAL)

def get_thumbnail_by_position(canvas_x, canvas_y):
    index = -1
    found = False
    if _imagetype != "":
        for thumbnail in thumbnails[_imagetype]:
            start = thumbnail.getStart()
            end   = thumbnail.getEnd()
            if (canvas_x >= start and canvas_x <= end):
                index = thumbnails[_imagetype].index(thumbnail)
                #print("retrieved " + thumbnail.getFile() + " Index: " + str(index))
                found = True
                break
        if not found:
            thumbnail = None
            index = None
    else:
        thumbnail = None
        index = None
    return (thumbnail, index)

def canvas_gallery_show(event):
    #print('bbox', canvas_gallery.bbox('images'))
    canvas_gallery.focus_set()

    canvas_x = canvas_gallery.canvasx(event.x)
    canvas_y = canvas_gallery.canvasy(event.y)
    thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
    if thumbnail is not None:
        item_id = thumbnail.getId()
        display_image(thumbnail)
        print("Text sroll to lineno: ", str(thumbnail.getLineno()))
        thumbnail.scrollTextToLineno()

def delay_decr(event): # speed +
    canvas_gallery.focus_set()
    delta = -5
    canvas_x = canvas_gallery.canvasx(event.x)
    canvas_y = canvas_gallery.canvasy(event.y)
    thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
    if thumbnail is not None:
        player = thumbnail.getPlayer()
        if player is not None: # a video
            delay = player.getDelay()
            if delay + delta > 5:
                player.setDelay(delay + delta)

def delay_incr(event): # speed -
    canvas_gallery.focus_set()
    delta = 5
    canvas_x = canvas_gallery.canvasx(event.x)
    canvas_y = canvas_gallery.canvasy(event.y)
    thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
    if thumbnail is not None:
        player = thumbnail.getPlayer()
        if player is not None: # a video
            delay = player.getDelay()
            if delay + delta < 200:
                player.setDelay(delay + delta)

def delay_deflt(event): # speed normal
    canvas_gallery.focus_set()
    canvas_x = canvas_gallery.canvasx(event.x)
    canvas_y = canvas_gallery.canvasy(event.y)
    thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
    if thumbnail is not None:
        player = thumbnail.getPlayer()
        if player is not None: # a video
            delay = player.getDelay()
            player.setDelay(delay_default)

def xview(*args):
    #print (*args)
    global _canvas_gallery_width_visible
    global _canvas_gallery_width_images
    global _canvas_gallery_width_all
    s1 = 0.0
    s2 = 1.0
    scrolldelta = 0
    width_scrollbar = scroll_canvas_x.winfo_width()
    canvas_x = int(canvas_gallery.canvasx(0))
    canvas_y = int(canvas_gallery.canvasy(0))
    #print ("Scroll totale Breite(Images): " + str(_canvas_gallery_width_images) + " totale Breite(All): " + str(_canvas_gallery_width_all) \
    #    + " visible: " + str(_canvas_gallery_width_visible)  + " canvas_x: " + str(canvas_x))
    slider_width = int((_canvas_gallery_width_visible / _canvas_gallery_width_all) * width_scrollbar)
    # aktuelle Scroll-Position des Canvas
    # aktuelle position der Scrollbar
    scrollposition = scroll_canvas_x.get()[0]
    
    # wenn wir die Pfeiltasten betätigen, wollen wir auf den Anfang des nächsten (vorherigen) Bildes scrollen.
    # wenn das aktuelle Bild nur teilweise zusehen ist, scrollen wir bei Linkstaste auf den Bildbeginn
    if len(args) == 3 and args[2] == "units":
        # den scrollbetrag auf die Größe des Bildes am linken Rand setzen
        thumbnail, index = get_thumbnail_by_position(canvas_x + 11, canvas_y)
        if thumbnail is not None:
            if int(args[1]) > 0:
                scrolldelta = (thumbnail.getEnd() - canvas_x + gap)
            else:
                if canvas_x - thumbnail.getStart() > 10: # Bild links abgeschnitten, an den Anfang scrollen
                    scrolldelta = (thumbnail.getStart() - canvas_x) # ist dann negativ, was wir ja wollen
                    #print("Bild links abgeschnitten, weil canvas_x = " + str(canvas_x) + " und Bildstart = " + str(thumbnail.getStart()))
                else: #Bild ist vollständig zu sehen, also zurück zum nächsten
                    if index > 0: # es gibt einen Vorgänger
                        scrolldelta = (thumbnails[_imagetype][index - 1].getStart()) - canvas_x
                        #print("Vorgänger ist: " + thumbnails[_imagetype][index - 1].getFile() + " Start: " + str(thumbnails[_imagetype][index - 1].getStart())\
                        #    + " canvas_x is: " + str(canvas_x) + " scrolldelta is: " + str(scrolldelta))
            
            new_canvas_x = canvas_x + scrolldelta
            # nach links scrollen machr keinen Sinn, wenn wir schon ganz links stehen, analog rechts
            if (int(args[1]) < 0 and canvas_x <= 0) or (int(args[1]) > 0 and new_canvas_x >= _canvas_gallery_width_images):
               return
            s2 = new_canvas_x / _canvas_gallery_width_all
            s1 = (new_canvas_x - slider_width) / _canvas_gallery_width_all
            #print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
        scroll_canvas_x.set(s1, s2)
        canvas_gallery.xview('moveto', s2)
    elif len(args) == 3 and args[2] == "page":
        #print("Args: ", str(args))
        # wenn wir eine Seite nach rechts scrollen sollen, soll das Bild, das jetzt ganz oder teilweise am rechten Bildrand zu sehen ist, am linken Bildrand erscheinen
        # wenn wir 1 Seite nach links scrollen sollen, soll der Vorgänger des Bildes vollständig am rechten Bildrand sichtbar sein. Wenn das dazu führt,
        # das das Bild am linken Bildrand abgeschnitten ist, scrollen wir auf dessen Anfang
        thumbnail_last = thumbnails[_imagetype][-1]
        if int(args[1]) > 0: # scroll right
            # get thumbnail at left border
            posx = canvas_x
            dothumbnail = True
            while dothumbnail: #while because canvas_x could be on gap
                thumbnail_current, index_current = get_thumbnail_by_position(posx, canvas_y)
                if thumbnail_current is None:
                    posx += gap
                    #print("current retry...")
                else: #found
                    dothumbnail = False
            # get thumbnail at right border
            posx = canvas_x + _canvas_gallery_width_visible # start
            dothumbnail = True
            while dothumbnail:
                thumbnail, index = get_thumbnail_by_position(posx, canvas_y)
                if thumbnail is not None:
                    # we have to check, if whole canvas is filled by a very wide image (panorama), in which case we scroll by width of canvas
                    if thumbnail == thumbnail_current:
                        scrolldelta = _canvas_gallery_width_visible
                    else:
                        tfile = thumbnail.getFile()
                        #print("Image at right: " + tfile + " last: " + thumbnail_last.getFile() + " last-end: " + str(thumbnail_last.getEnd()))
                        scrolldelta = min(thumbnail.getStart() - canvas_x, thumbnail_last.getStart() - canvas_x)
                        dothumbnail = False
                else: # no thumbnail, we check if there are no more images at right
                    #print("scrolling right, end of last image: " + str(thumbnail_last.getFile()) + " " + str(thumbnail_last.getEnd()) + \
                    #  " End of canvas: " + str(canvas_x + _canvas_gallery_width_visible))
                    if canvas_x + _canvas_gallery_width_visible >= thumbnail_last.getEnd(): # no image at right position of canvas, do nothing
                        #print("*** reached the end of scrolling right, end of last image: " + str(thumbnail_last.getFile()) + " " + str(thumbnail_last.getEnd()) + " End of canvas: " + str(canvas_x + _canvas_gallery_width_visible))
                        dothumbnail = False
                        return
                    else: #could be gap, so look at position - gap
                        posx -= gap
            #print("Scroll right 1 page, scrolldelta: " + str(scrolldelta))
                    
        else: # scroll left
            posx = canvas_x
            dothumbnail = True
            while dothumbnail: #while because canvas_x could be on gap
                thumbnail_current, index_current = get_thumbnail_by_position(posx, canvas_y)
                if thumbnail_current is None:
                    posx += gap
                    #print("current retry...")
                else: #found
                    dothumbnail = False
            targetposition = max(thumbnail_current.getEnd() - _canvas_gallery_width_visible, 0) # scroll to the target which is width_visible ahead of position of left
            posx = targetposition
            dothumbnail = True
            while dothumbnail: #while because targetposition could be on gap
                thumbnail_target, index_target = get_thumbnail_by_position(posx, canvas_y)
                if thumbnail_target is None:
                    posx += gap
                    #print("target retry...")
                else: #found
                    dothumbnail = False
            tfile = thumbnail_target.getFile()
            cfile = thumbnail_current.getFile()
            #print("Target for scroll left: " + tfile + " position: " + str(targetposition) + " current at left border: " + cfile + " start: " + str(thumbnail_current.getStart()))
            # we have to check, if whole canvas is filled by a very wide image (panorama), in which case we scroll by width of canvas
            if thumbnail_target == thumbnail_current:
                scrolldelta = -_canvas_gallery_width_visible
            else:
                # if leftmost visible would completely disappear by scroll left, target is nect thumbnail
                a = targetposition - thumbnail_target.getStart() # actual scrollamount, we need the thumbnail acual at left side of cnvas
                #b = canvas_x - thumbnail_current.getStart()
                b = thumbnail_current.getEnd() - canvas_x # visible pixels
                if b < a: # current would disappear by scrolling, so take the next image
                    if index_target + 1 < len(thumbnails[_imagetype]):
                        thumbnail_target = thumbnails[_imagetype][index_target + 1]
                        #print("*** thumbnail_current would disappear after scroll left")
                scrolldelta = (thumbnail_target.getStart() - canvas_x)
            #print("Scroll left 1 page, scrolldelta: " + str(scrolldelta))

        new_canvas_x = canvas_x + scrolldelta
        # nach links scrollen machr keinen Sinn, wenn wir schon ganz links stehen, analog rechts
        if (int(args[1]) < 0 and canvas_x <= 0) or (int(args[1]) > 0 and new_canvas_x >= _canvas_gallery_width_images):
           return
        s2 = new_canvas_x / _canvas_gallery_width_all
        s1 = (new_canvas_x - slider_width) / _canvas_gallery_width_all
        #print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
        scroll_canvas_x.set(s1, s2)
        canvas_gallery.xview('moveto', s2)
    else:
        #if (1 == 0):
            #return
        canvas_gallery.xview(*args)

def text1_double(event):
    (row, col) = t_text1.index(tk.CURRENT).split(".")
    print(row, col)
    thumbnail = _dict_thumbnails_lineno[_imagetype][row]
    scrollToImage(thumbnail)
    # we dont need the file anymore because we have a method to scroll cancas to the lineno associated with thumbnail
    # but here we have a usefull code to get the text line after mouse click
    lstart = "%d.0" % int(row)
    lend   = "%d.0 lineend" % int(row)
    # tindex = "%d.0, %d.0 lineend" % (lineno, lineno + 1)
    line    = t_text1.get(lstart, lend)
    regpattern = r'[\/\\]([^\/\\.]+)\.([^\/\\.]+)' 
    #print(t_text1.index(f"@{event.x},{event.y}"), t_text1.index("current"), line)

def scrollToImage(thumbnail): # scroll to start-position of thumbnail identified by filename
    global _canvas_gallery_width_visible
    global _canvas_gallery_width_images
    global _canvas_gallery_width_all
    s1 = 0.0
    s2 = 1.0
    width_scrollbar = scroll_canvas_x.winfo_width()
    slider_width = int((_canvas_gallery_width_visible / _canvas_gallery_width_all) * width_scrollbar)
    # aktuelle Scroll-Position des Canvas
    canvas_x = canvas_gallery.canvasx(0)
    canvas_y = canvas_gallery.canvasy(0)
    # aktuelle position der Scrollbar
    scrollposition = scroll_canvas_x.get()[0]
    
    # den scrollbetrag auf die Größe des Bildes am linken Rand setzen
    if thumbnail is not None:
        scrolldelta = (thumbnail.getEnd() - canvas_x + gap)
        new_canvas_x = thumbnail.getStart()
        s2 = new_canvas_x / _canvas_gallery_width_all
        s1 = (new_canvas_x - slider_width) / _canvas_gallery_width_all
        #print ("new Scroll posiion in canvas  is: " + str(new_canvas_x) + " S1, S2 = " + str(s1) + "," + str(s2) + " slider-widt: " + str(slider_width))
    scroll_canvas_x.set(s1, s2)
    canvas_gallery.xview('moveto', s2)

def display_image(thumbnail):
    global _dict_file_image
    file = thumbnail.getShowfile()
    # wenn das Bild schon in einem Fenster angezeigt wird, dann verwenden wir dieses
    if file in _dict_file_image:
        print ("FSImage exists for file: " + file)
        fs_image = _dict_file_image[file]
        player = fs_image.getPlayer()
        if player is not None: # this is a video
            print ("FSImage restart file: " + file)
            player.restart()
            fs_image.setPlaystatus('play') # Status, Buttontext
    else: # ein neues Objekt anlegen und in _dict_file_image eintragen
        print ("FSImage does not exist for file: " + file)
        fs_image = MyFSImage(file, thumbnail, _dict_file_image)
        _dict_file_image[file] = fs_image

def show_context_menu(event):
    global context_men, _event
    # das Event müssen wir speichern, da die eigenlichen Funktionen die x und y benötigen
    _event = event
    # falls wir keine anzeigbare Datei haben, müssen wir show-Item disablen
    canvas_x = canvas_gallery.canvasx(event.x)
    canvas_y = canvas_gallery.canvasy(event.y)
    thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
    if thumbnail is not None:
        if thumbnail.getImage() == 0:
            print(" No Image availabl for " + thumbnail.getFile())
            context_menu.entryconfig(1, state="disabled")
        else:
            context_menu.entryconfig(1, state="normal")
        if thumbnail.getState() == state.INCLUDE:
            context_menu.entryconfig(0, label = "Exclude " + thumbnail.getFile())
        else:
            context_menu.entryconfig(0, label = "Include " + thumbnail.getFile())
    context_menu.entryconfig(1, label = "Show " + thumbnail.getFile())
    context_menu.post(event.x_root, event.y_root)

def canvas_button_1(event):  # we need an event to set focus to canvas in order for the arrow keys to work and we scroll text box
    canvas_gallery.focus_set()
    canvas_x = canvas_gallery.canvasx(event.x)
    canvas_y = canvas_gallery.canvasy(event.y)
    thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
    if thumbnail is not None:
        item_id = thumbnail.getId()
        print("Text sroll to lineno: ", str(thumbnail.getLineno()))
        thumbnail.scrollTextToLineno()

def canvas_gallery_exclude(event):
    #print('bbox', canvas_gallery.bbox('images'))
    canvas_gallery.focus_set()

    canvas_x = canvas_gallery.canvasx(event.x)
    canvas_y = canvas_gallery.canvasy(event.y)
    thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
    if thumbnail is not None:
        linenew = ""
        #print("State is: " + str(thumbnail.getState()))
        if thumbnail.getState() == state.INCLUDE:
            thumbnail.setState(state.EXCLUDE)
        else: # toggle to not exclude, delete Item
            thumbnail.setState(state.INCLUDE)
    historize_process()
    
def Button_exclude_all(*args):
    for thumbnail in thumbnails[_imagetype]:
        if thumbnail.getState() == state.INCLUDE:
            thumbnail.setState(state.EXCLUDE)
    historize_process()
            
def Button_include_all(*args):
    for thumbnail in thumbnails[_imagetype]:
        if thumbnail.getState() == state.EXCLUDE:
            thumbnail.setState(state.INCLUDE)
    historize_process()

def historize_process():
    global _processid_akt, _processid_high, _processid_low, _list_processids, _dict_process_image
    _processid_high += 10
    _processid_akt = _processid_high
    if _processid_akt < _processid_low: # das ist nur einmal erfüllt, da auf high value initialisiert
        _processid_low  = _processid_akt
    _list_processids.append(_processid_akt)
    print ("Processid_high is now: " + str(_processid_high) + " Processid_akt is now: " + str(_processid_akt) + " List is: " + str(_list_processids))
    # wir bilden jetzt zu der aktuellen processid eine Liste der states der thumbnails
    _dict_process_image[_processid_akt] = []
    for thumbnail in thumbnails[_imagetype]:
        _dict_process_image[_processid_akt].append(thumbnail.getState())
    update_button_state() # refer to function comment
    
    # UNDO / REDO disabeln, wenn Aktion nicht möglich, weil es keine frühere / spätere Bearbeitung gibt
    if _processid_akt > _processid_low:
        _button_undo.config(state = NORMAL)
    else:
        _button_undo.config(state = DISABLED)
    if _processid_akt < _processid_high:
        _button_redo.config(state = NORMAL)
    else:
        _button_redo.config(state = DISABLED)

def canvas_image_exclude():
    print("Context menu exlude")
    canvas_gallery_exclude(_event)

def canvas_image_show():
    print("Context menu show")
    canvas_gallery_show(_event)

def canvas_video_restart():
    print("Context menu restart")
    canvas_gallery.focus_set()

    canvas_x = canvas_gallery.canvasx(_event.x)
    canvas_y = canvas_gallery.canvasy(_event.y)
    thumbnail, index = get_thumbnail_by_position(canvas_x, canvas_y)
    if thumbnail is not None:
        player = thumbnail.getPlayer()
        if player is not None: # this is a video
            player.restart()
            
    
# Undo /Redo Funktionen
def process_undo(event):
    global _processid_akt, _processid_high, __processid_low, list_processids
    print("ctrl_z pressed.")
    if _button_undo["state"] == DISABLED:
        messagebox.showinfo("UNDO", "no further processes which can be undone")
        return
    i = len(_list_processids) - 1
    while i >= 0:
        print (" UNDO I: " + str(i) + " processid von i: " + str(_list_processids[i]) + " processid_akt: " + str(_processid_akt))
        if _list_processids[i] < _processid_akt:
            print ("  UNDO Bedingung erfuellt. I: " + str(i) + " Wert Liste: " + str(_list_processids[i]) + " processid_akt: " + str(_processid_akt))
            _list_processids.append(_list_processids.pop(i))
            break
        i -= 1
    _processid_akt = _list_processids[-1] # das oberste Element
    print (" UNDO Processid_high is now: " + str(_processid_high) + " Processid_akt is now: " + str(_processid_akt) + " List is: " + str(_list_processids))
    apply_process_id(_processid_akt)
    if _processid_akt == _processid_low:
        _button_undo.config(state = DISABLED)
    _button_redo.config(state = NORMAL)

def process_redo(event):
    global _processid_akt, _processid_high, _processid_low, _list_processids
    print("ctrl_y pressed.")
    if _button_redo["state"] == DISABLED:
        messagebox.showinfo("REDO", "no further processes which can be redone")
        return
    i = len(_list_processids) - 1
    while i >= 0:
        print (" REDO I: " + str(i) + " processid von i: " + str(_list_processids[i]) + " processid_akt: " + str(_processid_akt))
        if _list_processids[i] > _processid_akt:
            print ("  REDO Bedingung erfuellt. I: " + str(i) + " Wert Liste: " + str(_list_processids[i]) + " processid_akt: " + str(_processid_akt))
            _list_processids.append(_list_processids.pop(i))
            break
        i -= 1
    _processid_akt = _list_processids[-1] # das oberste Element
    print (" REDO Processid_high is now: " + str(_processid_high) + " Processid_akt is now: " + str(_processid_akt) + " List is: " + str(_list_processids))
    apply_process_id(_processid_akt)
    if _processid_akt == _processid_high:
        _button_redo.config(state = DISABLED)
    _button_undo.config(state = NORMAL)

def apply_process_id(process_id):
    # set thumbnail-states according actual processid
    global _processid_akt, _processid_high, _processid_low, _list_processids
    i = 0
    for thumbnail in thumbnails[_imagetype]:
        #_dict_process_image[_processid_akt].append(thumbnail.setState(_dict_process_image[process_id][i]))
        thumbnail.setState(_dict_process_image[process_id][i])
        i += 1
    update_button_state()
    
def update_button_state(): # enabled / disabled include / Exclude buttons

    #wir ermitteln, ob alle include oder exlude haben. In diesem Falls
    # disabeln wir exclude / Include All, was ja keinen Sinn hat und ggf.
    # die Historie unötig aufbläht
    count_states = 0
    count_exclude = 0
    count_include = 0
    for thumbnail in thumbnails[_imagetype]:
        if thumbnail.getState() == state.EXCLUDE:
            count_exclude += 1
        if thumbnail.getState() == state.INCLUDE:
            count_include += 1
        count_states += 1
    if count_exclude == count_states:
        _button_exclude.config(state = DISABLED)
    else:
        _button_exclude.config(state = NORMAL)
    if count_include == count_states:
        _button_include.config(state = DISABLED)
    else:
        _button_include.config(state = NORMAL)

def button_undo():
    process_undo((0, 0))
    
def button_redo():
    process_redo((0, 0))
# Ende undo / redo-Funktionen

def button_duplicates():
    global _win_duplicates
    for mytarget in _dict_duplicates[_imagetype]:
        #print("Duplcate Key: " + mytarget) 
        mylist = _dict_duplicates[_imagetype][mytarget]
        if len(mylist) > 1: # es gibt 1...n Duplicates
            print("Duplcate Key: " + mytarget)
            for mysource in mylist:
                print("   " + mysource)
    _win_duplicates = MyDuplicates() 
   
def menu_camera_new():
    global _win_camera
    _win_camera = MyCameraWindow() 

def on_window_destroy(self):
    a = 1
    #print ("Destroy called.")
    #root.instance.destroy()
    #root.withdraw()

def stop_all_players():
    # stop all video players
    if _imagetype is not None and _imagetype != "":
        for imagetype in _dict_subdirs:
            if imagetype in thumbnails:
                for t in thumbnails[_imagetype]: # stop all running players
                    thisplayer = t.getPlayer()
                    if thisplayer is not None:
                        if thisplayer.getRun(): # running
                            thisplayer.pstop()
                            #print ("Stop player for: " + t.getFile() + " playertype: " + imagetype)
 
def on_cb_num_toggle():
    if cb_num_var.get():
        canvas_gallery.itemconfigure("rect_numbers", state="normal")
        canvas_gallery.itemconfigure("numbers", state="normal")
    else:
        canvas_gallery.itemconfigure("rect_numbers", state="hidden")
        canvas_gallery.itemconfigure("numbers", state="hidden")


def clear_textbox(o):
    o.delete(0, 'end')
    
def clear_text(o):
    o.delete(1.0, 'end')

def insert_text(o, str):
    o.insert('end', str)

if __name__ == '__main__':
    Dateimeister.start_up()
    
def dateimeister(dateityp, endung, indir, thisoutdir, addrelpath, recursive, target_prefix, dict_relpath):
    # List all files and directories in the specified path, returns list
    #print("Files and Directories in '{:_<10}' typ '{:}' endung '{:}':". format(dateityp, endung, indir))
    print("Dateimeister addrelpath is: ", addrelpath)
    obj = os.scandir(indir)
    dict_result = {}
    dict_result_all = {} # we need all JPEG-Files for process_type "use_jpeg". Ignore timestamp modified
    dict_result_tooold = {} # we want to keep the files which are not copied because a newer target exist
    list_suffixes = endung.split(',')
    ii = 0
    while ii < len(list_suffixes):
        suffix = list_suffixes[ii].strip()
        list_suffixes[ii] = suffix
        ii += 1
    if recursive == "n":
        # das hier ist für nicht rekursive Aufrufe. Man verarbeitet einfach nur Files
        # os.walk scheint immer rekursiv zu funktionieren
        with os.scandir(indir) as it:
            direntries = list(it)  # reads all of the directory entries
            direntries.sort(key=lambda x: x.name)
        for entry in direntries:
            if entry.is_file():
                process = "n"
                docopy  = "n"
                filename = entry.name
                #print ("*** Entry: " + filename)
                for suffix in list_suffixes:
                    match = re.search(rf".*?\.{suffix}$", filename, re.IGNORECASE)
                    if match:
                        process = "j"
                        #print("File " + filename + " matches: " + suffix)
                        break
                if process == "j":
                    if cb_newer_var.get(): # copy only if source file is newer
                        st_mtime = entry.stat(follow_symlinks=False).st_mtime
                        strdatetime = datetime.fromtimestamp(st_mtime)
                        # check if file exists in target-dir
                        targetfilename = os.path.join(thisoutdir, target_prefix + filename)
                        #print ("F: " + filename + " mstime " + str(strdatetime) + " targetfile: " + targetfilename)
                        if os.path.isfile(targetfilename):
                            st_mtime_target = os.stat(targetfilename).st_mtime
                            strdatetime_target = datetime.fromtimestamp(st_mtime_target)
                            #print("Targetfile " + filename + " exists in " + thisoutdir + " mstime " + str(st_mtime_target))
                            if st_mtime > st_mtime_target:
                                docopy = "j"
                            else: # don't copy because targetfile has newer timestamp, but keep it in dict_result_tooold
                                docopy = "o"
                        else: # target does not exist
                            a = 1
                            docopy = "j"
                            #print("Targetfile " + filename + " does not exists in " + thisoutdir)
                    else: # copy anyway
                        docopy = "j"
                    sourcefile = os.path.join(indir,      filename)
                    targetfile = os.path.join(thisoutdir, target_prefix + filename)
                    targetfile = re.sub(r"\\", "/", targetfile) # replace single backslash by slash
                    if dateityp.upper() == "JPEG":
                        dict_result_all[sourcefile] = targetfile # we need all jpeg-files regardless of copy-status
                if docopy == "j" or docopy == "o":
                    dict_result[sourcefile] = targetfile
                if docopy == "o": # too old
                    dict_result_tooold[sourcefile] = targetfile
            if entry.is_dir():
                a = 1
                #print ("D: " + entry.name)
    else:
        # für rekursive Aufrufe scheint os.walk besser geeignet, schneller und nimmt einem die Arbeit ab, selbst zu navigieren
        print("Files and Directories in '{:_<10}' typ '{:}' endung '{:}':". format(dateityp, endung, indir))
        for root, dirs, files in os.walk(indir, topdown=True):
            for filename in files:
                filename = re.sub(r"\\", "/", filename) # replace single backslash by slash
                fullname = os.path.join(root, filename)
                relpath = ""
                process = "n"
                docopy  = "n"
                for suffix in list_suffixes:
                    match = re.search(rf".*?\.{suffix}$", filename, re.IGNORECASE)
                    if match:
                        process = "j"
                        #print("File " + filename + " matches: " + suffix)
                        break
                if process == "j":
                    if addrelpath == 'j':
                        relpath  = re.sub(re.escape(indir), '', root)
                        relpath  = re.sub(r'^[\\\/]', '', relpath)
                        target_dir = thisoutdir + '/' + relpath
                    else: 
                        target_dir = thisoutdir
                    if cb_newer_var.get(): # copy only if source file is newer
                        statinfo = os.stat(fullname)
                        st_mtime = statinfo.st_mtime
                        strdatetime = datetime.fromtimestamp(st_mtime)
                        # check if file exists in target-dir
                        #print("F: " + fullname + " mstime " + str(strdatetime) + " relpath is: " + relpath)
                        targetfilename = os.path.join(target_dir, target_prefix + filename)
                        if os.path.isfile(targetfilename):
                            st_mtime_target = os.stat(targetfilename).st_mtime
                            strdatetime_target = datetime.fromtimestamp(st_mtime_target)
                            #print("Targetfile " + filename + " exists in " + target_dir + " mstime " + str(st_mtime_target))
                            if st_mtime > st_mtime_target:
                                docopy = "j"
                            else: 
                                docopy = "o"
                        else: # target does not exist
                            a = 1
                            docopy = "j"
                            #print("Targetfile " + filename + " does not exists in " + target_dir)
                    else: # copy anyway
                        docopy = "j"
                    sourcefile = os.path.join(root,       filename)
                    targetfile = os.path.join(target_dir, target_prefix + filename)
                    targetfile = re.sub(r"\\", "/", targetfile) # replace single backslash by slash
                    if dateityp.upper() == "JPEG":
                        dict_result_all[sourcefile] = targetfile # we need all jpeg-files regardless of copy-status
                if docopy == "j" or docopy == "o":
                    dict_result[sourcefile] = targetfile
                    # we have to store relpath in dict_relpath for the delete script which deletes those relpaths if they are empty
                    # after the files have been deleted  (undo copy). From the rightmst subdir to the left we check if relpath already exists if
                    # yes we appen the rightmost portion (can be empty)
                    right = ""
                    thispath = relpath
                    thispath = re.sub(r'\\', '/', thispath)
                    if thispath != "":
                        do_process = True
                    else:
                        do_process = False
                    while do_process:
                        #print("> thispath: " + thispath)
                        if thispath in dict_relpath:
                            if right == "": # only incr +ement count of files for this dir
                                dict_relpath[thispath] += 1
                                #print("> ex. direntry: " + thispath)
                            else: # make new entry
                                newkey = thispath + '/' + right
                                dict_relpath[newkey] = 1
                                #print("> new direntry: " + newkey)
                            do_process = False # done
                        else: # remove rightmost subdir
                            #print("> dir not in dict: " + thispath)
                            match = re.search(r'([\\\/]+)(^[\\\/]+)$', thispath) # find slash followed by not slash till end
                            if match:
                                slash = match.group(1)
                                right = match.group(2)
                                to_remove = escape(ext)
                                thispath = re.sub(rf'[\\\/]{to_remove}$', '', thispath)
                                #print("> Anfang: " + thispath + " Ende: " + right)
                            else: # string without slash, 1 more try if not empty
                                if thispath != "":
                                    # was not in dir, so make an entry
                                    dict_relpath[thispath] = 1
                                    do_process = False
                                else:
                                    do_process = False
                if docopy == "o": # too old
                    dict_result_tooold[sourcefile] = targetfile
                                
                        
            for dir in dirs:
                a = 1
                #print("D: " + os.path.join(root, dir))
    return dict_result, dict_result_all, dict_result_tooold

 





